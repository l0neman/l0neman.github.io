{"pages":[{"title":"关于","text":"Android 程序员小应用轻编辑器 提示 代码无警告 文档要规范 联系e-mail: l0neman@foxmail.com 青春 - 塞缪尔·厄尔曼 ​青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的恋情；青春是生命的深泉在涌流。 ​青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，方堕暮年。 ​岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。 ​无论年届花甲，拟或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。 ​一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。","link":"/about/index.html"}],"posts":[{"title":"Android Activity 任务栈","text":"前言一个 Android 应用中与用户产生交互的一系列 Android 被称为任务，Android 系统使用栈来管理这些 activity，它们的行为如下： 当在桌面点击一个应用图标打开主界面时，如果之前没有打开过这个应用，将会创建一个全新的任务栈，并把主界面的 activity1 作为栈底元素入栈，当用户从主界面依次打开 activity2, activity3 时，它们会被依次压入栈中，此时栈内元素为 activity1, activity2, activity3，用户点击返回键时，activity3将被被执行 finish 操作，同时将会出栈，activity2 恢复，继续点击返回键，直到退回到主界面时，如果再次点击返回键，则应用退出，任务栈被销毁。 不同应用可以指定相同的任务，同一个应用中的 Android 也可存在于多个任务中，还可使用一些选项影响 Android 在任务栈中的行为。更详细的文档可以参考官方指南： AndroidAPI 指南：任务和返回栈 下面对和任务栈相关的选项和配置进行详细分析： Android 选项以下选项是在 android 配置文件中的 &lt;activity/&gt; 标签下所指定的选项。 taskAffinity字符串属性 ，用来指定与 Android 相关联的任务，应用内所有 Android 的默认任务为应用对应的包名，所以指定时应该不同于本应用包名，在这个 Android 指定了 allowTaskReparenting 选项时或者启动 Android 的 Intent 带有 FLAG_ACTIVITY_NEW_TASK 标记时，Android 可能会被移动到指定的任务栈中。 如果从用户的角度来看，一个 .apk 文件包含多个“应用”，可能需要使用 taskAffinity 属性将不同关联分配给与每个“应用”相关的 Activity。 allowTaskReparenting指定 Android 所在的任务切换至前台时，Android 能否从该任务切换到相关联的任务，true 表示可以转移，默认为 false。 例如，应用 1 的主 Android a 启动了 应用2的 Android b2，则 b2 和 a 在同一个任务栈中，此时切换到后台，点击桌面图标进入应用 2，应用 2 的主 Android 是 a2，如果 b2 的 allowTaskReparenting 选项开启，则此时显示的是b2，点击返回键后可退到 a2，这是由于应用 1 在切换到后台时，b2 已被转移到与其相关联的任务栈中，如果 b2 使用 taskAffinity 属性指定了与 a2 不同的任务，则不会发生以上的任务切换。 excludeFromRecents布尔属性，是否将 Android 启动的任务排除在最近使用的应用列表之外（Android 5.0 展示为可滑动清除的卡片列表），此选项仅对任务的根 Android 有效，任务的根 Android 指定此选项后，其所在任务不会在最近应用列表出现。 alwaysRetainTaskState布尔属性，是否始终保持 Activity 所在任务的状态，如果为 false，系统可能在一段时间后，清空当前任务（清除根 Android 之上的所有 activity），当用户再次切换到此应用时，只能看到根 activity，如果为 true，则会始终保持切换到后台前的状态。此选项只对任务的根 Android 有效。 clearTaskOnLaunch布尔属性，每次用户点击桌面图标打开任务时，都将清除任务的根 Android 之上的所有 activity， 只保留根 activity，如果 Android 中有 allowTaskReparenting 选项开启，则该 Android 将会转移到与其相关联的任务中，此选项只对任务的根 Android 有效。 finishOnTaskLaunch布尔属性，每次用户点击桌面图标打开任务时，将会关闭开启此选项的 activity，如果 Android 中有 allowTaskReparenting 选项开启，优先执行此选项。 autoRemoveFromRecents布尔属性，api21可用，指定是否在根 Android 执行 finish 之后，从最近应用列表中移除任务。 maxRecents数字属性，概览屏幕中位于此 Activity 根位置的任务数上限。 达到该条目数时，系统会从概览屏幕中移除最近最少使用的实例。 有效值为 1-50（低内存设备使用 25）；0 为无效值。 该值必须是整数，例如 50。默认值为 16。 noHistory布尔属性，当用户离开 Android 并且其不再屏幕上展示时，是否将其从任务栈中移除并执行 finish 操作。 测试结论，如果此属性设置在根 Android 上时， 如果任务只有根 activity，则在返回桌面再切换到应用时，根 Android 将不会被关闭 如果在根 Android 之上有未开启 noHistory 选项的 activity，则在返回桌面再切换到应用时，则根 Android 会被 finish，只留下其上的 activity。 当任务中的所有 Android 都开启了 noHistory 选项后，切换到应用时，会清空根 Android 之上的所有 activity。 启动模式-launchMode以下4种启动模式，是在清单文件配置中 &lt;activity/&gt; 标签下 launchMode 属性的所有取值。 standard标准模式，所有 Android 默认的启动模式，每次使用 Intent 启动 activity，都会创建一个新的 Android 实例，每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。 singleTop和 standard 模式的唯一区别是，如果目标 Android 在当前任务的栈顶已经存在一个实例并且指定了 singleTop 启动模式，则不会创建新实例，只会回调它的 onNewIntent 方法传递启动的 Intent，如果目标 Android 不在栈顶，则行为和 standard 模式一致，当 Android 出现在其他任务栈时，需要和 Intent.FLAG_ACTIVITY_NEW_TASK 模式组合使用，才能在其他任务栈内寻找栈顶的 activity，并回调其 onNewIntent 方法。 singleTask首先寻找 Android 所在任务，如果找到与 Android 关联的任务，并且不存在 Android 实例，将会创建 Android 实例，如果在 Android 关联任务中已存在目标 Android 实例，则不会创建新实例，并且回调其 onNewIntent 方法传递启动的 Intent，当目标 Android 之上有 Android 存在时（任务栈中），将会清空其上的所有 activity，即将目标 Android 置于栈顶，此启动模式有 Intent.FLAG_ACTIVITY_NEW_TASK 的作用，如果找不到 Android 关联任务，则会创建新的任务，并在任务中创建新的 Android 实例作为任务的根 activity。 singleInstance与 singleTask 的唯一区别是，它只允许任务栈中存在唯一的目标 Android 的实例，不允许其他 Android 在任务中和其共存，即使不指定 taskAffinity 属性，使用 singleInstance 启动模式的 Android 也会在新的任务中出现。 启动模式-IntentFlag以下是在启动 Activity 的 Intent 中可使用 addFlag 方法指定的部分和任务栈相关的标记。 FLAG_ACTIVITY_CLEAR_TASK在启动 Android 时，首先清空 Android 关联任务栈（任务栈内的 Android 全部执行 finish），此标记只能与 Intent.FLAG_ACTIVITY_NEW_TASK 联合使用。 FLAG_ACTIVITY_CLEAR_TOP如果当前任务中存在 Android 实例，则会销毁当前任务栈中目标 Android 之上的所有 acitivty，然后回调目标 Android 的 onNewIntent 方法传递启动 Activity 的 Intent，若找不到，则创建新的 Android 实例，一般和 Intent.FLAG_ACTIVITY_NEW_TASK 结合使用，结合后，可在其它任务栈中找到目标 Android 的实例，并执行和上面相同描述的操作，否则不会在其他任务栈中寻找 activity。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS设置后，Android 所在任务将不会在最近任务列表展示（概览屏幕），只对任务的根 Android 有效，如果在当前任务中的 Android 启动新 Android 时设置此标记，则 activty 依然会在最近任务列表中展示，所以设置此标记，需要配合 Intent.FLAG_ACTIVITY_NEW_TASK 在新的任务中启动 activity，这个新任务将不会在最近任务列表中展示。 FLAG_ACTIVITY_NEW_TASK首先寻找 Android 关联的任务，如果找不到，就创建新的任务，并且创建新的 Android 实例并入栈，如果找到 Android 关联任务，里面没有 Android 实例，则创建新的 Android 实例入栈，如果关联任务栈内已存在 Android 实例，则判断任务栈是否处于前台状态，若处于前台，则无动作，否则将关联的任务提到前台。 FLAG_ACTIVITY_NO_HISTORY使用此标记启动的 Android 将和在清单文件中开启 noHsitory 选项有相同的作用。 FLAG_ACTIVITY_SINGLE_TOP使用此标记启动 Android 时，将和在清单文件中开启 singleTop 选项有相同的作用。 FLAG_ACTIVITY_FORWARD_RESULT适用于在使用了 startForResult 方法启动的 Android 中启动新 Android 时设置此标记，如果设置了此标记，那么即是使用了 startForResult 方法启动的 Android 将返回结果的权力交给了使用此标记启动的 activity，即使用 setResult 方法传递结果的权力，那么期待返回结果的 Android 将收到此标记启动 Android 返回的结果。 FLAG_ACTIVITY_MULTIPLE_TASK只能和 FLAG_ACTIVITY_NEW_DOCUMENT 或 FLAG_ACTIVITY_NEW_TASK 组合使用，使用此标记将强制创建新的任务并创建新的 Android 入栈。 FLAG_ACTIVITY_NEW_DOCUMENTapi21可用，与 FLAG_ACTIVITY_NEW_TASK 的不同点是，如果任务栈中没有 Android 实例， 即使未指定 Android 的 taskAffinity 属性，也将创建新的任务，并当 Android 入栈，当 Android 所在的任务退出后，最近任务列表里也将不再出现这个任务。 FLAG_ACTIVITY_NO_ANIMATION启动 Android 时关闭动画 FLAG_ACTIVITY_RESET_TASK_IF_NEEDEDFLAG_ACTIVITY_RETAIN_IN_RECENTS使用 FLAG_ACTIVITY_NEW_DOCUMENT 启动的文档界面会在执行 finish 之后从最近任务列表中移除，使用这个标志可以使其保留在最近任务列表中，可以使用户重新启动这个文档。 FLAG_ACTIVITY_TASK_ON_HOME当启动此 Android 后，点击返回键将返回系统桌面，需要和 FLAG_ACTIVITY_NEW_TASK 结合使用。","link":"/2019/02/12/android-activity-%E4%BB%BB%E5%8A%A1%E6%A0%88/"},{"title":"8086 贪吃蛇","text":"运行环境：MsDos 7.1 或 DOSBox 键盘方向键控制 演示 汇编代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636assume cs:code, ds:data, ss:stack; gpu prop byte; 7 6 5 4 3 2 1 0; BL R G B I R G B; | \\_____/ | \\_____/; 闪烁 背景 高亮 前景; game map: 25 x 25; snake bodys max: 23 x 23data segment score dw 0 ; game score scpre db 'score:' ; [6] score prefix dead db 'game over!' ; [10] game over food dw 0 ; snake food: x|y sdct db 0 ; snake direction 0001-up 0010-down 0100-left 1000-right slen db 0 ; snake length body dw 529 dup(0) ; snake bodys: x|y, ...data endsstack segment dw 20 dup(0)stack endscode segmentstart: mov ax, data mov ds, ax ; init data seg mov ax, 0b800h mov es, ax ; save gpu base addr mov ax, stack mov ss, ax mov sp, 20 ; init stack call clear mov ah, 24 mov al, 24 push ax call draw_map call create_snake call draw_snake call create_food call draw_food call start_game call show_scoreend_game: call game_over mov ax, 4c00h int 21h ; # start game; void -&gt; voidstart_game: mov cx, 50 sg0: call listen_key call clear_last call move_snake call is_dead call draw_snake call is_eat call show_score call sleep loop sg0 ret; # show game over alert; void -&gt; voidgame_over: push ax push cx push si mov si, 28 mov cx, 10 ; string lengthgo0: mov ax, si mov ah, al mov al, 12 push ax mov ah, 00000111b mov al, dead[si - 28] push ax call draw_char inc si loop go0 pop si pop cx pop ax ret; # is the snake dead; void -&gt; voidis_dead: push ax push cx push si mov ax, body[0] ; get head cmp ah, 0 ; touch the edge je end_game cmp ah, 24 je end_game cmp al, 0 je end_game cmp al, 24 je end_game mov ch, 0 mov cl, slen dec cx mov si, 2 ; start with secondid0: ; touch self body mov ax, body[si] cmp body[0], ax je end_game add si, 2 loop id0 pop si pop cx pop ax ret; # add snake body; void -&gt; voidadd_body: push ax push si mov ah, 0 mov al, slen inc al mov slen, al ; add body mov si, ax add si, si mov ax, body[si - 4] mov body[si - 2], ax inc score call create_food call draw_food pop si pop ax ret; # is snake eat food; void -&gt; voidis_eat: push ax mov ax, food cmp ax, body[0] jne nt0 call add_bodynt0: pop ax ret; show game score; void -&gt; voidshow_score: push ax push bx push si mov si, 28 mov cx, 6 ; string lengthpo0: ; draw score prefix mov ax, si mov ah, al mov al, 2 push ax mov ah, 00000111b mov al, scpre[si - 28] push ax call draw_char inc si loop po0 mov si, 0 mov ax, scoresl0: mov bh, 0 mov bl, 10 div bl mov bx, ax mov bl, bh mov bh, 0 push bx ; save digit inc si ; count digits cmp al, 0 ; no more digit je se0 mov ah, 0 ; next digit jmp short sl0se0: mov cx, si mov si, 34 ; show start xsn0: pop bx ; get each digit add bx, 30H ; get digit ascii mov ax, si mov ah, al mov al, 2 push ax mov ah, 00000111b mov al, bl push ax call draw_char ; draw each digit inc si loop sn0 pop si pop bx pop ax ret; # listen to keys; void -&gt; voidlisten_key: push ax mov ah, 1 mov al, 0 int 16h ; keboard interrupt cmp ah, 1 je lk0 mov ax, 0 int 16h cmp ax, 4800h ; press up je kup cmp ax, 5000h ; press down je kdown cmp ax, 4b00h ; press left je kleft cmp ax, 4d00h ; press right je kright jmp short lk0 kup: cmp sdct, 0010b ; direction conflict je lk0 mov sdct, 0001b ; set direction jmp short lk0kdown: cmp sdct, 0001b je lk0 mov sdct, 0010b jmp short lk0kleft: cmp sdct, 1000b je lk0 mov sdct, 0100b jmp short lk0kright: cmp sdct, 0100b je lk0 mov sdct, 1000b lk0: pop ax ret; # clear last snake body; void -&gt; voidclear_last: push ax push si mov ah, 0 mov al, slen mov si, ax add si, si mov ax, body[si - 2] ; last body push ax mov ah, 00000000b mov al, ' ' push ax call draw_char ; clear pop si pop ax ret; # update snake bodys; void -&gt; voidmove_snake: push ax push cx push si mov ch, 0 mov cl, slen dec cx mov ah, 0 mov al, slen mov si, ax add si, sims0: mov ax, body[si - 4] mov body[si - 2], ax sub si, 2 loop ms0 mov ax, body[0] ; upd head cmp sdct, 0001b ; up je up cmp sdct, 0010b ; down je down cmp sdct, 0100b ; left je left cmp sdct, 1000b ; right je right up: dec al jmp short uokdown: inc al jmp short uokleft: dec ah jmp short uok right: inc ah jmp short uokuok: mov body[0], ax pop si pop cx pop ax ret; # draw snake to map; void -&gt; voiddraw_snake: push cx push si push ax mov ch, 0 mov cl, slen mov si, 0ds0: mov ax, body[si] push ax mov ah, 01110000b mov al, ' ' push ax call draw_char ; draw body add si, 2 loop ds0 pop ax pop si pop cx ret; # create snake; fixed: snake size is 3; void -&gt; voidcreate_snake: push cx push si push ax mov sdct, 1000b ; set direct is right mov ah, 1 mov al, 1 mov slen, 2 ; set snake length mov ch, 0 mov cl, slen mov si, 0 mov ah, 6 ; set snake head x mov al, 4 ; set snake head yc0: mov body[si], ax dec ah add si, 2 loop c0 pop ax pop si pop cx ret; draw food to map; void -&gt; voiddraw_food: push ax mov ax, food push ax mov ah, 00101000b mov al, ' ' push ax call draw_char ; draw food pop ax ret; # create a food; fixed: map width and height; void -&gt; voidcreate_food: push ax push bx push cx push dx push sire0: mov bx, 23 push bx call rand ; get x inc dx ; range: 1-[23] mov ah, dl push bx call rand ; get y inc dx mov al, dl mov ch, 0 mov cl, slen mov si, 0sb0: ; for snake body cmp ax, body[si] je re0 ; conflict with body, create again add si, 2 loop sb0 mov food, ax ; save food xy pop si pop dx pop cx pop bx pop ax ret; # rand number; 0: range -&gt; dx: 0~(range)rand: push bp mov bp, sp push ax mov ax, 0h out 43h, al in al, 40h in al, 40h in al, 40h mov bx, [bp + 4] div bl mov dh, 0 mov dl, ah pop ax pop bp ret 2; # sleep tiem; void -&gt; voidsleep: push cx mov cx, 50000 s0: push cx mov cx, 20 s1: loop s1 pop cx loop s0 pop cx ret ; # draw game map; 0: width|height -&gt; voiddraw_map: push bp mov bp, sp ; draw top push cx push ax push bx push dx mov dx, [bp + 4] ; get width mov ax, 0 mov ch, 0 mov cl, dh ; set width inc cl d0: mov bh, al ; draw top mov bl, 0 push bx mov bh, 00010000b mov bl, ' ' push bx call draw_char mov bh, al ; draw bottom mov bl, dl push bx mov bh, 00010000b mov bl, ' ' push bx call draw_char inc al loop d0 mov cl, dl ; set height dec cl ; inside content height mov al, 1 d1: mov bh, 0 ; draw left mov bl, al push bx mov bh, 00010000b mov bl, ' ' push bx call draw_char mov bh, dh ; draw bottom mov bl, al push bx mov bh, 00010000b mov bl, ' ' push bx call draw_char inc al loop d1 pop dx pop bx pop ax pop cx pop bp ret 2 ; # draw char to screen; 0: x|y, 1: prop|char -&gt; voiddraw_char: push bp mov bp, sp push ax push bx push si mov bx, [bp + 6] mov ah, 0 mov al, 0a0h mul bl ; set y mov bl, bh mov bh, 0 add bl, bl add bl, bl add ax, bx ; set x mov si, ax mov ax, [bp + 4] mov es:[si], ax ; set prop and char cmp al, ' ' jne jm0 mov es:[si + 2], ax ; for edge, double draw. jm0: ; for normal char pop si pop bx pop ax pop bp ret 4 ; # clear screen; void -&gt; voidclear: mov ax, 3h int 10h ret code endsend start","link":"/2020/06/03/8086-%E8%B4%AA%E5%90%83%E8%9B%87/"},{"title":"Xposed 框架的使用","text":"Xposed 简介Xposed 框架是 Android 平台上一个非常著名且强大的开源框架，使用它能够对系统进程内运行的方法进行 hook，所以可以用它来做一些系统层面的工作，它拥有无限可能的灵活性，目前市面上基于 Xposed 框架下开发 Xposed 子模块已经数不胜数了。 原理简析Android 系统运行的核心和起点是 Zygote 进程，所有应用都是从它 fork 子进程产生的，当系统开始运行时由 init.rc 脚本启动， 使用 /system/bin/app_process 程序完成启动，它加载所需的类并调用初始化方法。 Xposed 框架将在这个地方发挥作用，当 Xposed 框架被安装时，一个被扩展的 app_process 程序将被复制到 /system/bin/ 中，这个扩展的 app_process 将向类的路径附加一个 jar 文件，并在某些位置调用其方法，可能是虚拟机创建之后，或者在 Zygote 进程的 main 方法之前。在这个方法里，我们可以在其上下文中做插桩。 环境配置Xposed 框架会替换系统的关键文件，所以需要 root 权限，获取 root 权限之后，安装 Xposed 框架。 Xposed 下载地址: http://repo.xposed.info/module/de.robv.android.xposed.installer 安装 Xposed 框架的 APK 后，进入并点击 INSTALL/UPDATE 下面的版本号，即可开始安装。 提示：安装可能会导致设备无限重启或变砖，所以一定要确认适合自己的设备后再安装。 模块开发Xposed 框架安装完毕后即可进行 Xposed 模块的开发，我们自定义的功能都是在 Xposed 模块中实现的。 它是一个普通的 APK，包含一些实现 Xposed 依赖库提供的特定接口的类，当它被安装到设备后，被 Xposed 框架调起发挥作用，下面开始进行 Xposed 模块的开发。 项目依赖首先添加项目依赖。 确认根 Project 或 Module 添加了 jcenter 的仓库渠道。 123repositories { jcenter();} 添加 Xposed 库的编译支持。 Android Studio 3.0+ 的版本 123dependencies { compileOnly 'de.robv.android.xposed:api:82'} 低于 3.0 的版本 123dependencies { provided 'de.robv.android.xposed:api:82'} 注意：这里的选项是指定只参与编译，不需要真正的导入它的类，因为系统的 Xposed 框架内已经提供了这些类，所以不要用 implementation(Studio 3.0+) 和 complie(lower than 3.0)。 方法钩子方法钩子是 Xposed 的核心功能，一般通过对 APK 反编译后进行修改的方式，可以在任何位置插入和更改代码，但是必须重新编译打包整个包。使用 Xposed 可以放置方法钩子，不能修改方法代码，不过可以在方法调用的前后插入代码。 XposedBridge 中有一个私有的 hookMethod 本地方法，它在扩展后的 app_process 中实现，它可以将方法更改为本地方法，并链接到自己的泛型本地方法，每次调用钩子方法时，都将调用泛型方法，但是调用方无需知晓，在这个方法中，会调用 XposedBridge 的 handleHookedMethod 方法，handleHookedMethod 则会调用注册的回调方法。这里可以更改调用的参数、更改实例或静态变量、调用其他方法或对结果执行某些操作…或者跳过任何内容。 下面在 Android Studio 中创建一个 Module，在 AndroidManifet.xml 的 application 标签中添加 3 个 meta-data 标签。 12345678910111213&lt;application android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot; /&gt; &lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;Easy example which makes the status bar clock red and adds a smiley&quot; /&gt; &lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;82&quot; /&gt;&lt;/application&gt; xposedmodule 是固定的配置，说明自己是一个 Xposed 模块。 xposeddescription 是 Xposed 模块的简要描述，在 Xposed 框架应用中会展示出来。 xposedminversion 是 Xposed 模块的 API 版本，通常情况下，和使用的 Xposed API 版本应该一致。 实现 IXposedHookLoadPackage 接口，这个是放置方法钩子的入口点，如果需要实现资源替换，需要实现另外的接口，当 Android 系统启动时，每一个应用加载启动时都会回调这个接口。 12345678package io.l0neman.xposedproject;public class MyXposedStub implements IXposedHookLoadPackage { @Override public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { /* 激活模块后，使用 Xposed 作为标签过滤即可看到每个加载的应用包名 */ XposedBridge.log(&quot;Loading app: &quot; + lpparam.packageName);} 最后需要配置入口点，在 assets 目录下，建立一个 xposed_init 文件，它的每行都可以指定一个入口点的全类名。 1io.l0neman.xposedproject.MyXposedStub 现在安装 APK，然后打开 Xposed 框架，勾选这个模块，重启手机，就能看到日志。 123456Loading Xposed (for Zygote)...Loading modules from /data/app/io.l0neman.xposedproject-1.apk Loading class io.l0neman.xposedprojectLoaded app: com.android.systemuiLoaded app: com.android.settings... 上面的基础工作做完了，现在就可以使用 XposedHelpers 的辅助方法来获取方法钩子了，下面对一个应用的 Application 类进行 hook。 1234567891011121314151617181920212223public class MyXposedClient implements IXposedHookLoadPackage { @Override public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { /* 激活模块后，使用 Xposed 作为标签过滤即可看到每个加载的应用包名 */ XposedBridge.log(&quot;Loading app: &quot; + lpparam.packageName); if (!lpparam.packageName.equales(&quot;com.android.systemui&quot;)) { return; // 过滤目标包名 } XposedHelpers.findAndHookMethod(Application.class, &quot;attach&quot;, Context.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { /* 可以更改 hook 方法的行为 */ // param.setResult(null); // param.setThrowable(new Throwable()); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { /* 获取到了 attach 方法的 context 参数 */ Context context = (Context) param.args[0]; } });} 除了以上的方法 hook 之外，也可对应用内的任意类型进行反射获取。 资源替换目前还没有使用资源替换的方法，后续会补充。 避免重启的方法每次更改 Xposed 模块的代码后，都需要从新启动 Android 设备，非常不利于调试，所以可以用一种方法只在第一次重启，以后都不用重启了。 原理就是，首先编写一个 XposedStub APK，然后在其中通过包名的形式寻找另一个实现 Xposed 逻辑的 APK，通过动态加载的方式加载调用 APK 中的类和方法，这时只需要每次更改实现逻辑的 APK 即可，无需重启刷新 XposedStub 这个 APK 里面的逻辑了，相当于搭了一个桥梁。 首先实现一个实现逻辑的 APK，这里我需要一个能够 hook 类的方法，创建一个参数接收的类。 1234567891011package io.l0neman.xposedproject;import android.util.Log;import de.robv.android.xposed.callbacks.XC_LoadPackage;public class MyXposedClient { private static final String TAG = &quot;MyXposedClient&quot;; public static void handle(String seflApkPath, XC_LoadPackage.LoadPackageParam llparam) { Log.d(TAG, &quot;accept ok: &quot; + llparam.packageName); }} 然后编写 XposedStub APK，它将作为一个和 Xposed 框架通信的中间角色，接收 Xposed 框架的回调结果，并转交给目标 APK，下面是具体逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MyXposedStub implements IXposedHookLoadPackage { private static final String TAG = &quot;MyXposedStub&quot;; /* 目标 APK 包名 */ private static final String TARGET_PACKAGE_NAME = &quot;io.l0neman.xposedproject&quot;; /* 目标 APK 内的类型 */ private static final String TARGET_INJECT_CLASS_NAME = &quot;MyXposedClient&quot;; /* 目标 APK 类的方法 */ private static final String TARGET_INJECT_METHOD = &quot;handleLoadPackage&quot;; @Override public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { log(&quot;loading app: &quot; + lpparam.packageName); /* hook Application 类，为了获取 Context 对象 */ XposedHelpers.findAndHookMethod(Application.class, &quot;attach&quot;, Context.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { Context context = (Context) param.args[0]; callTarget(context, lpparam); } }); } /* 使用 context ，寻找目标 APK 的安装包并调用目标方法 */ private void callTarget(Context context, XC_LoadPackage.LoadPackageParam lpparam) throws Exception { File apkPath = findApkPath(context, TARGET_PACKAGE_NAME); if (apkPath == null) { return; } log(&quot;hit apk: &quot; + apkPath); PathClassLoader pathClassLoader = new PathClassLoader( apkPath.getAbsolutePath(), ClassLoader.getSystemClassLoader() ); /* 反射获取目标值类并调用其方法 */ Class&lt;?&gt; targetClass = Class.forName(TARGET_INJECT_CLASS_NAME, true, pathClassLoader); Method handle = targetClass.getMethod(TARGET_INJECT_METHOD, String.class, XC_LoadPackage.LoadPackageParam.class); handle.invoke(null, apkPath.getPath(), lpparam); log(&quot;inject ok&quot;); } /* 返回 APK 的安装包文件路径，每个 APK 安装后都会有，data/app/com.xxx.xxx/base_x.apk */ private static File findApkPath(Context context, String packaegName) { if (context == null) { throw new AssertionError(&quot;context is null&quot;); } try { Context targetContext = context.createPackageContext(packaegName, Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY ); String apkPath = targetContext.getPackageCodePath(); return new File(apkPath); } catch (PackageManager.NameNotFoundException ignore) {} return null; } private void log(String log) { Log.d(TAG, log); }} 提示编写 Xposed 模块时需要清楚的知道自己的代码处于什么环境，当 handleLoadPackage 被回调时，说明一个新的代码包（常见为一个新的应用）被加载起来了，此时下面的代码将运行在目标应用的进程中，当模块具有 UI 界面时，模块的代码将分别运行在本身的应用进程和注入的目标应用进程中，如果需要进行设配置，可能需要进行进程间通信。 由于一些原因，Xposed 框架的作者不再提供 Android 9 系统之上的版本，如果需要在 Android 9 平台或以上版本使用 Xposed，推荐使用基于 Magisk（面具框架）的 EdXposed 替代，目前它的最新版本具有即时更新模块的功能，不用再重启设备了。 Magisk 地址：https://github.com/topjohnwu/Magisk Edxposed 地址：https://github.com/ElderDrivers/EdXposed 参考 https://github.com/rovo89/XposedBridge/wiki https://api.xposed.info/reference/packages.html","link":"/2020/06/03/xposed-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Git 常用命令","text":"初始化 首次安装后设置名字和 email 地址。 123git config --global user.name &quot;YourName&quot;git config --global user.email &quot;email@example.com&quot; 创建 ssh Key。 1ssh-keygen -t rsa -C &quot;email@example.com&quot; 进入目录并初始化为 git 仓库。 1git init 文件更改 放弃文件在工作区的修改。 1git checkout -- &lt;文件名&gt; 添加文件到暂存区。 1git add &lt;文件/路径名&gt; 撤销存放到暂存区的文件。 1git reset HEAD &lt;文件/路径名&gt; 查看文件修改部分。 1git diff HEAD -- &lt;文件/路径名&gt; 提交文件至仓库。 121. 提交并添加注释。git commit -m &quot;注释&quot; 122. 修改最近的提交注释。git commit -amend 删除并添加到缓存区。 1git rm &lt;文件名&gt; 仓库状态 查看当前仓库状态。 1git status 查看提交日志。 1git log [--pretty=oneline] (参数为简化为单行显示) 查看命令执行历史记录。 1git reflog 版本控制 回退版本, ^ 表示回退到上一个版本， ^^ 表示上上一个，以此类推。 1git reset --hard HEAD^ 分支管理 创建并切换到目标分支。 1git checkout -b &lt;分支&gt; 切换到目标分支。 1git branch &lt;分支&gt; 查看分支。 1git branch 查看分支合并图 1git log --graph 整理分支提交历史为直线。 1git rebase 合并目标分支到当前分支，相当于指针直接指向目标分支。 1git merge &lt;分支&gt; 合并目标分支到当前分支并禁用 Fast forward 模式（非指针指向，而是提交和目标分支同样的内容）。 1git merge --no-ff -m &quot;合并注释&quot; &lt;分支&gt; 删除目标分支。 1git branch -d &lt;分支&gt; 现场保存 保存当前工作现场。 1git stash 查看保存的 stash。 1git stash list 恢复同时删除 stash 内容。 1git stash pop 恢复 stash 内容。 1git stash apply &lt;stash id&gt; 删除 stash 内容。 1git stash drop 标签使用 为当前提交创建标签。 1git tag &lt;标签&gt; 为目标提交记录（通过指定 commit id）创建标签。 121. 为 id 是 &lt;commit id&gt; 的提交记录创建标签。git tag &lt;标签&gt; &lt;commit id&gt; 122. 创建标签的同时附加注释。git tag -a &lt;标签&gt; -m &quot;标签注释&quot; &lt;commit id&gt; 列出所有 tag。 1git tag 查看目标 tag 详情。 1git show &lt;标签&gt; 删除标签。 1git tag -d &lt;标签&gt; 推送标签至远程库 121. 推送标签 myTag 至远程库。git push origin &lt;标签&gt; 122. 推送所有标签至远程库。git push origin --tags 从远程库删除标签。 123451. 先从本地删除。git tag -d &lt;标签&gt;2. 然后从远程库删除。git push origin :refs/tags/&lt;标签&gt; 远程库 添加本地库到远程库。 1git remote add origin &lt;远程库地址&gt; 首次推送到远程库。 1git push -u origin &lt;分支名&gt; 推送到远程库。 1git push origin &lt;分支名&gt; 克隆远程库到本地。 1git clone &lt;远程库地址&gt; 忽略规则GitHub 提供：https://github.com/github/gitignore android.gitignore 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Built application files*.apk*.ap_*.aab# Files for the ART/Dalvik VM*.dex# Java class files*.class# Generated filesbin/gen/out/release/# Gradle files.gradle/build/# Local configuration file (sdk path, etc)local.properties# Proguard folder generated by Eclipseproguard/# Log Files*.log# Android Studio Navigation editor temp files.navigation/# Android Studio captures foldercaptures/# IntelliJ*.iml.idea/workspace.xml.idea/tasks.xml.idea/gradle.xml.idea/assetWizardSettings.xml.idea/dictionaries.idea/libraries# Android Studio 3 in .gitignore file..idea/caches.idea/modules.xml# Comment next line if keeping position of elements in Navigation Editor is relevant for you.idea/navEditor.xml# Keystore files# Uncomment the following lines if you do not want to check your keystore files in.#*.jks#*.keystore# External native build folder generated in Android Studio 2.2 and later.externalNativeBuild# Google Services (e.g. APIs or Firebase)# google-services.json# Freelinefreeline.pyfreeline/freeline_project_description.json# fastlanefastlane/report.xmlfastlane/Preview.htmlfastlane/screenshotsfastlane/test_outputfastlane/readme.md# Version controlvcs.xml# lintlint/intermediates/lint/generated/lint/outputs/lint/tmp/# lint/reports/","link":"/2020/06/05/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"正则表达式参考","text":"1. 常用的元字符 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 2. 常用的限定符 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复 n 次 {n,} 重复 n 次或更多次 {n,m} 重复 n 到 m 次 3. 常用的反义代码 代码/语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了 x 以外的任意字符 [^aeiou] 匹配除了 aeiou 这几个字母以外的任意字符 4. 常用分组语法 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?&lt;name&gt;exp) 匹配 exp, 并捕获文本到名称为 name 的组里，也可以写成 (?’name’exp) (?:exp) 匹配 exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配 exp 前面的位置 (?&lt;=exp) 匹配 exp 后面的位置 (?!exp) 匹配后面跟的不是 exp 的位置 (?&lt;!exp) 匹配前面不是 exp 的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 5. 懒惰限定符 代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复 1 次或更多次，但尽可能少重复 ?? 重复 0 次或 1 次，但尽可能少重复 {n,m}? 重复 n 到 m 次，但尽可能少重复 {n,}? 重复 n 次以上，但尽可能少重复 6. 其他语法 代码/语法 说明 \\a 报警字符 (打印它的效果是电脑嘀一声) \\b 通常是单词分界位置，但如果在字符类里使用代表退格 \\t 制表符，Tab \\r 回车 \\v 竖向制表符 \\f 换页符 \\n 换行符 \\e Escape \\0nn ASCII 代码中八进制代码为 nn 的字符 \\xnn ASCII 代码中十六进制代码为 nn 的字符 \\unnnn Unicode 代码中十六进制代码为 nnnn 的字符 \\cN ASCII 控制字符。比如 \\cC 代表 Ctrl+C \\A 字符串开头 (类似 ^，但不受处理多行选项的影响) \\Z 字符串结尾或行尾 (不受处理多行选项的影响) \\z 字符串结尾 (类似 $，但不受处理多行选项的影响) \\G 当前搜索的开头 \\p{name} Unicode 中命名为 name 的字符类，例如 \\p{IsGreek} (?&gt;exp) 贪婪子表达式 (?&lt;x&gt;-&lt;y&gt;exp) 平衡组 (?im-nsx:exp) 在子表达式 exp 中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes|no) 把 exp 当作零宽正向先行断言，如果在这个位置能匹配，使用 yes 作为此组的表达式；否则使用 no (?(exp)yes) 同上，只是使用空表达式作为 no (?(name)yes|no) 如果命名为 name 的组捕获到了内容，使用 yes 作为表达式；否则使用 no (?(name)yes) 同上，只是使用空表达式作为 no","link":"/2020/06/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%82%E8%80%83/"},{"title":"Android ClassLoader 简析","text":"ClassLoader 加载机制ClassLoader 是一个抽象类，它为 Java 虚拟机上运行的进程提供类加载的操作，它定义了类加载器的标准接口，具体加载类的逻辑，以及加载类的路径由其具体子类实现。 ClassLoader 对外提供一个 loadClass 方法，使用时调用此方法并传入符合 java 标准的全类名参数，将会返回一个 Class&lt;?&gt; 对象，通过查看 loadClass 方法的实现可以了解到类加载器的加载机制。 1234567891011121314151617181920212223242526272829// java.lang.ClassLoader...public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { return loadClass(name, false);}protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // 首先，检查该类是否已经加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // 如果从不是 null 的父类加载器中找不到类，则抛出 ClassNotFoundException } if (c == null) { // 如果仍然找不到，则从当前 ClassLoader 类路径按顺序调用 findClass c = findClass(name); } } return c;} 从上述代码了解到，ClassLoader 加载机制基于一个叫“双亲委派模型”的东西，会优先从父加载器中加载类。 除了最顶层的 ClassLoader，其他 ClassLoader 都必须有一个父加载器。 为了清晰的表现此模型，使用流程图描述如下： 通常实现自定义的 ClassLoader 时，不建议重写 loadClass 方法，因为会导致破坏双亲委派模型，从而可能影响整个系统的稳定性，除非有明确理由和把握重写 loadClass，否则推荐重写 findClass 方法，符合双亲委派模型。 Android ClassLoaderAndroid 应用程序的类加载框架由三个核心 ClassLoader 支撑，下面是结构图： BootClassLoader 是系统级别的基础 ClassLoader，所有 Android 和 Java 定义的类型均为其负责加载，它作为最顶层的 ClassLoader，没有父类加载器。查看其类加载路径如下： 12345678910111213141516export BOOTCLASSPATH /system/framework/org.dirtyunicorns.utils.jar :/system/framework/telephony-ext.jar :/system/framework/tcmiface.jar :/system/framework/core-oj.jar :/system/framework/core-libart.jar :/system/framework/conscrypt.jar :/system/framework/okhttp.jar :/system/framework/core-junit.jar :/system/framework/bouncycastle.jar :/system/framework/ext.jar :/system/framework/framework.jar :/system/framework/telephony-common.jar :/system/framework/voip-common.jar :/system/framework/ims-common.jar :/system/framework/apache-xml.jar :/system/framework/org.apache.http.legacy.boot.jar 可以看到，它加载的类型都是 Java 和 Android 提供的基础类库中的类型。 通过一些基础类型的 class 成员调用 getClassLoader() 方法可以获取到它，例如： 1234Class.class.getClassLoader();Activity.class.getClassLoader();TextView.class.getClassLoader();... 左下 ClassLoader 是应用进程的 ClassLoader，它的实现类型为 PathClassLoader，由于限制了类加载路径为应用程序的 apk 文件路径，它只能够加载应用程序本身 Dex 文件中的类型。 Android 系统在创建应用程序进程的时候将会创建这个 ClassLoader，并将其赋予应用程序进程。它的类加载路径如上图所示，为应用程序的 apk 文件路径，它的父类加载器为 BootClassLoader。 获取应用程序 ClassLoader 的方法为使用应用程序开发者自己定义类型的 class 成员的 getClassLoader() 方法，或者使用任意 context 的 getClassLoader() 方法获取，当前线程如果未主动指派 ClassLoader，那么默认也是应用程序的 ClassLoader。 1234context.getClassLoader()Thread.currentThread().getContextClassLoader()MyActivity.class.getClassLoader()... 右下 ClassLoader 是一个系统默认 ClassLoader，类加载路径为 .，还包含几个库路径。 获取这个 ClassLoader，可以调用 ClassLoader 的静态方法 getSystemClassLoader() 取得。 DexClassLoaderDexClassLoader 是 Android 提供给开发者使用的能够加载任意路径下的 Dex 文件包的一个 ClassLoader，它支持任意路径的 jar/zip/apk 文件。 下面是它的唯一构造方法： 1234567/** * @param dexPath dex 包文件路径 * @param optimizedDirectory 提供一个优化目录，dex 文件将被释放到此路径 * @param libraryPath 库路径，将从此路径加载 so 库 * @param parent 父类加载器 */public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) 使用时传入相关参数，即可使用其对象的 loadClass 方法进行类加载操作。 提示明确代码所处的 ClassLoader 环境，以及当前类所属的 ClassLoader 尤为重要。例如，当项目采用了自己实现的热更新方案时，应用包在远程用户的设备上运行，此时需要下发热更新包达到修复目标应用包（宿主）代码的目的，可能需要访问应用包内的类，那么此时需要清晰的知道，应用包的 ClassLoader 如何获取到，热更新包本身的 ClassLoader 与应用包的关系。否则很容易出现问题。 当一个 so 被一个 ClassLoader 加载起来时，另一个 ClassLoader 就无法加载这个 so 了。 http://androidxref.com/9.0.0_r3/xref/art/runtime/java_vm_ext.cc#922 探究 Android 应用程序的 ClassLoader 是在何时创建的？何时赋予给 Context？ 一个类何时被初始化，怎样被初始化？ 热更新、热修复技术方案解析。","link":"/2020/07/07/android-classloader-%E7%AE%80%E6%9E%90/"},{"title":"100 行代码实现 GitHub TOC 生成器","text":"要解决的问题 简要描述 GitHub 不支持将 .md 文件中的 [TOC] 标签自动解析成目录，那么使用代码解决此问题。 详细描述 经常使用 GitHub 的同学都知道，README.md 是仓库的默认说明文档，当使用浏览器打开仓库的地址时，GitHub 将会自动把 README.md 渲染成网页，为用户提供良好的阅读体验。 不止是 README.md 文件，所有的 .md 文件，在从 GitHub 网站打开时都会被自动渲染。 GitHub 中的 .md 文件属于 MarkDown 文件，它使用的是 GitHub Flavored Markdown 支持的语法，也就是 GitHub 自己定义的 MarkDown 语法。 当我们使用 MarkDown 编写开源项目文档，或以 MarkDown 做笔记时， 文档中各种层级标题是必不可少的，例如项目介绍、项目实现、架构设计、流程图等，当文档内容逐渐丰富，标题逐渐出现层次，如果上来直接看文档，不可能做到对整个文档内容和结构一目了然，就像看一个 PDF 文件，没有目录，非常难以阅读。 此时，需要给 MarkDown 文档添加目录，通过了解 MarkDown 语法，发现通常在 MarkDown 顶部加上 [TOC] 标签，绝大多数 MarkDown 解析器都会将 [TOC] 标签解析为添加文档的目录，在渲染 MarkDown 文档时，自动在文档开头添加上目录，用户点击目录中的条目，即可跳转至内容区对应的标题处。 于是在了解上述内容后我立刻在我的一大坨文档上添加一个超强的 [TOC]，push 到 GitHub，正准备狂喜的时候，一看。傻眼了，GitHub 原封不动的把 [TOC] 给放在那里了。 后来知道 GitHub Flavored Markdown 是不支持自动渲染 [TOC] 的。那不行，很不爽，必须得加上目录。 项目背景通过搜索引擎寻找直接可用的 GitHub TOC 生成工具，搜索了半天，找到一个网页工具，是个外国人做的，一使用发现，竟然不支持中文，真是不行。看来还是自己搞一个吧。 然后通过看这个工具生成目录的规则，以及参考别人 GitHub 项目中的带有目录的 .md 文件发现，GitHub MarkDown 可以手动编写指向每一个标题的索引，利用 MarkDown 语法中的超链接标签 [title](url)。 其中 title 放置链接的描述，url 放置超链接，那么，用户可用鼠标点击这个链接，直接跳转到对应的网页，例如： 1[百度一下](https://www.baidu.com/) 对于 MarkDown 的标题，例如 # 前言、## 项目描述，不论标题层次，它们对应的链接都是 [标题](#标题)，分别如下： 123[前言](#前言)[项目描述](#项目描述) 那么用户点击链接时，会在当前网页的 url 后面添加 #前言，然后跳转到本页面的标题对应处。这样就可以生成目录了。 一开始写文档，标题不多，就手动制作一个目录，做了两次，感觉真的太麻烦了。 于是乎，我随手创建一个 Java 类，只用了几十行就搞定了，只要解析出 .md 文档中的 #、## 等标题标签，就作为标题，然后提取标题内容，填入 [标题](#标题) 的格式，最后打印出来就可以了，然而实际用起来却像骑上一辆正方形轮子的自行车。 原因是 [标题](#标题) 格式中 # 后面的内容有一定的规则，并不是把标题内容完全搬过来就可以了，例如不能使用大写字母、不能包含一些特殊符号，一旦包含，就无法跳转至对应标题；或者当文档中的标题有重复的时候，那么相同的目录，只能跳转到第一个标题处。所以使用上面随手写的工具会出现：鼠标怎么也点不动，或者点击跳转到总是第一个重复标题的位置，所以用起来非常难受。 经过我多次编写 GitHub MarkDown 文档的搬砖经验，总结目录索引的规则，最后用了 100 多行 Java 代码写出了一个好用的工具（难度等级：猴子都能写出来），自己用的时候大呼“真香！”^_^。 其实网上看到有很多 GitHub MarkDown TOC 的项目，但是看起来都太臃肿了，废话太多，明明一个类就可以搞定，非要搞得跟坦克一样，真的不适合我。 思路总结 GitHub MarkDown 目录规则如下： 依据 MarkDown 语法，出现在 # 后面的标题将作为目录出现； 标题 # 你好 的目录格式为 - [你好](#你好)，小括号内为标题的索引，点击可跳转到标题处； 特殊符号在标题的索引中将被替换为 &quot;&quot;；空格将被替换为 &quot;-&quot;，大写字母将被替换为小写； 如果标题重复，那么第一次出现的标题索引保持不变，后续标题索引依次追加 -1，-2 依次类推。 例如，MarkDown 文档标题如下： 12345678910111213# MarkDown TOC 项目## 项目描述### 背景## 需求描述### 背景## 可行性分析### 背景 生成的目录如下： 1234567- [MarkDown TOC 项目](#markdown-toc-项目) - [项目描述](#项目描述) - [背景](#背景) - [需求描述](#需求描述) - [背景](#背景-1) - [可行性分析](#可行性分析) - [背景](#背景-2) 效果如下： 实现根据上面总结的规则就可以编写代码了。 对于文档标题的提取，逐行扫描文档，发现有 # 或 ## 开头的内容，认为是标题，提取后面的内容。 考虑到一种特殊情况，文档引用代码片段时，代码中可能出现以 # 开头的行，例如 Makefile 或 Shell 脚本中的注释。所以需要排除，由于代码片段是通过 ``` 符号包围的，所以，扫描到 ``` 符号，认为进入了代码，则不提取标题，再次遇到 ``` 闭合代码片段，进入正文内容后再开始提取。 对于重复标题，使用 Map 数据结构来进行保存。当遇到重复标题时，累计数量 +1，转成文本添加到目标的后面作为标号即可； 对于不能使用的特殊符号列表，采用了遍历测试 ASCII 表的方法，提取出来可出现在目录索引中的符号，其他符号一律作为特殊符号，替换为 &quot;&quot; 处理。 那么即可编写代码，最后生成的工具是一个 4KB 的 jar 包，使用方法如下： 指定一个后缀为 .md 的文件，目录将被打印出来，复制到 MarkDown 文档最上方即可。 1java -jar MarkDownTocCreator.jar XXX.md 代码已通过我个人 GitHub 上的文档测试，目前没有出现问题（其中的 IoUtils，是为了逐行读取文档）。 如需使用这个小工具，请到文末仓库地址中自取 ^_^。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Created by l0neman on 2020/07/07. * * @author l0neman * @version 1.0 */public class MarkDownTocCreator { // 目录标记 private static final char TOC_FLAG = '#'; // 代码段标记 private static final String CODE_FLAG = &quot;```&quot;; // 允许出现在目录中的字符 // 不是 [数字 + 字母 + 中文 + ASCII 表中筛选出的有效字符] private static final String NOT_ALLOW_CHAR_REGEX = &quot;[^\\\\w\\\\u4e00-\\\\u9fa5-_ƒ^ŠŒŽšœŸªµºÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ]&quot;; // 存放相同目录名的索引 // 按照规则，第一个目录为原始字符串，例如“哈哈”，第二个重复名字开始依次为：“哈哈-1”，“哈哈-2”，依次类推 private final Map&lt;String, Integer&gt; tocCount = new HashMap&lt;&gt;(); private String fixSpecialChar(String toc) { return toc.toLowerCase().replace(' ', '-').replaceAll(NOT_ALLOW_CHAR_REGEX, &quot;&quot;); } /* 输出标准 github toc 目录 */ private String getToc(String tocLine) { int index = tocLine.indexOf(&quot;# &quot;); // 取得目录内容 String srcToc = tocLine.substring(index + 2); String fixToc = fixSpecialChar(srcToc); // 处理目录重复的情况 Integer count = tocCount.get(fixToc); if (count == null) { tocCount.put(fixToc, 0); } else { ++count; tocCount.put(fixToc, count); fixToc = fixToc + &quot;-&quot; + count; } String toc; // 根据 # 符号数量确定目录深度，最大支持 4 层 # switch (index) { case 0: toc = &quot;-&quot;; break; case 1: toc = &quot; -&quot;; break; case 2: toc = &quot; -&quot;; break; case 3: toc = &quot; -&quot;; break; default: toc = null; break; } if (toc != null) { toc += String.format(&quot; [%s](#%s)&quot;, srcToc, fixToc); } return toc; } private boolean insideCode = false; private void handle(String file) { IoUtils.readToLines(new File(file), tocLine -&gt; { if (tocLine.startsWith(CODE_FLAG)) { // 进入代码片段中，# 符号将不算做目录 insideCode = !insideCode; } if (!insideCode &amp;&amp; tocLine.startsWith(&quot;#&quot;)) { String convert = getToc(tocLine); if (convert != null) { System.out.println(convert); } } }); } public static void main(String[] args) { if (args.length == 0 || args[0].equals(&quot;&quot;) || !args[0].endsWith(&quot;.md&quot;)) { System.out.println(&quot;Please specify a markdown file.&quot;); return; } new MarkDownTocCreator().handle(args[0]); }} 项目地址 https://github.com/l0neman/MarkDownTocCreator","link":"/2020/07/19/100-%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-github-toc-%E7%94%9F%E6%88%90%E5%99%A8/"},{"title":"计算机启动原理","text":"启动流程概述 开机加电； CPU 跳转到 BIOS 指令的的物理地址（在 Intel 平台为 0XFFFF0）； BIOS 执行 POST（Power-On Self Test，硬件自检）； 找到可启动的设备； 从 MBR 加载引导扇区； BIOS 将控制权移交给操作系统的 Boot Loader（引导加载程序）。 BIOSBIOS（Basic Input/Output System）是基本输入输出系统，它为电脑提供最低级、最直接的硬件控制与支持，是联系底层的硬件系统和软件系统的桥梁。为了在关机后使 BIOS 不会丢失，早期的 BIOS 存储在 ROM（Read-Only Memory）中，并且其大小不会超过 64KB；目前的 BIOS 大多有 1MB 到 2MB，所以会被存储在 闪存（Flash Memory）中。 BIOS 是一组固化到计算机主板上一个 ROM 芯片中的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从 CMOS（一种 RAM 芯片）中读写系统设置的具体信息。 BIOS 通常与硬件系统集成在一起（在计算机主板的 ROM 或 EEPROM 中），所以也被称为固件。 BIOS 执行流程BIOS 存放在 ROM 中，所以断电后不会丢失。电脑开机时，CPU 加电后会跳转到 BIOS 的第一条指令的物理地址 0xFFFF0 上，BIOS 开始执行。 第一次启动检查计算机硬件和外围设备（第二次自检由内核完成），例如 CPU、内存、风扇灯。当 BIOS 启动，就会做一个自我检测的工作，自检过程被称为 POST（Power On Self Test）； 如果自检没有问题，BIOS 开始对硬件进行初始化，并规定当前可启动设备的先后顺序，选择由哪个设备来开机。选择好开机设备后，就会从该设备的 MBR（主引导目录）中读取 Boot Loader（启动引导程序）并执行。启动引导程序用于引导操作系统启动（例如 GRUB）。 当 MBR 被加载到 RAM 之后，BIOS 就会将控制权交给 MBR，进入系统引导的第二阶段。 硬件自检（Power-On Self Test，POST） 如果硬件出现问题，主板会发出蜂鸣，终止启动；否则检查没有问题，则 BIOS 调用 GPU 在屏幕上显示出 CPU、内存、硬盘等相关信息。BIOS 在执行完硬件自检和初始化后，将自己复制到从 0xA0000 开始的物理内存中继续执行。 UEFI 与 BIOSBIOS 存在一些问题： 开发效率低：BIOS 使用汇编语言开发，开发效率较低，代码与硬件密切相关，耦合性高，难以移植； 性能较低：BIOS 基本输出/输出服务需要通过中断完成，导致开销，且 BIOS 没有提供异步工作模式，将在等待时消耗时间； 功能扩展性差：BIOS 代码采用静态链接，需要增加硬件功能时，必须将 16 位代码放置在 0x0C0000~0x0DFFFF 地址，初始化时将其设置为约定的中断处理程序。而且 BIOS 没有提供动态加载设备驱动的方案； 安全性：BIOS 运行过程没有考虑任何安全性； 不支持从硬盘 2T 容量以上的地址引导，受限于 BIOS 的寻址方式，BIOS 硬盘采用 32 位地址，那么引导扇区的最大逻辑地址是 2^32，约为 2^32 * 512 = 2T。 为了解决 BIOS 的问题，UEFI 产生了。 UEFI（Unified Extensible Firmware Interface）是统一可扩展固件接口，它是一种个人电脑规格，用来定义操作系统与系统固件之间的软件接口，作为 BIOS 的替代方案，UEFI 负责加电自检（POST），联系操作系统以及提供连接操作系统与硬件的接口。 EFI 引导管理员与 EFI drivers 的沟通方式（图片来自维基百科）： UEFI 优于 BIOS 的几个特点： EFI 是使用模块化、C 语言风格的参数堆栈传递方式以及动态链接的形式构建的系统，相对于 BIOS 而言更容易实现，同时具有更强的容错性，降低开发时间； 运行于 32 位或 64 位模式，面对未来的增强处理器模式下，能够突破 BIOS 16 位代码的寻址能力，达到处理器最大寻址； UEFI 具有良好的鼠标操控图形和界面，开机速度也优于 BIOS。 BIOS 启动过程： 1[ Power-On ] -&gt; [ BIOS Initializtion ] -&gt; [ POST ] -&gt; [ Load OS ] -&gt; [ Enter OS ] UEFI 过程： 1[ Power-On ] -&gt; [ UEFI Initializtion ] -&gt; [ Load OS ] -&gt; [ Enter OS ] MBRMBR（Master Boot Record）是主引导记录或者开机记录，是一个 512 byte 的扇区，位于磁盘的固定位置。 MBR 存在于硬盘驱动器最开始部分的一个特殊扇区，这个扇区包含已安装的操作系统启动记录器和驱动器的逻辑分区信息。BIOS 完成 POST 和初始化后，会根据 CMOS 中设定的启动顺序选择引导的设备，设备可以是 U 盘或硬盘。如果为硬盘，则 BIOS 就会读取 MBR，MBR 中包含了一段引导程序，一个分区表和 Magic Number。 MBR 结构图： 标准 MBR 结构描述： 地址 描述 长度（字节） 0000 代码区 440（最大 460） 01B8 磁盘标志 4 01BC 一般为空值；0x0000 2 01BE 标准 MBR 分区表规划（4 个主分区表入口） 64 01FE MBR 有效标志（Magic Number）：0x55FA 2 MBR，总大小：446 + 64 + 2 = 512 byte 分区表的长度为 64 byte，共有 4 项，每个 16 byte，那么一个硬盘只能分为 4 个一级分区。 每个分区表项结构描述如下： 偏移 长度（字节） 描述 00H 1 分区状态：00 非活动分区；80 活动分区；其他无意义 01H 1 分区起始磁头号（HEAD），用到全部 8 位 02H 2 分区起始扇区号（SECTOR），占据 02H 的 0－5 位；该分区的起始磁柱号（CYLINDER），占据 02H 的 6－7 位和 03H 的全部 8 位 04H 1 文件系统标志位 05H 1 分区结束磁头号（HEAD），用到全部8位 06H 2 分区结束扇区号（SECTOR），占据 06H 的 0－5 位；该分区的结束磁柱号（CYLINDER），占据 06H 的 6－7 位和 07H 的全部 8 位 08H 4 分区起始相对扇区号 0CH 4 分区总的扇区数 在分出主分区后，其他部分可分为扩展分区，或者不分，扩展分区必须再分成若干逻辑分区后才能使用，所有的逻辑分区都是扩展分区。 硬盘基本结构： 1硬盘的容量 ＝ 主分区的容量 ＋ 扩展分区的容量 1扩展分区的容量 ＝ 各个逻辑分区的容量之和 GPTGPT（GUID Partition Table）是全局唯一标识分区表，它是一个实体硬盘的分区表的结构布局的标准。它是 UEFI（可扩展固件接口）标准的一部分，被用于替代 BIOS 系统中的存储逻辑块地址和大小信息的主引导记录（MBR）分区表。对于那些扇区为512 byte 的磁盘，MBR 分区表不支持容量大于 2.2TB（2.2×1012 byte）的分区。 BootLoader下图为 Linux 系统普通模式下的启动过程： Boot Loader（启动引导加载程序）又叫做操作系统内核加载器（OS Kernel Loader），一个在操作系统内核运行前运行的一段小程序，通过这段小程序可以初始化硬件设备，建立内存空间的映射，将系统软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。通常，Boot Loader 是严重地依赖于硬件而实现的，特别是在嵌入式世界。因此，在嵌入式世界里建立一个通用的 Boot Loader 几乎是不可能的。 启动引导程序拥有以下功能： 加载操作系统的内核。这是启动引导程序最主要的功能； 拥有一个可以让用户选择的菜单，来选择到底启动哪个系统。如果安装过双 Windows 系统，就可以看到类似的选择菜单，不过这个选择菜单是由 Windows 的启动引导程序提供的，不是 GRUB； 可以调用其他的启动引导程序，这是多系统启动的关键。需要注意的是，Windows 的启动引导程序不能调用 Linux 的启动引导程序，所以一般建议先安装 Windows，后安装 Linux，是为了将 Linux 的启动引导程序安装到 MBR 中，覆盖 Windows 的启动引导程序。 Lniux 下的 Boot Loader 程序常见有两种：LILO 和 GNU GRUB。 LILO 没有命令交互界面，不支持网络引导，MBR 配置错误将导致系统无法引导； GRUB 具有命令交互界面，支持网络引导，如果 MBR 配置出现错误，则默认跳转到 GRUB 命令行界面。 早期的 LILO 引导程序已经不常见了，GRUB 拥有更多优势： 支持更多的文件系统; GRUB 的主程序可以直接在文件系统中查找内核文件； 在系统启动时，可以利用 GRUB 的交互界面编辑和修改启动选项； 可以动态修改 GRUB 的配置文件，这样在修改配置文件之后不需要重新安装 GRUB，而只需重新启动就可以生效。 GRUB 引导内核的过程按照启动流程，BIOS 在完成自检后，会到第一个启动设备的 MBR 中读取 GRUB。在 MBR 中用来放置启动引导程序的空间只有 446 Byte，不足以容纳 GRUB 主程序代码，那么 Linux 将 GRUB 的程序分为三段执行： Stage 1：执行 GRUB 主程序 第一阶段用来执行 GRUB 主程序，主程序必须放在启动区中（MBR 或者引导扇区中）。但是 MBR 容量有限，所以只能安装 GRUB 的最小的主程序，而不能安装 GRUB 的相关配置文件。这个主程序用来启动 Stage 1.5 和 Stage 2。 Stage 1.5：识别不同的文件系统 Stage 2 比较大，只能放在文件系统中（分区），但是 Stage 1 不能识别不同的文件系统，所以不能直接加载 Stage 2。这时需要先加载Stage 1.5，由 Stage 1.5 来加载不同文件系统中的 Stage 2。 Stage 1.5 没有放在文件系统中，而是在安装 GRUB 时，直接安装到紧跟 MBR 之后的 32KB 的空间中，这段硬盘空间是空白无用的，而且是没有文件系统的，所以 Stage 1 才能直接读取 Stage 1.5。读取了 Stage 1.5 后就能识别不同的文件系统，才能加载 Stage 2。 Stage 2：加载 GRUB 的配置文件 加载 GRUB 的配置文件 /boot/grub/grub.conf，根据配置文件中的定义，加载内核和虚拟文件系统。接下来内核就可以接管启动过程，继续自检与加载硬件模块了。 Linux Kernel 加载 根据 GRUB 设定的内核映像所在路径，系统读取内存映像，并进行解压缩内核； 系统将内核解解压至内存中，调用初始化函数初始化各种设备，完成 Linux 核心环境的建立。 启动流程图 CentOS 6.x 系统启动过程 电脑加电，加载 BIOS 信息，BIOS 进行系统检测。依照 BIOS 设定，找到第一个可以启动的设备（一般是硬盘）； 读取第一个启动设备的 MBR (主引导记录），加载 MBR 中的 Boot Loader（启动引导程序，常见为 GRUB）； 依据 Boot Loader 的设置加载内核，内核会再进行一遍系统检测。系统一般会采用内核检测硬件的信息，而不一定采用 BIOS 的自检信息。内核在检测硬件的同时，还会通过加载动态模块的形式加载硬件的驱动； 内核启动系统的第一个进程，也就是 /sbin/init； 由 /sbin/init 进程调用 /etc/init/rcS.conf 配置文件，通过这个配置文件调用 /etc/rc.d/rc.sysinit 配置文件。而 /etc/rc.d/rc.sysinit 配置文件是用来进行系统初始化的，主要用于配置计算机的初始环境； 还是通过 /etc/init/rcS.conf 配置文件调用 /etc/inittab 配置文件。通过 /etc/inittab 配置文件来确定系统的默认运行级别； 确定默认运行级别后，调用 /etc/init/rc.conf 配置文件； 通过 /etc/init/rc.conf 配置文件调用并执行 /etc/rc.d/rc 脚本，并传入运行级别参数； /etc/rc.d/rc 确定传入的运行级别，然后运行相应的运行级别目录 /etc/rc[0-6].d/ 中的脚本； /etc/rc[0-6].d/ 目录中的脚本依据设定好的优先级依次启动和关闭； 最后执行 /etc/rc.d/rc.local 中的程序； 如果是字符界面启动，就可以看到登录界面了。如果是图形界面启动，就会调用相应的 X Window 接口； 其他Android 设备启动过程 Android 设备与 PC 的硬件差异较大，虽然启动过程不相同，但是过程类似。 Android 设备通用启动流程图： 参考 https://www.cnblogs.com/adamwong/p/10582183.html http://c.biancheng.net/linux_tutorial/","link":"/2020/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"},{"title":"Android 模拟器 Root 和 SuperSU 安装","text":"前言有时需要在 Android 模拟器上测试特定功能，需要使用到 Root 权限，例如访问某些系统配置、修改系统文件等。通常情况下在 adb shell 的环境下使用 su 命令以 Root 身份执行相关命令即可满足需求，但是还有命令行难以满足的情况，例如给一个第三方应用授予 Root 权限（赋予应用使用 su 命令的权限），如果直接使用命令修改 su 文件权限，使特定应用可以访问，不仅难以控制，而且可能造成滥用 Root 权限的安全风险。所以需要一个统一管理 Root 权限授予的工具，那么可以使用 SuperSU 工具。 SuperSU 是 Android 系统上著名的 Root 权限管理工具，安装此软件后，可以方便的对 Root 权限进行管理，那么后面安装 Xposed 等依赖 Root 的工具时就很容易了。 在 Android 真机上安装 SuperSU 的方比较容易，只需要获得 Root 权限即可快速安装，在 Android 模拟器上安装略有不同。 下面是在 Android 官方模拟器上获取 Root 权限和安装 SuperSU 的方法。 环境说明使用了如下环境进行操作： Android Studio 4.0.1。Android 开发集成环境，方便打开 AVD（Android Virtual Device），创建模拟器 官方模拟器镜像 API 27（Android 8.1）。使用 Android 8.1 是为了安装 Xposed 最新版本 Ubuntu 20.04.1 LTS。使用的操作系统版本 SuperSU 2.8.2。最新的 SuperSU 软件的版本 安装 SuperSU 时首先需要获得 root 权限，如果直接创建默认模拟器虚拟设备，并且直接安装 Supersuer.apk 是不行的，可参考如下详细步骤来进行安装。 安装步骤概述 创建模拟器并获取 root 权限； 设置 SuperSU 所需环境； 安装 Superuser.apk。 1. 创建模拟器并获取 root 权限首先从 Android Studio 右上角，点击一个手机右下角有 Android 机器人图标的按钮（AVD Manager），打开 AVD 管理界面。 然后选择 [+ Create Virtual Device] 创建一个 Android 模拟器。 [Hardware] 可随意选择，这里选择 [Pixel 2]，[System Image] 这里选择了 [X86 Images] 中的 Oreo-27-x86-Android 8.1 (Google APIS)（注意：这里一要选择后面有 Google APIS 的镜像，否则不能获取 Root 权限）。 名称这里设置为 suavd。创建后，此时 avd 列表中出现一个名为 suavd 的模拟器。 接下来获取 Root 权限，非常简单，模拟器已经提供了 Root。 在 Shell（Unix、Linux）或 DOS（Windows）中输入如下命令，即可使用 Root 身份进入 Shell： 123$ adb shellgeneric_x86:/ $ sugeneric_x86:/ # 或者： 123$ adb root$ adb shellgeneric_x86:/ # 提示：如果使用了非 Google APIs 的镜像，进入 adb shell 后将不支持 su 命令；如果输入 adb root 将会出现如下错误提示： 12adb root:adbd cannot run as root in production builds 2. 设置 SuperSU 所需环境有了 Root 权限，接下来为安装 SuperSU 做准备，SuperSU 本身是一个 Root 权限管理软件，但本身并不具有 Root 权限，要安装它，需要授予它 Root 权限。 SuperSU 包含一个 su 可执行文件和一个 Superuser.apk，只需要把 SuperSU 提供的 su 可执行文件替换系统的 su 文件，并且给予权限 -rwsr-sr-x (6755) 即可。 一般在实际设备上有两种方式替换文件： 手动将 SuperSU 的 su 文件替换系统文件，需要 Root 权限； 通过 Recovery 模式直接将 su 文件已补丁包的形式刷入。 对于模拟器来说，它没有 Recovery 模式，是直接使用 img 镜像启动的，所以只能使用第一种方法。 首先下载 SuperSU 的相关文件： 在这里下载：https://supersuroot.org/download/ 选择 Recovery V2.82 Flashable.zip 进行下载，里面包含各个架构所需的 su 文件，以及 Superuser.apk 安装包。 现在查看模拟器原始的 su 文件位置： 12generic_x86:/ # which sugeneric_x86:/ # /system/xbin/su 根据模拟器架构（这里是 x86），取出压缩包中的 su.pie 或 su 文件， 这里对于 Android 5.0 版本及之上的设备来说，需要使用 su.pie 文件，它是使用 -fPIE 标记编译的位置无关的可执行文件，具有地址空间随机化特性。 上面已经有了 Root 权限，现在可以进行替换了。 首先打开创建的模拟器 suavd（点击绿色三角形），然后进入并查看模拟器的 su 命令所在的路径： 123$ adb shellgeneric_x86:/ # which su/system/xbin/su 下面进行替换： 1234$ adb root$ adb remount$ adb push su.pie /system/xbin/suadb: error: failed to copy 'su.pie' to '/system/xbin/su': remote couldn't create file: Read-only file system adb remount 是为了将 /system 挂载为可写。 然而出现了报错，提示 /system 是只读文件系统，无法写入文件。解决办法如下： 关闭模拟器，使用命令行重新启动模拟器，并指定 -writable-system 选项（emulator 程序在 Android SDK 的 emulator 路径中，如果配置了环境变量，可以直接使用 emulator 命令，这里使用了绝对路径）： 1$ ~/Android/Sdk/emulator/emulator -avd suavd -writable-system 此时模拟器的 /system 就具备可写属性了，查看模拟器的文件路径（在 ~/.android/avd/suavd.avd），会发现一个 system.img.qcow2 文件，它是模拟器的虚拟文件系统，目的是将只读镜像 system.img 具备可写的特性，修改 /system 的内容将被保存在 system.img.qcow2 中。 如果不使用 -writeable-system 选项将不会创建这个文件，那么 /system 也就不可写。 现在重新执行上面的命令即可完成替换： 1234$ adb root$ adb remount$ adb push su.pie /system/xbin/susu.pie: 1 file pushed. 14.1 MB/s (104012 bytes in 0.007s) 可以了，接下来按部就班设置 SuperUS： 12345678910111213$ adb shellgeneric_x86:/ # chmod 6755 /system/xbin/sugeneric_x86:/ # ls -al /system/xbin/su -rwsr-sr-x 1 root shell 104012 2008-02-29 03:33 /system/xbin/sugeneric_x86:/ # su --installgeneric_x86:/ # su --daemon&amp; [1] 3844generic_x86:/ # setenforce 0[1] + Done \\su --daemon 上面命令解释如下： 设置权限，使 SuperSU 提供的 su 可执行文件能够被所有应用执行； 初始化安装 su； 设置 su 守护进程； 关闭 SELinux 安全策略，解除 Root 权限的限制。 这样就完成了 SuperSU 环境的设置。 提示：如果高于 Android 5.0 版本使用了 su 文件替换，而不是 su.pie ，将会出现如下情况： 12generic_x86:/ # su --install&quot;su&quot;: error: Android 5.0 and later only support position-independent executables (-fPIE). 3. 安装 SuperSU App在环境设置完毕后，直接安装 Supersuer.apk 即可，在压缩包中 common/Superuser.apk 中。 12$ adb install Superuser.apk Success 安装后打开在模拟器中打开，显示如下，则安装成功，如果显示 Root undetected，则安装失败，按照上面步骤进行检查。 这里选择 CANCEL 就可以，如果选择 CONTINUE 更新文件，可能会卡在开机界面导致无法启动系统。 为了保证模拟器下次启动能够正常运行 SuperSU 保证 Root 状态，可以创建一个 Snapshot（快照），点击模拟器右下角的溢出菜单，点击 [TAKE SNAPSHOT]，创建一个快照，重命名为 root。 下次启动模拟器，从这里直接运行快照，将恢复到 Root 时的状态。 注意：再次启动模拟器时，不能从 Android Studio 中的 AVD Manager 直接启动，依然需要使用命令行加 -writable-system 选项启动，因为默认的启动不具备 /system 写权限。 测试为了测试 SuperSU 是否可用，这里选择安装 Xposed 框架进行测试。 12$ adb install XposedInstaller_3.1.5.apkSuccess 进入主界面，点击 INSTALL/UPDATE 安装 Xposed 将会出现 Root 授权界面，点击授权后，重启，成功激活 Xposed 框架。 SuperSU 工作原理根据开源版本的 superuser 了解 SuperSU 工作原理： daemonsu 为 su 启动的守护进程； 现在第三方应用开始调用 su 命令，请求申请 Root 权限； su 是一个可执行文件，内部与 daemonsu 进行通信，发送执行命令请求； daemonsu 创建 sush 子进程，sush 进程使用 am（Activity Manager）命令启动 Superuser 应用，请求授权，出现用户授权界面； 授权通过，Superuser 应用通过 socket 返回给 sush 用户授权结果，通过授权，则 sush 选择是否执行请求的命令。 时序图如下： 参考 https://www.cnblogs.com/cute/p/4095359.html https://stackoverflow.com/questions/5095234/how-to-get-root-access-on-android-emulator https://blog.csdn.net/qq_39131177/article/details/85060694 https://blog.csdn.net/xiaolli/article/details/70154998","link":"/2020/09/19/android-%E6%A8%A1%E6%8B%9F%E5%99%A8-root-%E5%92%8C-supersu-%E5%AE%89%E8%A3%85/"},{"title":"Android AVD 位置修改","text":"前言默认的 Android Virtual Device Manager (AVD)，就是官方 Android 模拟器的镜像文件存储位置在 C:\\Users\\&lt;user_name&gt;\\.android\\avd 中，Linux 和 Mac 在 &lt;user_home&gt;/.android/avd 中，有时需要改变它的位置，例如给 C 盘腾出空间。 Windows 系统中操作步骤如下： 操作步骤 关闭 Android Studio； 控制面板 -&gt; 系统 -&gt; 高级系统设置 -&gt; 环境变量； 添加一个用户变量： 变量名：ANDROID_SDK_HOME 变量值：&lt;更改后的位置&gt;，例如 D:\\Tool\\Avd，其中更改后的位置不能是 Android SDK 的根目录，可以是它的子目录 打开 Android Studio，确认 .android 文件夹在更改后的的位置中被创建了； 从以前的位置 C:\\Users\\&lt;user_name&gt;\\.android\\avd 将 avd 文件夹移动到新的位置 D:\\Tool\\Avd 中","link":"/2021/04/21/android-avd-%E4%BD%8D%E7%BD%AE%E4%BF%AE%E6%94%B9/"},{"title":"Dropbear Android 安装步骤","text":"克隆 https://github.com/ubiquiti/dropbear-android 仓库 修改 build-dropbear-android.sh 文件中的编译器路径： 1234HOST=arm-linux-androideabiCOMPILER=${TOOLCHAIN}/bin/armv7a-linux-androideabi28-clangSTRIP=${TOOLCHAIN}/bin/arm-linux-androideabi-stripSYSROOT=${TOOLCHAIN}/sysroot 设置 TOOLCHAIN 变量： 1export TOOLCHAIN=/xxx/ndk/22.0.7026061/toolchains/llvm/prebuilt/linux-x86_64 编译执行 build-dropbear-android.sh 脚本 生成了 target/dropbear 和 target/dropbearkey 可执行文件 把两个文件放入 Android 设备 /system/xbin/ 中 生成密钥： 12dropbearkey -t dss -f /system/etc/dropbear/dropbear_dss_host_keydropbearkey -t rsa -f /system/etc/dropbear/dropbear_rsa_host_key 启动服务并设置用户名和密码： 1dropbear -A -N root -C 123456 客户端连接： 1ssh root@10.2.17.16 -p 10022","link":"/2021/04/21/dropbear-android-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"},{"title":"GDB ARM 交叉编译环境搭建","text":"需求需要使用 GDB 在本机来调试 ARM 环境 环境需要安装交叉编译器，ARM 交叉编译器有很多种，这里安装其中一种。 1sudo apt install gcc-arm-linux-gnueabi 编译时可能需要用到 Texinfo。 1sudo apt install Texinfo 编译方法 首先下载 GDB，这里下载了最新的 GDB 10.1 版本 为了在本机调试 ARM 环境，需要编译出本机可用的 GDB 可执行文件，以及 ARM 端的 GDB Server。 ./configure 配置说明： --target 指定目标平台--host 指定目标运行平台--prefix 指定 make install 安装路径 CC 指定 C 语言编译器CXX 指定 C++ 语言编译器 编译本机 GDB首先解压 gdb-10.1.tar.xz 到 gdb-10.1 目录 然后进入 gdb-10.1 目录，配置 make，执行如下指令： 1./configure --target=arm-linux-gnueabi --prefix=&quot;/???/gdb-10.1/build/` 这里是本机，所以不用指定 --host 选项和 CC 以及 CXX 变量的值，configure 会自动检测。 配置后即可进行编译和安装： 123makemkdir build # 安装到此目录make install 编译完成后进入 build 目录，能够看到 arm-linux-gnueabi-gdb 可执行文件，使用 file 命令确认可执行文件的平台符合本机： 1arm-linux-gnueabi-gdb: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a10a8de31b935a58a16cc7f653d13665a3166543, for GNU/Linux 3.2.0, with debug_info, not stripped 编译目标机 GDB Server目标机执行 ARM 程序，如果需要调试 ARM，需要在目标机上安装 GDB Server，通常和 GDB 版本一致。 首先进入需要编译出 ARM 平台的 GDB，因为编译 GDB Server 过程会依赖 GDB 的编译文件。 重新解压 gdb-10.1.tar.xz 到一个新的目录（防止和刚编译的本机 GDB 文件冲突）gdb-10.1-arm 中 进入此目录，然后首先编译 GDB，这里和本机编译 GDB 时的 Make 配置不同，需要指定目标运行平台为 arm，以及编译器为交叉编译器： 1CC=&quot;arm-linux-gnueabi-gcc&quot; CXX=&quot;arm-linux-gnueabi-g++&quot; ./configure --target=arm-linux-gnueabi --host=&quot;arm-linux-gnueabi&quot; --prefix=&quot;/xxx/gdb-10.1/build&quot; 配置后进行编译： 123makemkdir buildmake install 编译后即可编译 GDB Server，进入 gdbserver 目录： 首先配置 Make： 1CC=&quot;arm-linux-gnueabi-gcc&quot; CXX=&quot;arm-linux-gnueabi-g++&quot; ./configure --target=arm-linux-gnueabi --host=&quot;arm-linux-gnueabi&quot; --prefix=&quot;/xxx/gdb-10.1/gdbserver/build&quot; 然后编译、安装： 123makemkdir build # 安装到此目录make install 编译后进入 build，可以看到 bin 目录，进入看到 arm-linux-gnueabi-gdbserver 可执行文件，使用 file 命令确认文件属于目标机平台： 1arm-linux-gnueabi-gdbserver: ELF 32-bit LSB executable, ARM, EABI5 version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.3, BuildID[sha1]=330389c2fc884446a58ae1a3da4a6e2e1dd93da9, for GNU/Linux 3.2.0, with debug_info, not stripped 将 gdbserver 传入目标机即可。","link":"/2021/04/21/gdb-arm-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"Material Design 参考","text":"Elevation（海拔） Component elevation values（组件高度值）: Compont Elevation Nav drawer 16dp App bar 4dp Card 6dp FAB 6dp Button 2dp to 8dp Dialog 24dp Table of default elevation values（默认高度表）： Component Defualt elevation values (dp) DIalog 24 Modal bottom sheet 16 Modal side sheet 16 Navigation drawer 16 Floatig action button (FAB -pressed) 12 Standard bottom sheet 8 Standard side sheet 8 Bottom navigation bar 8 Bottom app bar 8 Menus and sub menus 8 Card (when picked up) 8 Contained button (press state) 8 Floating action button (FAB - resting elvation) 6 Snackbar 6 Top app bar (scrolled state) 4 Top app bar (resting elevatino) 0 or 4 Refresh indicator 3 Search bar (resting elevaion) 3 Card (resting elevation) 1 Switch 1 Text button 0 Standard side sheet 0 Layout（布局） Spacing methods（间距方法） Baseline grid8dp 网格：所有组件均和手机、平板和台式机的 8dp 正方形基准网格对齐。4dp 网格：组件中的图标、类型和某些元素可以与 4dp 网格对齐。 组件尺寸建议 Spacing（间距） Padding （填充） 填充指 UI 元素之间的空间。填充是基准线的另一种间距方法，以 8dp 或 4dp 的增量进行度量。 例如：组件之间具有 24dp 填充的布局。 Dimensions （尺寸） 某些组件（例如应用程序栏或列表）仅概述元素的高度。这些元素的高度应与 8dp 网格对齐。 Status bar height: 24dpApp bar height: 56dpList item height: 88dp Containers and ratios（容器与比例） Aspect ratios （长宽比） 建议在 UI 中使用如下纵横比：16:9，3:4，2:4，3:1，4:2，2:3。 Touch targets（触摸目标） 触摸目标应至少为 48 x 48 dp，目标之间至少要有 8dp 的空间。 Applying color to UI（将色彩应 用于 UI） Top and bottom app bars（顶部和底部应用栏） Identifying app bars（识别应用栏） 顶部和底部的应用栏使用应用程序的原色。系统栏可以使用原色的深色或浅色变体来将系统内容与顶部应用栏内容分开。 例如：顶部应用栏上使用原色（purple 500），系统栏上使用深色主色（purple 700）。 要强调应用栏和其他表面之间的区别，请在附近的组件（例如浮动操作按钮（FAB））上使用辅助颜色。 例如：底部应用栏上使用原色（blue 700），而在浮动操作按钮上使用第二色（orange 500）。 Typography（版式） The type system（类型系统） Type Scale（类型量表） 类型量表是类型系统支持的 13 种样式的组合。 Material Design type scale: Scale Category Typeface Font Size Case Letter spacing H1 Roboto Light 96 Sentence -1.5 H2 Roboto Light 60 Sentence -0.5 H3 Roboto Regular 48 Sentence 0 H4 Roboto Regular 34 Sentence 0.25 H5 Roboto Regular 24 Sentence 0 H6 Roboto Medium 20 Sentence 0.15 Subtitle 1 Roboto Regular 16 Sentence 0.15 Subtitle 2 Roboto Medium 14 Sentence 0.1 Body 1 Roboto Regular 16 Sentence 0.5 Body 2 Roboto Regular 14 Sentence 0.25 BUTTON Roboto Medium 14 All caps 1.25 Caption Roboto Regular 12 Sentence 0.4 OVERLINE Roboto Regular 10 All caps 1.5 色彩总结material design color primaryprimary darkprimary light secondarysecondary darksecondary light 原则： 从上至下，由深至浅。 由主色彩至副色彩 仅有主色彩则替换副色彩 副色彩做为动作控件的色彩 如果多个动作控件，那么副色彩上下要形成色彩落差。 色彩选择参考表格： 控件 只有主色彩 包含副色彩 状态栏 primary dark &lt;= 标题栏 primary &lt;= 动作按钮 primary secondary 滑杆球 primary secondary 滑杆 primary secondary 背景 primary light secondary light tab 按钮 primary light &lt;= tab 指示线 primary secondary 按钮 primary secondary 开关球 primary light secondary light 开关杆 primary secondary 列表点击背景 primary","link":"/2021/04/21/material-design-%E5%8F%82%E8%80%83/"},{"title":"好用的 Android 日志工具","text":"简介分享一个 Android 日志工具（Java 层），几乎我的每个项目都会用到，自认为非常好用，这里描述一下它的设计和实现。 它有如下几个特点： 简单，仅由一个 100 余行的 Java 类实现，猴子都能看懂 ^_^； 额外可选日志内容，提供线程名信息和调用栈，提供当前日志打印所在类以及所在代码行数； 方便，包含栈信息，直接用鼠标即可点击到日志打印所在行； 安全，保证日志字符串完全被优化掉，而不是留在代码中，下面会分析； 灵活，提供二次封装。 开源仓库地址在文末给出。 背景日志是工程开发中必不可少的调试工具之一，良好的日志代码可以清晰的反映逻辑流程和关键变量的值，任何程序开发框架都会提供内置的日志类库供开发者使用。 Android SDK 也不例外，它提供了 android.util.Log 来打印日志，包含了 6 个级别的日志。 分别是：Assert、Debug、Error、Info、Verbose、Warning 通常我们在使用 Log 时，几乎一定是需要包装的，最常见的需求就是发布 Release 包时去除所有打印的日志，防止泄露关键信息以及影响应用执行效率。 下面分析系统 Log 类中的几个我个人认为的优缺点。 优点： 足够简单，在临时测试时可以随手打印出日志； 自带相关调式信息，例如时间、进程/线程ID、应用包名，日志级别。 缺点： 没有应用内的日志开关，几乎一定需要封装； 调试信息不够丰富，例如线程以 ID 形式显示不够直观、无法知道日志调用所在代码行； 日志级别冗余，提供 6 个级别的日志，让人不知道该选择哪一个（我从没用过所有级别）； 未提供日志格式化方法，只能使用字符串相加，这样会导致日志字符串无法被优化（下面会分析）。 由于系统 API 要设计的足够通用，必须要足够简单，所以不会提供那么多附加内容，那是框架需要做的。 那么下面就用自己的代码来弥补它的缺点。 设计日志级别设计我认为 4 个级别已经足够覆盖 Java 层逻辑的所有的情况。 Error 级别，使用红色标记，表示严重错误，不应该出现的、非预料中的错误。一旦出现，应用是无法正常执行的。 Warn 级别，使用橙色标记，表示警告，预料内的异常。例如网络异常，通常出现警告级别的异常，需要考虑替方案，例如没有网络，则从本地缓存读取。 Debug 级别，使用绿色标记，表示调试信息，打印关键逻辑相关的变量数值的信息。 Info 级别，使用蓝色标记，表示和流程相关的信息，例如执行进入了某个函数，某个服务被启动，通常不包含变量。 日志格式设计首先分析系统日志包含的信息，如下： 1232020-07-17 14:15:18 21194-21194/io.l0neman.example I/MainActivity: onResume: initViews \\ / \\ / \\ / / \\ \\ / \\ / [ 时间 ] [ 进程-线程 ID ] [ 包名 ] [ 级别 ] [ TAG ] [ 日志内容 ] 发现系统日志已经包含了相关信息，那么我们就不考虑添加这些信息了。 需要添加如下内容： 线程名字，了解实时的逻辑执行线程信息； 栈信息，当前调用栈信息，可像异常抛出时可用鼠标点击跳转至调用处。 例如，异常调用栈后面表示代码具体调用行，可以用鼠标定位到具体位置： 1234Caused by: java.lang.RuntimeException: demo at io.l0neman.example.MainActivity.onCreate(MainActivity.java:17) at android.app.Activity.performCreate(Activity.java:7802) ... 通常我们可以定制的部分只有日志的 TAG 和后面的内容。 TAG 官方建议不超过 20 个字符，避免影响搜索效率，所以不考虑在这里添加过多内容。 通常最关心的还是日志的内容，所以添加的线程信息和栈信息不考虑放在日志最前面，那么日志格式设计如下。 1${log content} [thread name](Class:${line number}) 对应实际日志为： 12020-07-17 14:15:18 21194-21194/io.l0neman.example I/MainActivity: onResume: initViews [main](MainActivity.java:24) 这样就设计好了日志格式，继续其他部分的设计。 日志 TAG 设计TAG 是一个标签用于快速搜索，通常为一个类名或一个模块的标签，便于识别日志所处模块环境。 Android 系统源代码中通常一个类表示一项功能，那么此类中都有一个 TAG 常量，值和类名相同； 当项目复杂时，包含多个模块，每个模块包含多个类，一个类表示一个功能，那么我认为 TAG 需要分层。 由于 TAG 不宜过长，那就设计两层，如下。 TAG 分为一个主 TAG 和子 TAG，两个 TAG 之间使用 # 相连，格式如下。 1Primary#Secondary 那么，当应用简单时，只有一个应用模块，主 TAG 就可以表示整个应用，例如程序为 LoggerExample。 那么可以使用 LE 作为主 TAG，用于和其他应用区分，每个类的名字作为子 TAG，用于表示具体类的功能标签： 1LE#MainActivity 当应用复杂，具有多个模块，那么，主 TAG 就可以表示每个模块，例如模块为 Foo，Bar。 每个类的名字依然作为子 TAG，打印日志的时候就可以区分模块了： 123Foo#FileManagerBar#ImageFactory 至于更细粒度的 Java 方法，TAG 并不是必须的，那么可以在日志内容中进行补充。 日志安全性设计日志的安全性体现如下： 日志内容不允许在 release 版本中，因为打印时会泄露关键变量信息。 日志内容不允许出现在 release 版本的 DEX 文件中，因为会给逆向分析者提供流程逻辑信息，通常逆向分析者通过静态分析工具将 DEX 反编译为类 Java 代码，如果看到日志中的详细信息，相当于了解了当前函数的作用。 下面是实例分析，通常封装日志时都采用如下 logD 的方法，直接使用 BuildConfig.DEBUG 变量来包装一下，打印日志时使用 + 号连接字符串内容： 123456789private void testAndroidLog() { logD(TAG, &quot;#testAndroidLog mId=&quot; + mId);}private static void logD(String tag, String log) { if (BuildConfig.DEBUG) { Log.d(TAG, log); }} 如果在 Debug 版本调用 testAndroidLog 方法，将会正常打印日志，在 Release 中则 logcat 中看不到任何日志。 通常在打包 Release 版本时，会打开压缩选项 minifyEnabled true，混淆器会对未使用的参数进行优化移除。 那么使用静态反编译器 jadx 打开 APK 查看这段代码，如下： 12345678...public final void r() { &quot;#testAndroidLog mId=&quot; + this.p; t();}public static void t() {} 发现字符串组合的代码依然存在，因为当混淆器发现 logD 函数里面是空内容（由于 BuildConfig.DEBUG 为常量 false，所以编译器在编译成字节码时直接把此句 if 语句移除了），没有用到 tag 和 log 参数，所以移除了 tag 和 log 参数，然后将 logD 函数混淆为 t，但是在原始代码传递 log 时，做了字符串相加的运算，需要生成临时变量，则混淆器认为此句逻辑为有效逻辑，则不优化。 虽然从逻辑角度，这句代码完全可以优化掉，但是对于混淆器来说，它分析代码时需要更保守，防止优化掉有用的代码。 那么当逆向人员静态分析时，一下就能看出这个函数的用意是 testAndroidLog，即为了测试 Android Log，且 mId 变量和此方法紧密想关，当大量此类型的日志留在代码中，会对逆向人员提供较大帮助。 那么效果最好的一定是将 if 语句放在外面： 12345private void testAndroidLog() { if (BuildConfig.DEBUG) { logD(TAG, &quot;#testAndroidLog mId=&quot; + mId); }} 在编译时就全部优化掉了，然而每打印一次日志都得写，非常麻烦，所以不考虑。 那么最终采用如下方案，使用字符串格式化的方式解决此问题。 123456789private void testLogger() { loggerD(TAG, &quot;#testAndroidLog mId=%d&quot;, mId);}private static void loggerD(String tag, String formant, Object... args) { if (BuildConfig.DEBUG) { Log.d(TAG, String.format(formant, args)); }} 使用 jadx 静态反编译器查看得到： 12345678...public final void s() { new Object[1][0] = Integer.valueOf(this.p); u();}public static void u() {} 这样的话，由于每个参数都是分别传递的，除了后面的不定参数列表需要创建临时数组，所以混淆器会直接把独立的参数优化掉，那么就看不到前面的格式化字符串参数了。上面的代码根本看不出来任何逻辑，保证了应用逻辑的安全性。 实现根据上面的分析和设计，开始具体实现。 类名类名命名为很普通的 Logger。 API首先提供日志 API，包含四个级别的打印，均为静态方法。 PRINT 为全局打印标记，通常设置为 BuildConfig.DEBUG，可根据需要修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Logger.javaprivate static final boolean PRINT = BuildConfig.DEBUG;public static void i(String tag, String format, Object... args) { if (PRINT) { Log.i(tag, String.format(format, args)); }}public static void i(String tag, Throwable tr, String format, Object... args) { if (PRINT) { Log.i(tag, String.format(format, args), tr); }}public static void d(String tag, String format, Object... args) { if (PRINT) { Log.d(tag, String.format(format, args)); }}public static void d(String tag, Throwable tr, String format, Object... args) { if (PRINT) { Log.d(tag, String.format(format, args), tr); }}public static void w(String tag, String format, Object... args) { if (PRINT) { Log.w(tag, String.format(format, args)); }}public static void w(String tag, Throwable tr, String format, Object... args) { if (PRINT) { Log.w(tag, String.format(format, args), tr); }}public static void w(String tag, Throwable tr) { if (PRINT) { Log.w(tag, tr); }}public static void e(String tag, String format, Object... args) { if (PRINT) { Log.e(tag, String.format(format, args)); }}public static void e(String tag, Throwable tr, String format, Object... args) { if (PRINT) { Log.e(tag, String.format(format, args), tr); }} 日志 TAG日志 TAG 由处理参数 tag 得到，根据前面的设计，那么 tag 参数为子 TAG，主 TAG 定为常量，根据项目不同，对其进行修改。 对于每个模块的打印，参考后面使用方法中的用法。 12345678// Logger.java// 这里代表 LoggerExample 应用，使用时根据应用或模块更改主 TAGprivate static final String MAIN_TAG = &quot;LE&quot;;private static String getTag(String tag) { return MAIN_TAG + &quot;#&quot; + tag;} 此时把 API 中的 tag 全部替换为 getTag(tag) 即可，例如： 1234567// Logger.javapublic static void d(String tag, String format, Object... args) { if (PRINT) { Log.d(getTag(tag), String.format(format, args)); }} 日志内容日志内容，根据设计部分提到的格式，对于原始日志内容添加上线程信息和栈信息： 12345678910111213// Logger.java// 提供栈信息关闭选项。private static final boolean STACK_PRINT = true;private static String getThreadName() { return Thread.currentThread().getName();}private static String getLog(String log) { String stackInfo = STACK_PRINT ? stackInfo() : &quot;&quot;; return log + &quot; [&quot; + getThreadName() + ']' + stackInfo;} 线程信息直接使用 Thread.currentThread().getName() 获取即可。 栈信息，单独说一下，当前的调用栈信息可使用 Thread.currentThread().getStrackTrace() 获取，它返回一个数组，包含从当前调用代码行，向上追溯的多层栈信息，就和下面的异常类似： 1234Caused by: java.lang.RuntimeException: demo at io.l0neman.example.MainActivity.onCreate(MainActivity.java:17) at android.app.Activity.performCreate(Activity.java:7802) ... 那么此时，需要获得日志调用行的相关栈信息，就需要从这个数组里面找出来，通过类命比较即可快速找到数组的索引。 日志需要考虑三种栈信息的支持： 当前日志调用行的栈信息，鼠标点击可跳转； 提供打印多层栈信息的选项，栈信息层数用户可以自定义； 提供对日志方法的封装，那么此时当前调用行的栈信息应该修正为用户的封装方法的当前调用行。 最终 stackInfo() 方法的实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Logger.java// 打印栈的层数，支持上面的 2private static final int STACK_COUNT = 1;// 栈寻找的起始深度private static final int STACK_DEPTH = 1;// 栈偏移，基于标准日志方法的偏移，调整偏移可支持上面的 3private static final int STACK_OFFSET = 4;// 组成当前日志调用行的栈信息，例如 (MainActivity.java:20)，鼠标点击可跳转private static String getFormatStackInfo(StackTraceElement element) { return &quot;(&quot; + element.getFileName() + ':' + element.getLineNumber() + ')';}// 找到 `Logger` 的栈偏移。private static int getStackDepth(StackTraceElement[] elements) { for (int i = STACK_DEPTH; i &lt; elements.length; i++) { final StackTraceElement element = elements[i]; if (!element.getClassName().split(&quot;\\\\$&quot;)[0].equals(Logger.class.getName())) { return i; } } return -1;}private static String stackInfo() { final StackTraceElement[] elements = Thread.currentThread().getStackTrace(); final int stackDepth = getStackDepth(elements); int bottomStackDepth = stackDepth + STACK_OFFSET; int topStackDepth = stackDepth + STACK_COUNT + STACK_OFFSET; if (bottomStackDepth &gt;= elements.length) { bottomStackDepth = elements.length - 1; } if (topStackDepth &gt; elements.length) { topStackDepth = elements.length; } StringBuilder builder = new StringBuilder(); StringBuilder stackTable = new StringBuilder(); for (int i = topStackDepth - 1; i &gt;= bottomStackDepth; i--) { final String formatStackInfo = getFormatStackInfo(elements[i]); builder.append(stackTable).append(formatStackInfo).append('\\n'); stackTable.append(&quot; &quot;); } return builder.toString();} 具体逻辑不再详细分析了，还需要自己去阅读。 最后将 API 的 log 参数替换成 getLog(log)，例如： 1234567// Logger.javapublic static void d(String tag, String format, Object... args) { if (PRINT) { Log.d(getTag(tag), String.format(format, args)); }} 此时就完成了所有逻辑，虽然简单，但是用起来很舒服，需要自己去亲自体验。 封装支持首先使用 Logger 打印一个普通的日志： 1234// MainActivity.java// line number: 26Logger.d(TAG, &quot;#testAndroidLog mId=%d&quot;, mId); 结果如下： 1...io.l0neman.example D/LE#MainActivity: #testAndroidLog mId=8 [main](MainActivity.java:26) 此时，假如想要封装 Logger，如下： 1234567// MainActivity.java// line number: 30private void myLoggerD(String tag, String log) { // line number: 31 Logger.d(tag, log);} 调用我们封装的 myLogger 方法打印： 1234// MainActivity.java// line number: 27myLoggerD(TAG, &quot;hello world&quot;); 结果如下： 1...io.l0neman.example D/LE#MainActivity: hello world [main](MainActivity.java:31) 此时发现栈信息依然是 Logger 原来原始打印语句的地方，这样肯定封装失败了，此时需要修正栈偏移。 由于封装只有一层，那么只要一层栈偏移即可对应到封装方法的调用行，使 STACK_OFFSET 增加 1 即可： 123// 栈偏移，基于标准日志方法的偏移- private static final int STACK_OFFSET = 4;+ private static final int STACK_OFFSET = 5; 再次测试，栈偏移修正到了封装方法上，此时就没问题了。 1...io.l0neman.example D/LE#MainActivity: hello world [main](MainActivity.java:27) 使用方法单项目使用方法对于单个应用来说，把 Logger 复制到项目包中，推荐重命名为与项目相关的有意义的名字，例如对于实例项目 LoggerExample 来说，把 Logger 类，重命名为 LeLogger。 然后将主 TAG 改为应用的标识 LE 即可，然后按照需要自定义 Logger 选项。 在 logcat 中输入 LE# 即可过滤出应用的日志。 多模块项目使用方法当一个项目存在多个模块时，推荐在每个模块中都复制进去一个 Logger 类，然后分别重命名为每个模块的标识。 例如有一个记事本有 Read Module 和 Edit Module 两个模块，那么分别复制两个 Logger 类到两个模块的包，分别重命名为 RmLogger 和 WmLogger，同时更改主 TAG 为 RM 和 WM，这样过滤日志使用主 TAG 就能区分模块的日志了。 在调用时，属于两个模块的代码分别调用各自的 Logger 类，互不干扰，那么就可以各自定义自己的日志开关和选项。 Logger 选项说明 Logger.PRINT = true 此标记控制所在 Logger 类的日志开关，设为 false 时，使用此 Logger 打印的所有日志将被移除。 Logger.STACK_PRINT = true 此标记控制是否在日志尾部显示调用栈信息，例如 (MainActiviy.java:20)。显示后，可使用鼠标点击跳转，设为 false，将不再显示。 Logger.STACK_OFFSET = 4 此标记控制打印单行调用栈信息的偏移。当需要对 Logger 进行包装时，如果包装一层，即 Logger 打印代码的上一次就是包装方法的代码时，将偏移 +1，偏移随着包装方法的层次累加而递增。 Logger.STACK_COUNT = 1 此标记控制打印调用栈信息的数量，默认为 1，只显示当前日志调用行的调用栈信息。可根据需要改变栈信息数量。 设置为 2 时效果如下： 1234...io.l0neman.example D/LE#MainActivity: hello world [main](Activity.java:7791) (Activity.java:7802) (MainActivity.java:21) (MainActivity.java:26) 设置为 7 时效果如下： 1234567...io.l0neman.example D/LE#MainActivity: hello world [main](LaunchActivityItem.java:83) (ActivityThread.java:3409) (ActivityThread.java:3245) (Instrumentation.java:1299) (Activity.java:7791) (Activity.java:7802) (MainActivity.java:21) 仓库地址https://github.com/l0neman/Logger","link":"/2020/07/23/%E5%A5%BD%E7%94%A8%E7%9A%84-android-%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7/"},{"title":"Android 应用进程 ServiceManager 的实现","text":"实现一个普通应用进程中的 ServiceManager，可自由注册和获取 Binder 服务。 文末给出开源仓库地址。 Binder 相关基础可参考：android-binder-设计分析 实名 Binder 与匿名 Binder实名 Binder在 Binder 通信模型中，存在一个 ServiceManager 的角色，它作为 Android 系统的服务总管，负责建立 Binder 名字和 Binder 实体的映射。 提示：ServiceManager 中的 Service 和 android.app.Service 组件不是同一个概念。 ServiceManager 中存在一个 addService 方法，使用它可将一个 Binder 实体通过一个唯一的字符串标识注册到 Binder 驱动中，同时 ServiceManager 会缓存 Binder 的引用，下次通过一个字符串标识来请求 ServiceManager 即可获得对应的 Binder 实体的引用。 Android Framework 层中的系统服务，都是通过 Java 层 ServiceManager 的 addService 方法将自己注册为服务的，例如著名的 ActivityManagerService 和 WindowManagerService： 12345678// AOSP 9.0.0_r3: android.server.am.ActivityManagerService.javapublic void setSystemProcess() { ... ServiceManager.addService(Context.ACTIVITY_SERVICE, this, /* allowIsolated= */ true, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO); ...} 1234567891011// AOSP 9.0.0_r3: android.server.SystemServer.javaprivate void startOtherServices() { ... wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore, new PhoneWindowManager()); ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO); ...} 当注册完成后，就可以通过字符串标识 Context.ACTIVITY_SERVICE 和 Context.WINDOW_SERVICE 来通过 ServiceManager 的 getService 方法获取相应 Binder 服务端的引用，对系统服务发起请求了。 像这样使用字符串标识明确的向 ServiceManager 注册的 Binder 实体，被称为实名 Binder。 提示：在 Android 系统中，四大组件的启动均是通过 ActivityManagerProxy（Binder 客户端）向 ActivityManagerService（Binder 服务端）发送进程间通信请求实现的。 匿名 Binder还存在一种匿名 Binder，匿名 Binder 的创建依赖于一条已经建立的 Binder 连接，通过已建立的 Binder 连接，将 Binder 服务端的引用从服务端进程传递至另一端，此时另一端持有 Binder 引用就可以通过 Binder 驱动与服务端进行沟通了。 匿名 Binder 不通过明确的字符串标识进行注册，而是通过私有 Binder 连接通道传递 Binder 引用，所以匿名 Binder 无法通过枚举或者猜测得到。 除了 ServiceManager 自身通过 0 号引用注册的 Binder 连接（仅服务于实名 Binder 的注册），其他的就只有系统服务注册的实名 Binder 连接了。 所以匿名 Binder 的创建必须通过实名 Binder 来实现。 需求分析如果现在要实现自己的 Binder 服务，服务存在于独立的进程中，且客户端可以获取服务端的 Binder 引用，自由地向服务端发出任务请求，要怎么办呢。 还要考虑动态注册 Binder 服务的需求，现实情况下，一个 Binder 服务可能无法满足业务需求，所以可以考虑以字符串标识对 Binder 服务端进行注册，那么客户端可以利用字符串标识查询对应的 Binder 服务端（类似于 Android 系统的 ServiceManager）。 那么需要分两部分考虑： 实现的 Binder 服务需要在一个进程中运行，在 Android 中四大组件均可在独立进程中运行，首先 Activity 不能在后台运行，所以 Binder 服务不能在 Activity 中运行，BroadcastReceiver 只能执行短时间的任务，所以也不能放置 Binder 服务，那么放在 Service 和 ContentProvider 是可行的。 如果传递 Binder 服务的引用给客户端，客户端持有 Binder 引用后即可向 Binder 服务端发起请求，那么有如下分析： 首先我们的应用处于 Android 普通应用进程中，并没有系统权限，所以不可能通过 Android 系统的 ServiceManager 注册自己的 Binder 服务，那么直接注册成为实名 Binder 服务的方法就不能采用了。 那么现在只能考虑通过匿名 Binder 来实现，先找到一个已建立的实名 Binder 连接，使用这个连接来传递自己的 Binder 服务端的引用给客户端使用即可。 Android 系统服务都是实名 Binder 连接，但是它们提供的接口功能都是固定的，肯定不能自由的被利用，所以只能先找到一个与匿名 Binder 相关的 API。同时为了实现 Binder 服务端，所以还要考虑后台运行的支持。 系统中的 Bundle 可以携带 Binder（使用 putBinder 方法），即 Intent 也能携带 Binder（Intent 可携带 Bundle）；还有 Service 组件的 onBind 方法，在客户端绑定时可以返回 Binder 引用。 那么基于这个条件就可以让的 Service 和 ContentProvider 组件具有了传送匿名 Binder 的功能，如下： 对于 Service 组件，开发者可实现一个远程进程中的 Service，然后实现它的 onBind 方法，返回一个 Binder 对象，这个 Binder 对象的引用将会传递给客户端，客户端（例如 Activity）使用 bindService 方法，通过 ServiceConnection 中的 onServiceConnected 回调获取这个 Binder 引用后，即可向 Service 中的 Binder 对象发送处理相关任务的请求，即通过 bindService 可以获得一个匿名 Binder；同时也可以在启动 Service 时，通过 Intent 携带一个 Bundle 对象，Bundle 对象中携带一个 Binder 对象进行传递，即在启动服务时可通过 Intent 传递 Binder 对象。 对于 ContentProvider 组件，开发者在实现了 ContentProvider 之后，可以在客户端使用 context.getContentResolver() 获取一个 ContentResolver 对象，利用这个 ContentResolver 对象向 ContentProvider 发出增删查改请求（query、delete、insert、update），还可以通过 call 方法发出自定义命令，其中 call 方法最后一个参数可以携带一个 Bundle 对象，这个 Bundle 允许携带 Binder 对象，即通过 call 方法可传递 Binder；同时 call 方法返回一个 Bundle 对象，即 ContentProvider 端也可直接返回 Binder 对象。 即 Service 和 ContentProvider 可以实现独立的 Binder 服务，或者有能力对 Binder 服务进行统一的管理。 分析了需求和实现方法，下面确定一下具体实施方案。 实现方案要通过匿名 Binder 实现一个 Binder 服务，那么首先需要实现一个 Binder 服务端对象，将其放置在远程进程中，再通过匿名 Binder 通道，将 Binder 服务端引用传递给客户端，此时客户端使用 Binder 服务端的引用即可向服务端发起请求，这时就完成了一个 Binder 服务的建立； 如果要实现 Binder 服务的动态注册，Binder 服务可能分布在各个进程中，如果需要统一管理，需要首先建立一个类似于系统 ServiceManager 的角色，ServiceManager 运行在一个独立的进程，Binder 服务可通过进程间通信的方法将自己的 Binder 引用注册到 ServiceManager 中，客户端可以通过 ServiceManager 自由获取 Binder 服务端的引用。 现在有两种办法可以实现匿名 Binder，需要采用哪一种方案实现 Binder 服务呢。 Service 方案如果采用 Service 的方案实现一个 Binder 服务，首先需要实现一个 Service，然后在清单文件中配置它，然后实现一个自己的 Binder 服务端，放在这个远程 Service 中，客户端使用 bindService 获取 Binder 服务端的 Binder 引用即可，不过这样的话看起来和直接使用 Service 组件没有任何区别，属于脱裤子放屁； 如果实现 Binder 服务端的动态注册，将需要使用到的 Binder 服务端对象动态传递至 Service 中，然后客户端再想办法查询 Binder 服务端的引用。那么考虑借助 Intent 对象，利用 Context 的 startService 或 bindService 方法动态传递 Binder 对象至 Service 中，在 Intent 中携带字符串标识，然后在 Service 中建立一个用字符串作为标识的 Map&lt;String, IBinder&gt; 结构缓存这些 Binder 服务端，当客户端获取时，首先需要使用 bindService 方法，绑定 Service，然后 Service 返回一个 Binder 引用，不过这个 Binder 引用并不能是客户端想要获取的 Binder 服务端引用，因为每次绑定 Service，它都始终返回同一个 Binder，就是 Service 的 onBinder 方法第一次返回的那个 Binder，所以这个 Binder 需要作为一个中转的 Binder 服务端，需要先使用 AIDL 定义一个服务获取客户端想要的 Binder 服务端的方法，例如： 12345// IBridge.aidlinterface IBridge { IBinder getBinder(String name);} 那么客户端通过获取这个 IBridge 对象的 Binder 引用之后，再调用 getBinder 查询 Service 中 Map&lt;String, IBinder&gt; 缓存的 Binder 服务端引用即可。 这是使用 Service 组件的方案，看起来挺麻烦，下面再说使用 ContentProvider 组件的实现方案。 ContentProvider 方案如果采用 ContentProvider 的方案实现一个 Binder 服务，那么首先需要实现一个 ContentProvider，然后也需要清单文件中配置它，然后实现一个自己的 Binder 服务端，放在这个远程进程的 ContentProvider 中，客户端使用 call 获取返回的 Bundle 数据包，然后读取出其中携带的 Binder 服务端的 Binder 引用即可，ContentProvider 的本意是为了共享数据，但这样一来就被赋予了新的功能，用来做 Binder 服务端的支持。不过相对于使用 Service 实现一个 Binder 服务来说，也没有体现出太多优势； 如果实现 Binder 服务端的动态注册，将需要使用到的 Binder 服务端对象动态传递至 ContentProvider 中，然后客户端再想办法查询 Binder 服务端的引用。那么可以直接使用 call 方法将字符串标识和通过 Bundle 数据包将服务端 Binder 发送至 ContentProvider 中，ContentProvider 使用一个 Map&lt;String, IBinder&gt; 缓存即可，下次客户端可以直接使用字符串标识通过 call 方法请求获取对应的 Binder 服务端，那么 ContentProvider 直接返回携带对应 Binder 服务端的引用即可，这样来看就比 Service 实现动态注册 Binder 服务有优势的多。 最终结论通过对两种方案的描述，谁更有优势显而易见。 对于 Service 来说，它还存在诸多限制，例如 bindService 绑定存在限制，BroadcastReceiver 组件无法绑定、绑定后必须取消绑定、或者服务不允许在后台运行，除非加上前台通知才允许后台运行，即使抛开这些限制，使用它实现 Binder 服务也是很麻烦的（需要借助 ServiceConnectation）。 反观 ContentProvider 均不存在上述限制，无需绑定，直接使用 call 请求即可，API 足够简洁，看起来可以完美的实现 Binder 服务。 实现根据上面的实现方案分析（最终确定了使用 ContentProvider 组件实现），下面来真正实现 Android 应用进程中的 Binder 服务。 一个 Binder 服务首先定义一个 Binder 服务的 AIDL 协议文件： 123456// IFoo.aidlpackage io.l0neman.example;interface IFoo { int add(int x, int y);} 它是一个叫 IFoo 的 Binder 服务，它内部有一个负责两数相加的 add 方法 然后实现一个 ContentProvider，叫做 ServiceProvider，然后直接将 IFoo 服务内置进去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ServiceProvider extends ContentProvider { public static final String ACTION_GET_SERVICE = &quot;act.ser&quot;; public static final String KEY_SERVER = &quot;ser&quot;; public static final String URI = &quot;content://io.l0neman.example.binder&quot;; private FooService mFooService = new FooService(); // Binder 服务端的实现 private static final class FooService extends IFoo.Stub { @Override public int add(int x, int y) { return x + y; } } @Nullable @Override public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) { if (ACTION_GET_SERVICE.equals(method)) { // 获取 Service 则返回携带 FooService 的 Bundle Bundle result = new Bundle(); BundleCompat.putBinder(result, KEY_SERVER, mFooService); return result; } return null; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); } @Override public String getType(Uri uri) { throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); } @Override public Uri insert(Uri uri, ContentValues values) { throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); } @Override public boolean onCreate() { return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); }} 清单文件： 12345&lt;provider android:name=&quot;io.l0neman.example.ServiceProvider&quot; android:exported=&quot;false&quot; android:authorities=&quot;io.l0neman.example.binder&quot; android:enabled=&quot;true&quot; /&gt; 很简单的代码，当任何客户端对 ServiceProvider 发出 call 请求，且 method 参数为 ACTION_GET_SERVICE 时，就返回一个携带 IFoo 服务的 Binder 对象。 此时客户端即可使用 call 获取服务端的 Binder 向服务端请求了。 12345678910111213141516171819202122// MainActivity.java@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final Bundle result = getContentResolver().call(Uri.parse(ServiceProvider.URI), ServiceProvider.ACTION_GET_SERVICE, null, null); if (result != null) { IBinder ref = BundleCompat.getBinder(result, ServiceProvider.KEY_SERVER); // 获取服务端 Binder IFoo foo = IFoo.Stub.asInterface(ref); if (foo != null) { try { // 调用服务端方法 final int add = foo.add(1, 2); Log.d(TAG, &quot;add: &quot; + add); } catch (RemoteException ignore) {} } }} 执行即可看到结果 3。 提示：这里有一个细节是，ServiceProvider 与应用主进程相同，此时里面的 IFoo Binder 服务端也和它处于同一进程，那么此时通过 Bundle 返回的 ref 并不是 Binder 引用，而是直接返回 ServiceProvider 的 mFooService 对象（Binder 类表示），如果 ServiceProvider 在另一个进程，那么通过 Bundle 返回的将是 Binder 引用（BinderProxy 类表示）。 12345678910111213141516// IFoo - IFoo$Stub...public static io.l0neman.example.IFoo asInterface(android.os.IBinder obj) { if (obj == null) { return null; } // 查询 Binder 是否在本地 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); // 如果 obj 对象是 Binder 服务端对象，iin 将为 obj 自己，如果 obj 是 Binder 引用，则为 null if (iin != null &amp;&amp; iin instanceof io.l0neman.example.IFoo) { // 本进程直接则直接返回 Binder 对象 return (io.l0neman.example.IFoo) iin; } // 否则返回 Binder 的引用，通过 Proxy 提供的方法，可向 Binder 服务端发送请求 return new io.l0neman.example.IFoo.Stub.Proxy(obj);} 123456789// Binder.java...public IInterface queryLocalInterface(String descriptor) { if (mDescriptor.equals(descriptor)) { return mOwner; } return null;} 123456// Binder.java - class BinderProxy...public IInterface queryLocalInterface(String descriptor) { return null;} 动态注册 Binder 服务动态注册服务，就是可以自由的注册 Binder 服务，注册后，客户端可以依据标识获取对应功能的服务端 Binder 的引用，然后向对应 Binder 服务发起任务请求。 按照前面的想法，先在 ContentProvider 中创建一个 Map&lt;String, IBinder&gt;，当 Binder 服务注册时，使用 call 方法将 Binder 服务端对象传递过来，此时 ContentProvider 接收到 Binder 服务端对象的引用，使用 Map 缓存起来，下一次，客户端再使用 call 方法传入字符串标识，ContentProvider 接收到字符串标识从 Map 中取出 Binder 端服务对象的引用，返回给客户端。 一般方法是在 ContentProvider 的 call 方法中，实现多个 method 参数的处理，例如使用 switch。考虑到以后还可能实现取消注册 Binder 服务等方法，那么每次都需要在 switch 中添加分支处理，这样的话看起来太麻烦了，而且可读性极差，其实可以直接采用面向对象的方式来完成。 首先，先实现一个叫做 ServiceManager 的 Binder 服务，这个 Binder 服务将直接内置在 ContentProvider 中，负责管理其他 Binder 服务的注册、获取、和取消注册等一系列事务。 类似于 Android 系统的 ServiceManager，系统的 ServiceManager 是直接在 Android 系统启动时使用 0 号引用注册到驱动中的，那么我们的应用进程中的 ServiceManager 就直接内置在一个 ContentProvider 中，当 ContentProvider 启动，ServiceManager 也就可以使用了。 首先定义 ServiceManager 的 AIDL 协议文件： 123456789101112// IServiceManager.aidlpackage io.l0neman.app;interface IServiceManager { // 注册服务 void addService(in String name, in IBinder binder); // 获取服务 IBinder getService(in String name); // 移除服务 void removeService(in String name);} 然后实现 ServiceManager 的具体逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// io.l0neman.apppublic class ServiceManagerImpl extends IServiceManager.Stub { private static final String TAG = ServiceManagerImpl.class.getSimpleName(); // 保存正在活动的 Binder 对象 private Map&lt;String, ServiceEntry&gt; mAliveServices = new ArrayMap&lt;&gt;(); // 保存已经死亡的 Binder 对象 private Map&lt;String, ServiceEntry&gt; mDiedServices = new ArrayMap&lt;&gt;(); @Override public void addService(final String name, IBinder binder) throws RemoteException { if (mAliveServices.containsKey(name)) { // 不允许重复注册 ServiceEntry item = mAliveServices.get(name); throw new RuntimeException(String.format(&quot;Service %s has registed by pid: %s, uid: %s&quot;, name, item.callingPid, item.callingUid)); } IBinder.DeathRecipient recipient = new IBinder.DeathRecipient() { @Override public void binderDied() { ServiceEntry entry = mAliveServices.remove(name); if (entry != null) { // 保存死亡的 Binder 对象 mDiedServices.put(name, entry); } } }; // 保存 Binder ServiceEntry entry = new ServiceEntry(name, Binder.getCallingPid(), Binder.getCallingUid(), binder, recipient); mAliveServices.put(name, entry); mDiedServices.remove(name); // Binder 的死亡通知 entry.linkToDeath(); Log.d(TAG, &quot;#addService: &quot; + name); } @Override public IBinder getService(String name) { ServiceEntry entry = mAliveServices.get(name); if (entry == null) { Log.d(TAG, &quot;#getService form died: &quot; + name); entry = mDiedServices.get(name); } if (entry != null) { return entry.binder; } Log.e(TAG, &quot;#getService: &quot; + name); return null; } @Override public void removeService(String name) throws RemoteException { ServiceEntry entry = mAliveServices.get(name); if (entry != null) { // 取消注册 Binder 死亡通知 entry.unlinkToDeath(); } mDiedServices.remove(name); }} 逻辑并不难理解，其中 ServiceEntry 是为了保存 Binder 服务端的相关信息的类型，可以利用这些信息做权限控制，例如限制指定的客户端进程 ID 和客户端 uid 才能&gt;使用，代码如下： 1234567891011121314151617181920212223242526272829private static final class ServiceEntry { final String name; // Binder 服务端字符串标识 final int callingPid; // 客户端的进程 ID final int callingUid; // 客户端的用户 ID final IBinder binder; // Binder 服务端对象 IBinder.DeathRecipient recipient; ServiceEntry(String name, int callingPid, int callingUid, IBinder binder, IBinder.DeathRecipient recipient) { this.name = name; this.callingPid = callingPid; this.callingUid = callingUid; this.binder = binder; this.recipient = recipient; } void linkToDeath() throws RemoteException { if (binder != null &amp;&amp; recipient != null) { binder.linkToDeath(recipient, 0); } } void unlinkToDeath() { if (binder != null &amp;&amp; recipient != null) { binder.unlinkToDeath(recipient, 0); } }} 然后创建一个 ServiceManagerProvider，将 ServiceManagerImpl 内置进去。 12345678910111213141516171819202122232425262728293031323334353637public class ServiceManagerProvider extends ContentProvider { private static final String TAG = ServiceManagerProvider.class.getSimpleName(); public static final String URI = &quot;content://io.l0neman.app.provider&quot;; public static final String KEY_SM = &quot;binder&quot;; public static final String METHOD_SM = &quot;$&quot;; private ServiceManagerImpl mServiceManager = new ServiceManagerImpl(); @Override public boolean onCreate() { Log.i(TAG, &quot;#onCreate&quot;); return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { return null; } @Override public String getType(Uri uri) { return null; } @Override public Uri insert(Uri uri, ContentValues values) { return null; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { return 0; } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { return 0; } @Override public Bundle call(String method, String arg, Bundle extras) { if (METHOD_SM.equals(method)) { Bundle service = new Bundle(); BundleCompat.putBinder(service, KEY_SM, mServiceManager); return service; } return null; }} 清单配置： 123456&lt;provider android:name=&quot;io.l0neman.app.ServiceManagerProvider&quot; android:authorities=&quot;io.l0neman.app.provider&quot; android:exported=&quot;false&quot; android:process=&quot;:sm&quot; android:grantUriPermissions=&quot;true&quot; /&gt; 然后实现 ServiceManager 的客户端封装，作为 API 提供给服务端注册自身 Binder 对象或客户端获取 Binder 服务端引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class ServiceManager { private static final String TAG = ServiceManager.class.getSimpleName(); private ServiceManager() { throw new AssertionError(&quot;no instance.&quot;); } private static IServiceManager sIServiceManager; // 获取 ServiceManager 的 Binder 引用（实则为 Binder 引用的封装，Proxy 对象） private static void ensureIServiceManager(final Context context) { Bundle bundle = context.getContentResolver().call( Uri.parse(ServiceManagerProvider.URI), ServiceManagerProvider.METHOD_SM, null, new Bundle()); if (bundle == null) { throw new RuntimeException(&quot;Service Manager is null [Bundle]&quot;); } IBinder serviceManager = BundleCompat.getBinder(bundle, ServiceManagerProvider.KEY_SM); if (serviceManager == null) { throw new RuntimeException(&quot;Service Manager is null [getBinder]&quot;); } try { serviceManager.linkToDeath(new IBinder.DeathRecipient() { @Override public void binderDied() { // Binder 死亡则尝试重新获取 ensureIServiceManager(context); } }, 0); } catch (RemoteException e) { Log.w(TAG, &quot;ensureIServiceManager: linkToDeath&quot;, e); } sIServiceManager = IServiceManager.Stub.asInterface(serviceManager); } private static IServiceManager getIServiceManager(Context context) { ensureIServiceManager(context); return sIServiceManager; } public static void addService(Context context, String name, IBinder binder) { try { getIServiceManager(context).addService(name, binder); } catch (RemoteException e) { Log.w(TAG, &quot;addService&quot;, e); } } public static IBinder getService(Context context, String name) { try { return getIServiceManager(context).getService(name); } catch (RemoteException e) { Log.w(TAG, &quot;#getService&quot;, e); return null; } } public static void removeService(Context context, String name) { try { getIServiceManager(context).removeService(name); } catch (RemoteException e) { Log.w(TAG, &quot;#removeService&quot;, e); } }} 很简单的封装，下面直接测试就好了。 测试首先定义两个服务 foo 和 bar 的 AIDL 接口，它们分别负责相加运算和相减运算。 1234567// IFoo.aidlpackage io.l0neman.example;interface IFoo { int add(int x, int y);} 1234567// IBar.aidlpackage io.l0neman.example;interface IBar { int sub(int x, int y);} 然后在 MainActivity 的 onCreate 方法中直接注册两个 Binder 服务。 在点击 test 按钮时分别获取两个服务的 Binder 引用，请求服务执行，获取结果。 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ServiceManager.addService(this, &quot;foo&quot;, new IFoo.Stub() { @Override public int add(int x, int y) { return x + y; } }); ServiceManager.addService(this, &quot;bar&quot;, new IBar.Stub() { @Override public int sub(int x, int y) { return x - y; } }); } // 点击测试按钮 public void test(View view) { IFoo iFoo = IFoo.Stub.asInterface(ServiceManager.getService(this, &quot;foo&quot;)); if (iFoo != null) { try { final int add = iFoo.add(1, 2); Log.d(TAG, &quot;add: &quot; + add); } catch (RemoteException ignore) {} } IBar iBar = IBar.Stub.asInterface(ServiceManager.getService(this, &quot;bar&quot;)); if (iBar != null) { try { final int sub = iBar.sub(3, 1); Log.d(TAG, &quot;sub: &quot; + sub); } catch (RemoteException ignore) {} } }} 代码也很简单，最终输出结果为 add: 3 和 sub: 2。 提示： ServiceManagerProvider 运行在一个独立进程中，和 MainActivity 处于不同的进程中，那么 MainActivity 中的两个 Binder 服务端对象通过 Bundle 传递给 ServiceManagerProvider 时将变成一个 Binder 引用，此时 ServiceManagerImpl 可对这些 Binder 引用进行统一管理。对于另一个进程中的 ContentProvider，主进程对于 call 方法的调用，将穿过 ActivityManagerProxy 与 ActivityManagerService 建立的匿名 Binder 通道传递 Bundle 数据，此时在 Bundle 中携带的 Binder 对象将被自动转换为 Binder 引用，至于转化过程的细节，在此不再赘述，后面再分析。 下面 test 方法中的获取的 Binder 对象直接就是 MainActivity 中的两个 Binder 服务端对象并非引用，因为 Binder 服务端和 test 方法在同一个进程中，所以 ServiceManager.getService 返回的对象是 Binder 服务端对象（Binder 类表示），那么 asInterface 中的 queryLocalInterface 将返回 Binder 服务端对象自身。 当客户端在其他进程调用 ServiceManager.getService 获取 Binder 服务端引用，与 Binder 服务端进程不在同一个进程中时，那么客户端获取的就是服务端的 Binder 引用（BinderProxy 类表示）。 这样就实现了一个普通应用进程中的 ServiceManager，通过统一管理匿名 Binder 的方式，实现了一种伪实名 Binder。 开源仓库https://github.com/l0neman/AppServiceManager 应用场景：只要是涉及两个进程间的通信，都可以用到，例如插件端和宿主端的通信、或实现一个主控制端服务，根据请求执行不同的任务。 参考 https://github.com/cmzy/DroidService","link":"/2020/07/27/android-%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B-servicemanager-%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"支持触摸拖动的 TouchDelegate","text":"需求最近有一个小需求，就是在界面上有一个预览图片的区域，这个区域用户可以双击缩放图片、双指自由缩放图片、触摸图片进行移动，对图片的局部区域进行查看，像这样： 这个功能可以使用 github 中的开源库 PhotoView 实现，地址：https://github.com/Baseflow/PhotoView 同时另一个条件是当前这个图像预览区域较小，不像上图这样预览区域比较大，大概是 4 分之 1 左右，如果直接使用 PhotoView 设置图片，那么用户体验可能较差，因为图像展示区域较小，难以进行自由的图像移动预览操作，所以这个需求就是：扩大触摸区域，让用户在图像显示区域的外侧也可以自由的对图像进行移动预览操作。如下，白色区域是 PhotoView 的父控件的区域，用户触摸和双击这里时，可对图像进行预览操作： 先把 PhotoView 放置在布局中，然后设置一张图片，PhotoView 本身会支持图片的双击和双指缩放与移动预览，如果要实现上述的需求，当时想到了两种解决方案： 将 PhotoView（图像预览控件）的父控件的触摸事件传递给 PhotoView，那么用户触摸在父控件上时，PhotoView 将会接收到触摸事件，从而控制内部图像的缩放和移动； 先将 PhotoView 本身尺寸变大，填满白色区域，再想办法将图片显示区域限制到需要的大小，需要手动使用代码调整图片显示到限制区域 显然第二种方法是需要对 PhotoView 控件进行额外处理和调整，与 PhotoView 紧密相连，第一种方法只需要将触摸事件传递给 PhotoView 即可，那么第一种方法更灵活和通用，所以优先选择第一种方案进行处理 采取第一种方案，通常可以自定义一个 ViewGroup，将它作为 PhotoView 的父控件，并重写它的 dispatchTouchEvent 方法，将事件全部传递给 PhotoView 处理。但这种方法不够灵活，因为需要创建一个特定的 ViewGroup 类型。那么还有没有其他的方法？发现 Android 提供了一个 TouchDelegate 的类，使用它可以扩大一个 View 的触摸区域，听起来挺符合当前需求的场景，那么计划使用 TouchDelegate 来实现这个需求。 首先看一下 TouchDelegae 的基本用法 TouchDelegate 用法12345678910public static void expandViewTouchBounds(final View view, final View parent) { Rect bounds = new Rect(); bounds.left = 0; bounds.top = 0; bounds.right = parent.getWidth(); bounds.bottom = parent.getHeight(); TouchDelegate touchDelegate = new TouchDelegate(bounds, view); parent.setTouchDelegate(touchDelegate);} 12// 扩展 photoView 的触摸区域到 parent 上expandViewTouchBounds(photoView, parent); 使用方法很简单，首先创建一个 TouchDelegate 对象，然后设置给父控件，其中 bounds 为在父控件中扩展的触摸区域，坐标相对于父控件，示例中设置为整个父控件的区域。 Bug本以为这样就可以了，通过测试发现在 PhotoView 外部的区域用单个手指触摸移动，图像预览区域根本无法跟着移动，但是却可以响应双击和双指的缩放事件。难道是用法的不对。 通过查看 TouchDelegate 的源代码发现，其实 TouchDelegate 是无法支持移动的触摸事件的响应的，只能支持 click 事件。关键代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Forward touch events to the delegate view if the event is within the bounds * specified in the constructor. * * @param event The touch event to forward * @return True if the event was consumed by the delegate, false otherwise. */public boolean onTouchEvent(@NonNull MotionEvent event) { int x = (int)event.getX(); int y = (int)event.getY(); boolean sendToDelegate = false; boolean hit = true; boolean handled = false; switch (event.getActionMasked()) { case MotionEvent.ACTION_DOWN: mDelegateTargeted = mBounds.contains(x, y); sendToDelegate = mDelegateTargeted; break; case MotionEvent.ACTION_POINTER_DOWN: case MotionEvent.ACTION_POINTER_UP: case MotionEvent.ACTION_UP: case MotionEvent.ACTION_MOVE: sendToDelegate = mDelegateTargeted; if (sendToDelegate) { Rect slopBounds = mSlopBounds; if (!slopBounds.contains(x, y)) { hit = false; } } break; case MotionEvent.ACTION_CANCEL: sendToDelegate = mDelegateTargeted; mDelegateTargeted = false; break; } if (sendToDelegate) { if (hit) { // Offset event coordinates to be inside the target view event.setLocation(mDelegateView.getWidth() / 2, mDelegateView.getHeight() / 2); } else { // Offset event coordinates to be outside the target view (in case it does // something like tracking pressed state) int slop = mSlop; event.setLocation(-(slop * 2), -(slop * 2)); } handled = mDelegateView.dispatchTouchEvent(event); } return handled;} 核心逻辑并不复杂，其中 mDelegateView 为被代理处理事件的 View，也就是 PhotoView。 主要关注下面 if (sendToDelegate) { . . . } 代码块中的逻辑，当触摸事件发生点的坐标落在 bounds 内，那么 hit 为 true，执行： 1event.setLocation(mDelegateView.getWidth() / 2, mDelegateView.getHeight() / 2); setLocation 的含义是重新设置 MotionEvent 的 x，y 坐标，也就是 getX() 和 getY() 的返回值。 那么从这里看出来，无论触摸事件的 action 是什么，都会将触摸坐标设置为被代理 View 的中心点，自然用手指触摸 View 外部区域移动时图像并不会跟着移动了。不过双击事件还是没有问题的，可正常检测到。 按照需求，肯定需要支持触摸拖动预览图片，结合目前情况，只能自己修复 TouchDelegate 中的事件传递逻辑了。父控件比 PhotoView 的区域大，当用户触摸到父控件区域内时，应该怎样处理？通常一个简单的规则就是按比例映射，按照触摸点 x、y 坐标在父控件内所占父控件尺寸的比例，设置在相对于子 View 区域相同的宽高比例的坐标上。 改进 TouchDelegate根据分析，那么需要改进 TouchDelegate 原始处理逻辑中将坐标固定的问题，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean onTouchEvent(@NonNull MotionEvent event) { int x = (int)event.getX(); int y = (int)event.getY(); boolean sendToDelegate = false; boolean hit = true; boolean handled = false; switch (event.getActionMasked()) { case MotionEvent.ACTION_DOWN: mDelegateTargeted = mBounds.contains(x, y); sendToDelegate = mDelegateTargeted; break; case MotionEvent.ACTION_POINTER_DOWN: case MotionEvent.ACTION_POINTER_UP: case MotionEvent.ACTION_UP: case MotionEvent.ACTION_MOVE: sendToDelegate = mDelegateTargeted; if (sendToDelegate) { Rect slopBounds = mSlopBounds; if (!slopBounds.contains(x, y)) { hit = false; } } break; case MotionEvent.ACTION_CANCEL: sendToDelegate = mDelegateTargeted; mDelegateTargeted = false; break; } if (sendToDelegate) { if (hit) {222// 按照父控件比例修正触摸点坐标 float newX = x * 1F / mBounds.width() * mDelegateView.getWidth(); float newY = y * 1F / mBounds.height() * mDelegateView.getHeight(); event.setLocation(newX, newY); } else { int slop = mSlop; event.setLocation(-(slop * 2), -(slop * 2)); } handled = mDelegateView.dispatchTouchEvent(event); } return handled;} 新的 Bug本以为没问题了，然而再次测试，发现单个手指触摸在 PhotoView 区域外，也就是父控件区域内时，图像也可以正常移动预览了。但是经过多次测试，发现存在有一个瑕疵，可以说就是一个 Bug。 问题描述： 首先在父控件区域按下一个手指，然后再按下第二个手指，此时在第二个手指不放开的情况下，抬起第一个手指时，图像会出现跳跃现象，而在 PhotoView 区域内进行这样的操作就不会出现跳跃的问题，那么说明上面的触摸区域扩大的逻辑处理还是存在问题的。 如下图，在第二个手指不放开的情况下，第一个手指抬起、放下、抬起、放下会触发图像的跳跃： 通过现象进行猜测，显然是两次触摸坐标之间的差值过大，导致 PhotoView 认为用户瞬间拖动了很长一段距离，图像跟着瞬间移动，就会出现跳跃现象 通过调试以及日志打印经过父控件的触摸事件的坐标，包括上面修复坐标的代码 event.setLocation(newX, newY); 发现坐标转换并没有问题，那么问题处在哪里？由于当时对于多点触控事件处理并不熟悉，而上面出现的 Bug 显然和多指触摸相关，结合上面观察到的现象：使用同样的流程在 PhotoView 内部就不会出现这种问题，而在父控件的区域操作就会出现，那么开始对 PhotoView 内部的接收到触摸事件的逻辑进行调试，通过对比在父控件和在 PhotoView 中的事件处理，最终发现了问题。 首先说一下像这种手指触摸控制图片移动时的场景在多指触摸时的典型处理方法。 图片移动预览典型处理方法对于多点触摸的情况，onTouchEvent 方法接收到的触摸事件按照操作顺序是这样： 123456789101112131. 第一个手指按下，触发 `ACTION_DOWN` 事件2. 第一个手指移动，触发 `ACTION_MOVE` 事件3. 第二个手指按下，触发 `ACTION_POINTER_DOWN` 事件，此时处于两个手指都按下的状态，可用 `event.getActionIndex()` 方法获得抬起手指触摸点的索引（继续按下手指，都将触发 `ACTION_POINTER_DOWN` 事件）4. 任意一个手指移动，触发 `ACTION_MOVE` 事件5. 任意一个手指抬起，触发 `ACTION_POINTER_UP` 事件，此时可用 `event.getActionIndex()` 方法获得抬起手指触摸点的索引（只要屏幕上抬起的不是最后一个手指，那么就会触发 `ACTION_POINTER_UP` 事件）6. 此时屏幕上只剩下一个手指，抬起触发将 `ACTION_UP` 事件 在处理手指触摸图片内容控制移动时，首先认为活动的手指（也就是负责移动图像内容的手指）只有一个，当第一个手指按下时那么第一个手指就是活动手指，可以使用一个变量进行记录它的 id： 1234567891011121314151617181920public boolean onTouchEvent(MotionEvent event) { switch (event.getActionMasked()) { ... case MotionEvent.ACTION_DOWN: { final int pointerIndex = event.getActionIndex(); final float x = event.getX(pointerIndex); final float y = event.getY(pointerIndex); // 记录最后触摸坐标，用来计算图片移动偏移 mLastTouchX = x; mLastTouchY = y;22// 记录活动手指 id mActivePointerId = event.getPointerId(pointerIndex); break; } ... } return super.onTouchEvent(event);} 当手指移动时，根据活动手指的坐标和最后触摸点的差计算出移动的偏移，然后对图片进行移动： 123456789101112131415161718192021222324public boolean onTouchEvent(MotionEvent event) { ... switch (event.getActionMasked()) { case MotionEvent.ACTION_MOVE: {22// 根据活动手指 id 获取触摸点索引 final int pointerIndex = event.findPointerIndex(mActivePointerId);22 final float x = event.getX(pointerIndex); final float y = event.getY(pointerIndex); // 计算图片拖动偏移 final float dx = x - mLastTouchX; final float dy = y - mLastTouchY; // todo: 使用 dx 和 dy 对图片进行移动 mLastTouchX = x; mLastTouchY = y; break; }2... } return super.onTouchEvent(event);} 此时虽然活动手指只有一个，但是触摸的手指可能是多个，不过我们只关心活动手指，需要关心一种特殊情况，就是当活动手指离开屏幕的时候，此时屏幕上还有多个手指，这种情况怎么处理？一种简单的情况就是把下一根手指作为活动手指，当屏幕上抬起的不是最后一个手指，那么就会触发 ACTION_POINTER_UP 事件，可以在这里进行判断处理，如果活动手指抬起，那么将活动手指的重任交给还在屏幕上的另一个手指： 12345678910111213141516171819202122public boolean onTouchEvent(MotionEvent event) { ... switch (event.getActionMasked()) { case MotionEvent.ACTION_POINTER_UP: { final int pointerIndex = event.getActionIndex(); final int pointerId = event.getPointerId(pointerIndex); // 如果抬起的手指是活动手指 if (pointerId == mActivePointerId) { // 交接给下一个手指 final int newPointerIndex = pointerIndex == 0 ? 1 : 0; // 更新活动手指 id 和坐标 mLastTouchX = event.getX(newPointerIndex); mLastTouchY = event.getY(newPointerIndex); mActivePointerId = event.getPointerId(newPointerIndex); } break; } ... } return super.onTouchEvent(event);} 分析 Bug 原因了解了图片处理规则之后，可以对上面的 Bug 进行分析了。 其实 PhotoView 也是这样处理图片移动的，如果按照正常逻辑，当第一个手指按下时，它是活动手指，正常记录坐标，第二个手指按下时，忽略它的坐标，当第一个手指抬起时，这时触发 ACTION_POINTER_UP 事件，需要转换活动手指，将最后一次触摸的坐标设置为第二个还未抬起的手指最后坐标，活动手指也设置为第二个手指的 id，此时当第二个手指开始移动时，那么当前手指坐标与最后坐标做差获得图片移动的值，对图片进行移动。正常流程不会出现跳跃的问题，始终跟随手指移动。 而对于触摸在父控件出现 Bug 的情况，通过调试和日志发现在最后处理活动手指的转换时出现了坐标的转换失误，就在处理 ACTION_POINTER_UP 事件的逻辑中。当多个手指同时触摸在屏幕上时，MotionEvent 这个对象中包含所有手指的坐标信息，两个手指时，它包含 x0、y0、x1、y1，然而 event.setLocation 这个方法只能改变 x0、x1 的坐标，x1 和 y1 即第二个即将变为活动状态的手指坐标则没有经过处理，它还是原始父控件的坐标，那么 mLastTouchX 和 mLastToachX 被赋予了错误的坐标值。此时活动手指的工作交接已完成，屏幕上只剩下一个手指，就是之前的第二个手指，当它开始移动时，它的坐标将被存储在 x0 和 y0 中，此时能够获取正确的值，再与还未转换的 mLastTouchX 和 mLastToachX 做差值，计算出一个较大的错误的偏移，导致图片发生跳跃，这就是这个 Bug 的原因。 总结就是 event.setLocation 方法只能改变屏幕上第一个手指的坐标，而其它手指坐标无法改变。 完善 TouchDelegate分析完了问题，那么就可以开始修复了，既然 setLocation 无法改变所有手指坐标，那么需要找到其他方法，在 MotionEvent 的 API 中浏览了一遍，貌似没有直接修改其他手指的 API，但是 MotionEvent 提供了 obtain 方法，它可以获得一个新的 MotionEvent 对象，从参数上看，可以生成多个手指的坐标信息，经过测试，完美解决了问题，关键代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344event = MotionEvent.obtain( System.currentTimeMillis(), System.currentTimeMillis(), event.getAction(), event.getPointerCount(), getPointerProperties(event), fixPointerCoords(event), event.getMetaState(), event.getButtonState(), event.getXPrecision(), event.getYPrecision(), event.getDeviceId(), event.getEdgeFlags(), event.getSource(), event.getFlags());...private MotionEvent.PointerProperties[] getPointerProperties(MotionEvent event) { int pointerCount = event.getPointerCount(); MotionEvent.PointerProperties[] properties = new MotionEvent.PointerProperties[pointerCount]; for (int i = 0; i &lt; pointerCount; i++) { MotionEvent.PointerProperties pointerProperties = new MotionEvent.PointerProperties(); event.getPointerProperties(i, pointerProperties); properties[i] = pointerProperties; } return properties;}private MotionEvent.PointerCoords[] fixPointerCoords(MotionEvent event) { int pointerCount = event.getPointerCount(); MotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[pointerCount]; for (int i = 0; i &lt; pointerCount; i++) { MotionEvent.PointerCoords coords = new MotionEvent.PointerCoords(); event.getPointerCoords(i, coords); coords.x = coords.x * 1F / mBounds.width() * mDelegateView.getWidth(); coords.y = coords.y * 1F / mBounds.width() * mDelegateView.getWidth(); pointerCoords[i] = coords; } return pointerCoords;} 完整源码下面是修复过的 TouchDelegate 完整源码，可直接拿来用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class FixTouchDelegate extends TouchDelegate { private final View mDelegateView; private final Rect mBounds; private final Rect mSlopBounds; private boolean mDelegateTargeted; private final int mSlop; public FixTouchDelegate(Rect bounds, View delegateView) { super(bounds, delegateView); mBounds = bounds; mSlop = ViewConfiguration.get(delegateView.getContext()).getScaledTouchSlop(); mSlopBounds = new Rect(bounds); mSlopBounds.inset(-mSlop, -mSlop); mDelegateView = delegateView; } @Override public boolean onTouchEvent(MotionEvent event) { int x = (int) event.getX(); int y = (int) event.getY(); boolean sendToDelegate = false; boolean hit = true; boolean handled = false; switch (event.getActionMasked()) { case MotionEvent.ACTION_DOWN: mDelegateTargeted = mBounds.contains(x, y); sendToDelegate = mDelegateTargeted; break; case MotionEvent.ACTION_POINTER_DOWN: case MotionEvent.ACTION_POINTER_UP: case MotionEvent.ACTION_UP: case MotionEvent.ACTION_MOVE: sendToDelegate = mDelegateTargeted; if (sendToDelegate) { if (!mSlopBounds.contains(x, y)) { hit = false; } } break; case MotionEvent.ACTION_CANCEL: sendToDelegate = mDelegateTargeted; mDelegateTargeted = false; break; } if (sendToDelegate) { MotionEvent obtain = null; if (hit) { // Offset event coordinates to be inside the target view // event.setLocation(mDelegateView.getWidth() / 2, mDelegateView.getHeight() / 2); obtain = MotionEvent.obtain( System.currentTimeMillis(), System.currentTimeMillis(), event.getAction(), event.getPointerCount(), getPointerProperties(event), fixPointerCoords(event), event.getMetaState(), event.getButtonState(), event.getXPrecision(), event.getYPrecision(), event.getDeviceId(), event.getEdgeFlags(), event.getSource(), event.getFlags() ); } else { // Offset event coordinates to be outside the target view (in case it does // something like tracking pressed state) int slop = mSlop; event.setLocation(-(slop * 2), -(slop * 2)); } if (obtain != null) { handled = mDelegateView.dispatchTouchEvent(obtain); obtain.recycle(); } else { handled = mDelegateView.dispatchTouchEvent(event); } } return handled; } private MotionEvent.PointerProperties[] getPointerProperties(MotionEvent event) { int pointerCount = event.getPointerCount(); MotionEvent.PointerProperties[] properties = new MotionEvent.PointerProperties[pointerCount]; for (int i = 0; i &lt; pointerCount; i++) { MotionEvent.PointerProperties pointerProperties = new MotionEvent.PointerProperties(); event.getPointerProperties(i, pointerProperties); properties[i] = pointerProperties; } return properties; } private MotionEvent.PointerCoords[] fixPointerCoords(MotionEvent event) { int pointerCount = event.getPointerCount(); MotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[pointerCount]; for (int i = 0; i &lt; pointerCount; i++) { MotionEvent.PointerCoords coords = new MotionEvent.PointerCoords(); event.getPointerCoords(i, coords); coords.x = coords.x * 1F / mBounds.width() * mDelegateView.getWidth(); coords.y = coords.y * 1F / mBounds.width() * mDelegateView.getWidth(); pointerCoords[i] = coords; } return pointerCoords; }} 调用方法 12345678910111213141516public static void expandViewTouchDelegate(final View view, final View parent) { view.post(() -&gt; { Rect bounds = new Rect(); view.setEnabled(true); ((ViewGroup) view.getParent()).getHitRect(bounds); bounds.left = 0; bounds.top = 0; bounds.right = parent.getWidth(); bounds.bottom = parent.getHeight(); TouchDelegate touchDelegate = new FixTouchDelegate(bounds, view); parent.setTouchDelegate(touchDelegate); });} Example 地址https://github.com/l0neman/FixTouchDelegate 参考 https://developer.android.google.cn/training/gestures/scale?hl=zh-cn","link":"/2021/06/30/%E6%94%AF%E6%8C%81%E8%A7%A6%E6%91%B8%E6%8B%96%E5%8A%A8%E7%9A%84-touchdelegate/"},{"title":"Android View 事件分发机制","text":"触摸事件处理框架Android 的 View 和 ViewGroup 采用了 Composite(组合) 设计模式，View 的组合具有高度动态性，在这种情况下，由于触摸事件是从底层驱动传递至上层 View 对象，如果按照普通对象间传递信息的方式，将会很复杂，很难处理，这里 Android 采用了 Chain of Responsibility（责任链） 设计模式，触摸事件流将通过视图树，使每个 View 对象都有机会处理事件，一旦某个 View 选择接收事件流，那么整个事件将交给它处理，如果 View 选择不处理，那么事件流会继续传递，直到找到最后的处理者，在处理触摸事件时有几个重要的方法，在弄懂 Android 事件分发机制之前，需要先了解这几个方法的作用及关系。 核心方法 ViewGroup 的三个重载方法 boolean dispatchEvent(MotionEvent e) 当触摸事件传递给当前 View 或 ViewGroup 时，此方法将会被调用，它会负责事件的分发工作，可能会将事件交给自己的 onTouchEvent 方法或子View来处理，返回值为是否消耗事件 boolean onIntercepteEvent(MotionEvent e) 此方法将被 dispatchEvent 方法调用，返回的是是否拦截此次事件，如果返回 true，事件将被拦截，事件交给自己的 onTouchEvent 处理，子 view 将不能接收到事件，否则交给子view处理，但子 view 可以通过一个方法设置一个标记来阻止事件的拦截。 boolean onTouchEvent(MotionEvent e) 负责消耗触摸事件，一般在此处处理触摸事件，返回值为是否消耗事件，若不消耗事件，事件将不会再次被传递，而是交给上层 View 进行处理 View 中存在两个方法，作用和 ViewGroup 相似 boolean dispatchEvent(MotionEvent e) 作用和 ViewGroup 类似，由于 View 一定会处理事件，所以 View 不存在 onIntercepteEvent 这个方法，因此 dispatchEvent 最终会将事件交给 onTouchEvent 方法处理 boolean onTouchEvent(MotionEvent e) 与 ViewGroup 作用相同 调用关系上面介绍了每个方法的作用，下面用伪代码来描述他们的大致关系 123456789101112/* 事件交给 viewGroup 的 dispatchTouchEvent 进行处理 */public boolean dispatchTouchEvent(MotionEvent event) { boolean consume = false; if (onIntercepteEvent(event)) { /* 决定拦截，事件将交给自己处理 */ consume = onTouchEvent(event); } else { /* 否则交给子view或viewGroup继续分发事件 */ consume = touchTarget.dispatchTouchEvent(); } return consume;} 上面的伪代码将事件处理模型描述了出来，事件总体是按照这个方式处理的，但涉及到 DOWN，MOVE 等具体事件时还需要详细探讨 触摸事件流向上面介绍了触摸事件处理结构，下面介绍当一个触摸事件产生时，触摸事件的传递方向，当触摸屏幕产生触摸事件时，事件将会首先到达顶层 Activity 并交给它的 dispatchTouchEvent 方法来处理，虽然 Activity 不是 View，但它同样具有 dispatchTouchEvent和 onTouchEvent 方法，dispatchTouchEvent 会辗转调用顶层 View 的 dispatchTouchEvent 方法，并传递触摸事件，即开始按照上面伪代码描述的流程来传递事件，如果顶层 View 的 dispatchTouchEvent 返回 false 即事件没有被消耗，则会最终交给 Activity 自身的 onTouchEvent 方法处理 部分方法内部实现在遇到事件冲突问题时，通常需要在自定义的 ViewGroup 或 View 中重写部分事件处理方法改变部分原有规则。 Activity-dispatchTouchEvent可以看到 Activity 的 dispatchTouchEvent 的处理，就是之前所描述的 1234567891011public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } // Window 对象将会把事件传递给顶层 view(DecorView) if (getWindow().superDispatchTouchEvent(ev)) { return true; } // 否则交给自己 return onTouchEvent(ev); } View-dispatchTouchEventView 的 dispatchEventEvent 方法，当 OnTouchListener 未处理事件，事件将交给 onTouchEvent 处理。 123456789101112131415161718192021222324252627282930313233public boolean dispatchTouchEvent(MotionEvent event) { ... boolean result = false; if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { stopNestedScroll(); } if (onFilterTouchEventForSecurity(event)) { // 安全条件过滤后的事件 if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; // 处理滚动条 } // 如果 view 设置了 onTouchListener 并且它消耗了事件， // 那么view 的 onTouchEvent 方法将不会再回调 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) { stopNestedScroll(); } return result;} Viewgroup-onInterceptTouchEventViewGroup 的 onInterceptTouchEvent 的方法实现， 123456789public boolean onInterceptTouchEvent(MotionEvent ev) { if (ev.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) { return true; } return false;} 常用的几个布局，包括 LiearnLayout、RelativeLayout、FrameLayout，都没有重写 onInterceptTouchEvent 方法，使用的都是 ViewGroup 的实现，只有在手指或者鼠标触摸时返回 true 选择拦截事件，其他情况都返回 false，不拦截事件，事件将交给子 View 处理，当需要拦截事件交给 ViewGroup 处理的时候，可以重写这个方法，改变它默认的规则。 View-onTouchEventViewGroup 和 View 使用相同的 onTouchEvent 方法实现，可以看出 View 默认实现了点击事件的处理，对于设置了 DISABLE 属性的 view，如果设置了可点击，例如 CLICKABLE 或 LONGCLICKABLE 属性，则会消耗事件， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); // 当控件为 DISABLED 状态时，如果设置了点击属性，依然会消耗事件 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); } // 类似 onTouchListener if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } // 处理点击事件 if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) { switch (action) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { setPressed(true, x, y); } if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { removeLongPressCallback(); if (!focusTaken) { if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) { break; } boolean isInScrollingContainer = isInScrollingContainer(); if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { setPressed(true, x, y); checkForLongClick(0, x, y); } break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); if (!pointInView(x, y, mTouchSlop)) { removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { removeLongPressCallback(); setPressed(false); } } break; } return true; } return false;} ViewGroup-dispatchTouchEvent 分析上面是事件分发的流程和参与事件分发的部分方法实现，最后对 ViewGroup 的 dispatchTouchEvent 方法进行分析，它是事件分发机制的核心实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) { ev.setTargetAccessibilityFocus(false); } boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // ------------------------------------------------ part 1 /* 在 DOWN事件(事件序列开始) 发生时初始化 */ if (actionMasked == MotionEvent.ACTION_DOWN) { /* 清空 mFirstTouchTarget */ cancelAndClearTouchTargets(ev); /* 清空状态包括 FLAG_DISALLOW_INTERCEPT */ resetTouchState(); } final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { /* FLAG_DISALLOW_INTERCEPT 为子 View 设置的拦截标记 */ final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); } else { intercepted = false; } } else { intercepted = true; } // ------------------------------------------------ part 1 if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // ------------------------------------------------ part 2 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; /* 不是 CANCEL 事件且未拦截 */ if (!canceled &amp;&amp; !intercepted) { View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); /* 寻找可以处理事件子View */ final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } /* 子 View 不能接收事件（VISIBLE或动画执行中 或 事件坐标点未落在子 View 内 */ if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); /* 有子View处理了 DOWN 事件 */ if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); /* 添加到 TouchTarget 链表头部 */ newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { /* 没有找到处理事件的子View，赋值最近的子View(链表尾部) */ newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // ------------------------------------------------ part 2 // ------------------------------------------------ part 3 if (mFirstTouchTarget == null) { // TouchTarget 为空，事件交给自己 onTouchEvent handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // 将事件分发给 TouchTarget 链表 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; /* 如果上次 TouchTarget 处理了事件，而这次被拦截 ，则会分发 CANCEL 事件给子View */ if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { // 删除 TouchTarget if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // ------------------------------------------------ part 3 if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled;} 第一部分代码 当 DOWN 事件到来时，清空保存的状态，包括 mFirstTouchTarget 和 重置 FLAG_DISALLOW_INTERCEPT 标志位。 当 DOWN 事件到来时 或 mFisrtTouchTarget 不为空时，会调用 onInterceptTouchEvent 询问是否拦截事件，如果FLAG_DISALLOW_INTERCEPT 标志位被设置，则不会拦截事件。 从下一段代码可以获取到，mFisrtTouchTarget 代表是否有子View处理了事件，FLAG_DISALLOW_INTERCEPT 标志位可通过在子View 中调用父 ViewGroup 的 requestDisallowInterceptTouchEvent() 方法来设置 第二部分代码 如果 ViewGroup 未拦截事件，那么开始寻找可以处理事件的子View，即利用 dispatchTransformedTouchEvent 方法把事件分发给子 View，如果子 View 处理了，即子View的 dispatchTouchEvent 返回 true，那么将会调用 addTouchTarget 方法，将子View 加入 TouchTarget 链表中，其中 mFirstTouchTarget 作为链表的头结点，这时 mFirstTouchTarget 被赋值，下次事件，如果子 View 设置，FLAG_DISALLOW_INTERCEPT 标志，则可以阻止 ViewGroup 拦截事件。 在 dispatchTransformedTouchEvent 方法中，如果 child 参数不为空，就会调用子 View 的 dispatchTouchEvent 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; /* 分发 CANCEL 事件 */ final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } /* 分发事件 child 为 null，则交给自己处理 */ final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; if (newPointerIdBits == 0) { return false; } final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } ...} 第三部分代码则是将事件分发给子 View，如果没有子 View 处理事件，那么交给自己处理，其中如果子 View 处理过事件，但是下次被父 ViewGroup 拦截了，那么 TouchTarget 当前处理事件的这个子 View 节点将被删除，本次会给子 View 分发 CANCEL 事件。 从以上代码分析可得出一些结论； 如果 ViewGroup 在 DOWN事件 时拦截了事件，那么子 View 再也无法拦截事件，因为 actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null 这个条件不会再次被满足。 如果在 DOWN事件 时被设置 FLAG_DISALLOW_INTERCEPT，则可以阻止 ViewGroup 拦截事件。 编码验证现在在代码中通过一些用例对上面的分析即结论进行验证。 首先新建一个Activity，再实现它的 onTouchEvent 方法，并打印日志，日志使用了 Logger 开源库，日志更直观一些。 123456789101112131415@Overridepublic boolean onTouchEvent(MotionEvent event) { switch (event.getActionMasked()) { case MotionEvent.ACTION_DOWN: Logger.d(&quot;activity consume down&quot;); return true; case MotionEvent.ACTION_MOVE: Logger.d(&quot;activity consume move&quot;); return true; case MotionEvent.ACTION_UP: Logger.d(&quot;activity consume up&quot;); return true; } return super.onTouchEvent(event);} 然后在 Activity 布局中加入自定义的 ViewGroup TouchParent， 内部只重写了 onIntercepTouchEvent 和 onTouchEvent 方法。 123456789101112131415161718192021222324252627282930@Override public boolean onInterceptTouchEvent(MotionEvent ev) { final int eventMasked = ev.getActionMasked(); switch (eventMasked) { case MotionEvent.ACTION_DOWN: return false; case MotionEvent.ACTION_MOVE: return false; case MotionEvent.ACTION_UP: return false; } return super.onInterceptTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent event) { final int eventMasked = event.getActionMasked(); switch (eventMasked) { case MotionEvent.ACTION_DOWN: Logger.d(&quot;parent consume down&quot;); return false; case MotionEvent.ACTION_MOVE: Logger.d(&quot;parent consume move&quot;); return true; case MotionEvent.ACTION_UP: Logger.d(&quot;parent consume up&quot;); return true; } return super.onTouchEvent(event); } 上面的 TouchParent 里面包含了一个自定义的 View TouchChild，它只重写了 onTouchEvent 方法 12345678910111213141516@Overridepublic boolean onTouchEvent(MotionEvent event) { final int eventMasked = event.getActionMasked(); switch (eventMasked) { case MotionEvent.ACTION_DOWN: Logger.d(&quot;child consume down&quot;); return true; case MotionEvent.ACTION_MOVE: Logger.d(&quot;child consume move&quot;); return true; case MotionEvent.ACTION_UP: Logger.d(&quot;child consume up&quot;); return true; } return super.onTouchEvent(event);} 好，现在上面都是默认情况，TouchParent 和 TouchChild 都默认处理所有事件，开始测试，现在用手指在 TouchChild 的绿色区域的位置向 TouchParent 的白色区域滑动并抬起手指，如下图 正常情况，TouchParent不拦截事件，那么TouchChild会处理所有事件，结果如下： 现在把 TouchParent 的 onIntercepTouchEvent 方法改一下，让它“只拦截” DOWN 事件，试试 123456789switch (eventMasked) { case MotionEvent.ACTION_DOWN: return true; case MotionEvent.ACTION_MOVE: return false; case MotionEvent.ACTION_UP: return false;} 结果是： 所以为什么是引号呢，这就验证了前面的，当 ViewGroup 决定拦截 DOWN 时，那么所有的事件都会交给它来处理，不会是表面上的只拦截DOWN事件，onInterceptTouchEvent 也将不会再被调用。 在 2 的基础上，把 TouchParent 的 onTouchEvent 的 MOVE 事件改成返回 false，不处理 MOVE 事件看看会怎样 123456@Override public boolean onTouchEvent(MotionEvent event) { case MotionEvent.ACTION_MOVE: // Logger.d(&quot;parent consume move&quot;); return false; ...} 其中 MOVE 事件由于 TouchParent 没有处理，最终交给了 Activity 处理 现在把 TouchParent 里的 onInterceptTouchEvent 方法改为 DOWN 事件不拦截，MOVE 和 UP 事件拦截 12345678910111213@Override public boolean onInterceptTouchEvent(MotionEvent ev) { final int eventMasked = ev.getActionMasked(); switch (eventMasked) { case MotionEvent.ACTION_DOWN: return false; case MotionEvent.ACTION_MOVE: return true; case MotionEvent.ACTION_UP: return true; } return super.onInterceptTouchEvent(ev); } 然后把 TouchChild 里的 onTouchEvent 方法，在 DOWN 中调用 getParent().requestDisallowInterceptTouchEvent(true); 即，阻止 TouchParent 的事件拦截，测试一下： 可以看到，事件完全被TouchChild处理了，因为 TouchChild 使用 requestDisallowInterceptTouchEvent 阻止了 TouchParent 的拦截，不过如果 TouchParent在down 事件里选择拦截的话，那么 TouchChild 将无法进行拦截，这里要注意的是 requestDisallowInterceptTouchEvent 是在 onTouchEvent 里调用的，推荐在 dispatchTouchEvent 方法里进行过拦截，dispatchTouchEvent 是必然会接受到事件的，而 onTouchEvent 可能受到 OnTouchListener 的影响而不被调用。 现在再在4的基础上在 TouchChild 里面的 onTouchEvent 里 MOVE 事件里调用 getParent().requestDisallowInterceptTouchEvent(false); 把事件还给TouchParent会怎样 这里多做了一次 MOVE 事件，为了看的更清楚，当 TouchChild 在 DOWN 事件里阻拦了 TouchParent 的时候，TouchChild 将会处理下一个 MOVE，在这里TouchChild有把事件交还给 TouchParent，这时 TouchParent 拦截了MOVE 事件，事件将会交给 TouchParent 来处理，但是很奇怪为什么会下一个 MOVE 会被 Activity 处理呢，然后才是 TouchParent 处理 MOVE，因为从前面的结论可以知道，上次是 TouchChild 处理的事件，这次被拦截的话，此次的事件将会变成一个 CANCEL 事件并分发给子 view，这里 TouchChild 没有处理 CANCEL 事件，所以最终交给了 Activity 处理，现在让 TouchChild 处理 CANCEL 123456789@Overridepublic boolean onTouchEvent(MotionEvent event) { //... case MotionEvent.ACTION_CANCEL: Logger.d(&quot;child consume cancel&quot;); return true; } return super.onTouchEvent(event);} 好了，事件确实是 CANCEL 事件，这次被 TouchChild 消耗了，Activity 就不会处理了 以上测试了几个典型例子，对结论进行了论证，下面是Android事件分发机制在处理事件冲突时的应用。 触摸事件冲突处理一般在项目中可能会遇到界面比较复杂的情况，而且可能是可滑动的布局相互嵌套的情况，比如，ScrollView 里面有一个 ListView，两个 view 都是纵向划动的，一定会有冲突，还有 ViewPager 里面有 ScrollView，或 ScrollView 里面有 ViewPager，这两个是横向和纵向划动的冲突，这种情况可能与用户体验相关，应该根据滑动的动作来决定事件交给哪个 View 来处理，为了解决这个问题，就需要对事件分发机制有所熟悉。 ​ 例如或 ScrollView 里面有 ViewPager 这种情况，当用户偏向横划的时候，相应的 ViewPager 就要做出内容的偏移，当用户偏向竖划的时后，ScrollView 就要滚动里面的内容，针对这种情况，就产生了一个判断条件，就是用户横向或纵向划动，转化为逻辑就是，MOVE 事件时 x 和 y 轴 滑动距离相比较，伪代码如下： 12345if (x &gt; y /*横向滑动*/) { // ViewPager滚动} else /*纵向滑动*/{ // ScrollView滚动} 那就是说，x &gt; y 时，ViewPager会拦截 ScrollView 的事件，自己来处理，否则 ScrollView 拦截 ViewPager 的事件，自己来处理 针对此情况，一般有两种拦截的方法，也就是触摸事件冲突处理的方法。 外部拦截法外部拦截法以嵌套布局外层 ViewGroup 为主，重写 onInterceptTouchEvent 方法，事件是否拦截，完全由 ViewGroup 决定。 12345678910111213141516171819202122public void onInterceptTouch(MotionEvent ev){ /*是否拦截*/ boolean intercepted = false; switch(event.getAction()){ case MotionEvent.ACTION_DOWN: /*不拦截Down事件*/ intercepted = false; break; case MotionEvent.ACTION_MOVE: if(父容器自身需要此事件){ intercepted = true; }else{ intercepted = false; } break; case MotionEvent.ACTION_UP: /*不拦截Up事件,没有意义*/ intercepted = false; break; } return intercepted;} 这种方法的事件决定权完全在外部 ViewGroup 上，其中为什么不拦截 DOWN 事件呢，因为一旦拦截，那么事件就一定会给自己处理了，子 View 就没有选择的余地了。 内部拦截法内部拦截法以嵌套布局内层 View 为主，主要重写子 View 的 dispatchTouchEvent 方法，这种方法需要 ViewGroup 不拦截 DOWN 事件，然后通过调用 ViewGroup 的 requestDisallowInterceptTouchEvent 来控制事件传递。 1234567891011121314151617/*子View*/public void dispatchTouchEvent(MotionEvent ev){ switch(event.getAction()){ case MotionEvent.ACTION_DOWN: /*使父View不再调用事件拦截*/ parent.requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: if(/*还给父view事件*/){ parent.requestDisallowInterceptTouchEvent(false); } break; case MotionEvent.ACTION_UP: break; } return super.dispatchTouchEvent(event);} 其实在 ScrollView 里面有 ViewPager 这种情况，源码里已经了处理，所以用的时候没有任何问题，下面截取了 ViewPager 的 onInterceptTouchEvent 的部分源码 12345678910111213141516171819202122232425262728case MotionEvent.ACTION_DOWN: { /* * Remember location of down touch. * ACTION_DOWN always refers to pointer index 0. */ mLastMotionX = mInitialMotionX = ev.getX(); mLastMotionY = mInitialMotionY = ev.getY(); mActivePointerId = ev.getPointerId(0); mIsUnableToDrag = false; mIsScrollStarted = true; mScroller.computeScrollOffset(); if (mScrollState == SCROLL_STATE_SETTLING &amp;&amp; Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) &gt; mCloseEnough) { // Let the user 'catch' the pager as it animates. mScroller.abortAnimation(); mPopulatePending = false; populate(); mIsBeingDragged = true; requestParentDisallowInterceptTouchEvent(true); setScrollState(SCROLL_STATE_DRAGGING); } else { completeScroll(false); mIsBeingDragged = false; } // ... break;} 会发现在 DOWN 事件中有一个 requestParentDisallowInterceptTouchEvent(true)，这里就是拦截外层 View 使用的内部拦截法。 123456private void requestParentDisallowInterceptTouchEvent(boolean disallowIntercept) { final ViewParent parent = getParent(); if (parent != null) { parent.requestDisallowInterceptTouchEvent(disallowIntercept); }} 在实际运用中，需要对于情况来选择合适的方法。 事件冲突处理实例这里假设一种情况，ScrollView 里面有一个 ListView，这两个 View 嵌套一定会出现问题，首先正常的在 Activity 里面放上一个 ScrollView 然后在里面放上一个 ListView，其中 ScrollView 是可以滚动的，ListView 高度限制为 200dp，内部子元素有 20 个，代码很简单，核心部分如下： 1234567891011121314151617181920212223242526272829303132ListView listView = (ListView)findViewById(R.id.lv_content);listView.setAdapter( new BaseAdapter() { @Override public int getCount() { return 20; } @Override public Object getItem(int position) { return null; } @Override public long getItemId(int position) { return position; } @Override public View getView(int position, View convertView, ViewGroup parent) { if (convertView == null) { TextView textView = new TextView(parent.getContext()); textView.setLayoutParams(new AbsListView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT )); textView.setTextSize(45); textView.setTextColor(Color.WHITE); textView.setGravity(Gravity.CENTER); textView.setText(&quot;item&quot; + position); convertView = textView; } else { ((TextView)convertView).setText(&quot;item&quot; + position); } return convertView; } }); 运行一下 会发现 ListView 根本无法滑动，肯定是 MOVE 事件完全被 ScrollView 拦截了，导致 ListView 接收不到事件，也就无法响应滑动，DOWN事件一般是不会被 ScrollView 拦截的，现在就想办法让 ListView 滑动，解决它们的冲突 首先需要一个条件，就是什么时候让 ListView 滑动，什么时候再把事件交还给 ScrollView，让它继续滑动，那么现在条件是这样，当手指落在 ListView 上并移动时，ListView 完全处理 MOVE 事件，当 ListView 达到底部的极限时且手指继续向上滑动 或 当 ListView 达到顶部的极限时且手指继续向下滑动把事件交给 ScrollView 处理，针对这个条件，发现决定事件的主要是 ListView，那么这里采用内部拦截法，重写 ListView 的事件处理方法，下面是完整代码和实现效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public final class TouchListView extends ListView { public TouchListView(Context context) { super(context); } public TouchListView(Context context, AttributeSet attrs) { super(context, attrs); } public TouchListView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } private int mLastY; @Override public boolean dispatchTouchEvent(MotionEvent ev) { final int eventMasked = ev.getActionMasked(); final int y = (int) ev.getY(); switch (eventMasked) { case MotionEvent.ACTION_DOWN: mLastY = y; // 拦截事件 getParent().requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: if (y &lt; mLastY &amp;&amp; checkScrollBottomLimit(this)) { // 当ListView达到底部的极限时且手指继续向上滑动，释放事件 getParent().requestDisallowInterceptTouchEvent(false); } else if (y &gt; mLastY &amp;&amp; checkScrollTopLimit(this)) { // 当ListView达到顶部的极限时且手指继续向下滑动，释放事件 getParent().requestDisallowInterceptTouchEvent(false); } mLastY = y; break; case MotionEvent.ACTION_UP: break; } return super.dispatchTouchEvent(ev); } /** * 判断ListView是否滚动到了底部 * * @param listView target * @return 滚动到了底部返回true，否则false */ private boolean checkScrollBottomLimit(ListView listView) { if (listView.getLastVisiblePosition() == listView.getCount() - 1) { final View lastChild = listView.getChildAt( listView.getChildCount() - 1); int lastChildBottom = listView.getTop() + lastChild.getBottom(); if (lastChildBottom == listView.getBottom()) { return true; } } return false; } /** * 判断ListView是否滚动到了顶部 * * @param listView target * @return 滚动到了顶部返回true，否则false */ private boolean checkScrollTopLimit(ListView listView) { if (listView.getFirstVisiblePosition() == 0) { final View lastChild = listView.getChildAt(0); if (lastChild.getTop() == 0) { return true; } } return false; }} 感觉有点别扭，例如当 ListView 达到底部的极限时且手指继续向上滑动，释放事件，ScrollView 继续滚动，但是要再向下滑动时，手指还在ListView上，按自然滑动的规则 ListView 内容应该向下滚动，但这时事件还是 ScrollView 在处理，所以它会跟着手一起滚动，这里可以用另一种比较麻烦的方法，将事件直接通过 ListView 的对象，调用它的 onTouchEvent 传递过去，这个问题先留下来。","link":"/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"title":"Android 坐标系和 View 滑动方法","text":"Android 二维坐标系和 Java 图形化界面开发类似，Android 中也有一种坐标系，这里说说二维平面的坐标系，在 Android 中，坐标系起始点以左上角为原点，竖直向下是 y 轴的方向，横向向右是 x 轴延伸方向，对于 Android 中的 View 来说，它本身所具有的一些位置相关的参数会根据这个坐标系来确定数值和正负，掌握这些有助于理解 View 在布局层次中所处位置的意义。 下面用一个典型例子来说明 Android 中的坐标系： 上图中的布局包含两个 View，一个是外层的 parent view 和内部的一个 child view，其中 parent view 设置了 padding=&quot;16dp&quot; 的属性，child view 设置了 layout_margin=&quot;16dp&quot; 的属性，为了更明显的表现布局的，其中绿色区域表示 parent view 设置 padding 后绘制子 View 的区域，灰色区域表示 child view 设置 margin 值后所占的空间。 123456789101112131415161718192021&lt;!-- parent view --&gt;&lt;com.runing.corrdinateandscroll.ScrollerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/fl_parent&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;240dp&quot; android:background=&quot;@color/colorPrimary&quot; android:padding=&quot;16dp&quot; tools:context=&quot;com.runing.corrdinateandscroll.MainActivity&quot;&gt;2&lt;!-- child view --&gt; &lt;ImageView android:id=&quot;@+id/iv_target&quot; android:layout_width=&quot;120dp&quot; android:layout_height=&quot;120dp&quot; android:layout_margin=&quot;16dp&quot; android:contentDescription=&quot;@string/app_name&quot; android:src=&quot;@drawable/img0&quot;/&gt;&lt;/com.runing.corrdinateandscroll.ScrollerLayout&gt; 下面分主要从和几个角度分析和 child view 相关的坐标参数 Parent View下面两个方法都是对 child view 调用的，他们返回的是两个重要位置参数的值，mScrollX 和 mScrollY getScrollX 返回相对于 View 左边缘 x 轴滑动的偏移量，它会影响 View 内容的绘制位置，如果向右偏移，返回的都是负值，反之返回正值，下面会细说它的含义。 getScrollY 返回相对于 View 上边缘 y 轴滑动的偏移量，如果向下偏移，返回的都是负值，反之返回正值。 Motion Event现在假设在 child view 上发生一个触摸事件，下面的这些方法将会从 child view 的 onTouchEvent(MotionEvent event) 或者 onTouchListener 的 onTouch(MotionEvent event) 方法中的 event 对象中获取值。 getRawX 触摸事件发生点相对屏幕左边缘的 x 轴偏移，因为触点一定会在屏幕内，所以一直是正值。 getRawY 触摸事件发生点相对屏幕上边缘的 y 轴偏移，同上一直会是正值。 getX child view 触摸事件发生点相对自身左边缘的 x 轴偏移，如果触点在自身左边缘的左边，值会为负。 getY child view 触摸事件发生点相对自身上边缘的 y 轴偏移，如果触点在自身上边缘的上面，值会为负。 Child View下图是一个 View 调用 setTranslation 的方法使 View 发生偏移前后的两个 View 的位置。 下以的方法均是针对 child view 来说的。 getLeft child view 左边缘距离 parent view 左边缘的 x 轴偏移量，相对于 parent view 右边时为正数。由图上看出，getLeft 的值会受到 parent view 的 padding 和 child view 自身的 layout_margin 属性的影响。 getTop child view 上边缘距离 parent view 上边缘的 y 轴偏移量，相对于 parent view 偏下时为正数，getTop 的值会受到 parent view 的 padding 和 child view 自身的 layout_margin 属性的影响。 getRight child view 右边缘距离 parent view 左边缘的 x 轴偏移量，即 getLeft 加view自身宽度。 getBottom child view 下边缘距离 parent view 上边缘的 y 轴偏移量，即 getRight 加view自身高度。 getTranslationX child view 相于自身 getLeft 向右的 x 轴偏移量，改变这个值不会改变 getLeft 的值。 getTranslationY child view 相于自身 getTop 向下的 y 轴偏移量，改变这个值不会改变 getTop 的值。 getX child view 发生 translationX 平移后的自身左边缘距离 parent view 左边缘的 x 轴偏移，即 getLeft + getTranslationX 。 getY child view 发生 translationY 平移后的自身左边缘距离 parent view 左边缘的 y 轴偏移，即 getTop + getTranslationY 。 上面只是简单列举了 Android 中与 View 中坐标相关的一些属性，下面将介绍 View 滑动的几种方法，了解上面这些有助于理解 View 滑动的一些原理，下面将会把这些知识融入到 View 滑动的实例中去。 View 滑动方法下面通过一个实例的实现来介绍 5 种 View 的滑动方法，并用这些方法实现相同需求的 View 滑动示例。 拖拽滑动实例首先确定实例需求，基于上面的条件来确定一些需求，并依次递进实现每一个需求： 一个 ViewGroup 中放置一个 ImageView 其中可以使用手指触摸和拖动其中的ImageView，并让其跟随触摸点自由移动。 在拖动过程中需要保证ImageView只能在ViewGroup的范围内滑动，并保持ViewGroup设置的 padding 属性和ImageView设置的 layout_margin 属性依然有效。 模拟悬浮窗的横向吸附效果，当松手时，如果ImageView偏左，则ImageView会平滑吸附到ViewGroup的左边缘，反之吸附到右边缘。 针对以上需求，使用以下 5 种方法一一实现，其中第 4 个需求属于弹性滑动也就是平滑滚动，这里先实现上面 3 种需求。 现在在外部对 ImageView 设置 OnTouchListener 来监听它的触摸事件，使用两个变量来标记手指按下的坐标，在手指移动时即可计算平移的偏移量，注意 onTouch 返回 true 来消耗事件，其中计算的偏移量将作为滑动的基础数值，对于每种滑动都会针对这个偏移值进行处理。 12345678910111213141516171819202122private int mLastX;private int mLastY;mTarget.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { final int x = (int) event.getX(); final int y = (int) event.getY(); switch (event.getActionMasked()) { case MotionEvent.ACTION_DOWN: /* 手指按下的坐标 */ mLastX = x; mLastY = y; break; case MotionEvent.ACTION_MOVE: /* 偏移量 */ int xOffset = x - mLastX; int yOffset = y - mLastY; break; } return true; } }); Translation使用 View 的 setTranslationX 和 setTranslationY 方法可直接使 View 发生平移，所以让 View 根据偏移滑动可以这样写，其中累加 getTranslation 的结果是为了基于当前位置滑动，而不是从头开始： 1234private void scrollByOffset(int xOffset, int yOffset) { mTarget.setTranslationX(mTarget.getTranslationX() + xOffset); mTarget.setTranslationY(mTarget.getTranslationY() + yOffset);} 这样 View 就会跟随手指滑动了，接下来开始限制 View 滑动范围，逻辑就是先计算出 translation 在 x 轴和 y 轴的滑动上限和下限，再判断新的 translation 位置否超出限制，如果超出限制，则重新设置原始偏移值在范围内。 这里由于初始位置的 translationX 和 translationY 都为 0，则他们的下限就是 0 12final int transXLowerLimit = 0;final int transYLowerLimit = 0; 假设 View 已经通过 translation 滑动到右下角边缘，现在可以计算出上限了。 从图上简单分析，很容易就能计算了： 123// 其中P = Padding，M = Margin，W = width，H = heightfinal int transXUpperLimit = mParentW - mTargetW - mParentPL - mParentPR - mTargetML - mTargetMR;final int transYUpperLimit = mParentH - mTargetH - mParentPT - mParentPB - mTargetMT - mTargetMB; 那么根据这四个变量值即可限制 translation 的变化，下面是完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 使用 translation 的方法进行滑动 */private void startScrollWithTranslation() { mTarget.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { final int x = (int) event.getX(); final int y = (int) event.getY(); switch (event.getActionMasked()) { case MotionEvent.ACTION_DOWN: stopAllAnimAndThread(); mLastX = x; mLastY = y; break; case MotionEvent.ACTION_MOVE: int xOffset = x - mLastX; int yOffset = y - mLastY; final int oldTransX = (int) mTarget.getTranslationX(); final int newTransX = oldTransX + xOffset; final int transXLowerLimit = 0; if (newTransX &lt; transXLowerLimit) { /* 重新设置偏移量，使其在范围内滚动，下同 */ xOffset = transXLowerLimit - oldTransX; } final int transXUpperLimit = mParentW - mTargetW - mParentPL - mParentPR - mTargetML - mTargetMR; if (newTransX &gt; transXUpperLimit) { xOffset = transXUpperLimit - oldTransX; } final int oldTransY = (int) mTarget.getTranslationY(); final int newTransY = oldTransY + yOffset; final int transYLowerLimit = 0; if (newTransY &lt; transYLowerLimit) { yOffset = transYLowerLimit - oldTransY; } final int transYUpperLimit = mParentH - mTargetH - mParentPT - mParentPB - mTargetMT - mTargetMB; if (newTransY &gt; transYUpperLimit) { yOffset = transYUpperLimit - oldTransY; } scrollByOffset(xOffset, yOffset); break; } return true; } });} 这样就完成了第一种方法了。 Scroll ToscrollTo 和 scrollBy 可以对 View 的绘制内容进行滑动，实质上是对 Canvas 绘制区域的滚动。下面是 View 的 draw(Canvas canvas) 的部分源码，可以体现 scrollTo 方法对绘制的影响。 123456789101112131415161718192021/* mScrollX影响left的取值 */int left = mScrollX + paddingLeft;int right = left + mRight - mLeft - mPaddingRight - paddingLeft;int top = mScrollY + getFadeTop(offsetRequired);int bottom = top + getFadeHeight(offsetRequired);...if (solidColor == 0) { final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) { canvas.saveLayer(left, top, right, top + length, null, flags); } ...}...if (drawTop) { matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p);} 其中的 mScrollX 和 mScrollY 的值，会受到 scrollTo 的影响而发生改变 1234567891011121314151617181920/** * Set the scrolled position of your view. This will cause a call to * {@link #onScrollChanged(int, int, int, int)} and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */public void scrollTo(int x, int y) { if (mScrollX != x || mScrollY != y) { int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) { postInvalidateOnAnimation(); } }} scollBy 帮我们处理了相对当前位置滑动的问题。 12345678910/** * Move the scrolled position of your view. This will cause a call to * {@link #onScrollChanged(int, int, int, int)} and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y);} 这里需要让 ImageView 滑动，就是调用 parent view 的 scrollBy 方法，来进行内容的滑动，但是有一个弊端是，parent view内部的所有子 View 都会滑动，这里只不过这里只有一个 child view，而且 scrollTo 并不只限制于ViewGroup，还可以对View进行内容的滑动，比如ImageView中可对内部的图片进行滑动，如果扩展一下，就可以做出一个图片浏览控件。 下面根据之前 translation 的套路，还是先实现自由滚动，上代码： 123private void scrollByOffset(int xOffset, int yOffset) { mParent.scrollBy(-xOffset, -yOffset);} 由于 scroll 和坐标系方向是相反的，所以这里为负值。接下来计算上限和下限。 下限默认是 0，上限也和之前 translation 的计算结果是相同的。 1234final int scrollXLowerLimit = 0;final int scrollYLowerLimit = 0;final int scrollXUpperLimit = mParentW - mTargetW - mParentPL - mParentPR - mTargetML - mTargetMR;final int scrollYUpperLimit = mParentH - mTargetH - mParentPT - mParentPB - mTargetMT - mTargetMB; 得到最终偏移值的完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 使用 scroll to 的方法进行滑动 */private void startScrollWithScrollTo() { mTarget.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { final int x = (int) event.getX(); final int y = (int) event.getY(); switch (event.getActionMasked()) { case MotionEvent.ACTION_DOWN: mLastX = x; mLastY = y; break; case MotionEvent.ACTION_MOVE: int xOffset = x - mLastX; int yOffset = y - mLastY; final int oldScrollX = -mParent.getScrollX(); final int newScrollX = oldScrollX + xOffset; final int scrollXLowerLimit = 0; if (newScrollX &lt; scrollXLowerLimit) { xOffset = scrollXLowerLimit - oldScrollX; } final int scrollXUpperLimit = mParentW - mTargetW - mParentPL - mParentPR - mTargetML - mTargetMR; if (newScrollX &gt; scrollXUpperLimit) { xOffset = scrollXUpperLimit - oldScrollX; } final int oldScrollY = -mParent.getScrollY(); final int newScrollY = oldScrollY + yOffset; final int scrollYLowerLimit = 0; if (newScrollY &lt; scrollXLowerLimit) { yOffset = scrollYLowerLimit - oldScrollY; } final int scrollYUpperLimit = mParentH - mTargetH - mParentPT - mParentPB - mTargetMT - mTargetMB; if (newScrollY &gt; scrollYUpperLimit) { yOffset = scrollYUpperLimit - oldScrollY; } scrollByOffset(xOffset, yOffset); break; } return true; } });} Layout Fun使用 layout 方法对目标 View 进行重新布局，也可以做到对 View 的滑动，那么对于针对偏移的滑动就可以这样写： 1234private void scrollByOffset(int xOffset, int yOffset) { mTarget.layout(mTarget.getLeft() + xOffset, mTarget.getTop() + yOffset, mTarget.getRight() + xOffset, mTarget.getBottom() + yOffset);} 注意这种方法只是在滑动时临时改变 View 的 mLeft,mRight,mTop,mBottom 属性，如果 View 重新调用 requesstLayout 方法请求布局的重绘，View 将会重新回到初始位置，可以提前保存 View 的位置。 接下来是计算 layout 绘制的上下限： 可以看出，View 的 getLeft 是有初始值的，同理 getTop 也是一样，那么这就是它们的下限。 123/* 原始left值，也可以在前面直接保存getLeft值，这里重新计算了left值 */final int leftLowerLimit = mParentPL + mTargetML;final int topLowerLimit = mParentPT + mTargetMT; 那么上限就是： 12final int leftUpperLimit = mParentW - mTargetW - mParentPR - mTargetMR;final int topUpperLimit = mParentH - mTargetH - mParentPB - mTargetMB; 由此可以限制偏移值了，完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 使用 layout 方法进行滑动 */private void startScrollWithOffsetFun() { mTarget.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { final int x = (int) event.getX(); final int y = (int) event.getY(); switch (event.getActionMasked()) { case MotionEvent.ACTION_DOWN: stopAllAnimAndThread(); mLastX = x; mLastY = y; break; case MotionEvent.ACTION_MOVE: int xOffset = x - mLastX; int yOffset = y - mLastY; final int oldLeft = mTarget.getLeft(); final int newLeft = oldLeft + xOffset; final int leftLowerLimit = mParentPL + mTargetML; if (newLeft &lt; leftLowerLimit) { xOffset = leftLowerLimit - oldLeft; } final int leftUpperLimit = mParentW - mTargetW - mParentPR - mTargetMR; if (newLeft &gt; leftUpperLimit) { xOffset = leftUpperLimit - oldLeft; } final int oldTop = mTarget.getTop(); final int newTop = oldTop + yOffset; final int topLowerLimit = mParentPT + mTargetMT; if (newTop &lt; topLowerLimit) { yOffset = topLowerLimit - oldTop; } final int topUpperLimit = mParentH - mTargetH - mParentPB - mTargetMB; if (newTop &gt; topUpperLimit) { yOffset = topUpperLimit - oldTop; } scrollByOffset(xOffset, yOffset); break; } return true; } });} offsetXXAndXX使用 offsetLeftAndRight 和 offsetTopAndBottom 两种方法可以直接对 View 进行滑动，使用这两种方法和 layout 相同，只不过更方便一些，直接传入偏移值即可使 View 滑动，经过测试，它和调用 layout 方法所照成的影响一致，都会使 mLeft,mRight,mTop,mBottom 发生变化，当 View 调用 requestLayout 后，View 依然会回到原始位置。 那么直接就直接使用吧： 12mTarget.offsetLeftAndRight(xOffset);mTarget.offsetTopAndBottom(yOffset); 既然和 layout 方法一样，那么对边界限制的代码也是一模一样，这里就不用写了，和 layout 是一样的。 在 Android 中存在一个 View 拖动的辅助类 ViewDragHelper ，使用它可以很方便的对 View 进行拖拽和边界限制，这里就不说了，其内部滑动就是调用了 offsetXXAndXX 系列方法，下面是它内部的一个方法： 123456789101112131415161718192021private void dragTo(int left, int top, int dx, int dy) { int clampedX = left; int clampedY = top; final int oldLeft = mCapturedView.getLeft(); final int oldTop = mCapturedView.getTop(); if (dx != 0) { clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx); ViewCompat.offsetLeftAndRight(mCapturedView, clampedX - oldLeft); } if (dy != 0) { clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy); ViewCompat.offsetTopAndBottom(mCapturedView, clampedY - oldTop); } if (dx != 0 || dy != 0) { final int clampedDx = clampedX - oldLeft; final int clampedDy = clampedY - oldTop; mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY, clampedDx, clampedDy); }} Layout Params使用 LayoutParams 就有很灵活了，它是作为 View 的布局参数映射类而存在的，最先想到的就的是动态更改 View 设置的 layout_margin 属性，即可做到 View 位置的更改，也就能控制 View 的滑动了，不过必须在支持 layout_margin 的父布局中才可以使用，相对于父布局来说，只要是支持 View 位置的属性，都可以拿来用，并不限制于 layout_margin 参数。 下面，我们在 FrameLayout 里面进行滑动，那么可以这样来： 123456private void scrollByOffset(int xOffset, int yOffset) { FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) mTarget.getLayoutParams(); params.leftMargin += xOffset; params.topMargin += yOffset; mTarget.setLayoutParams(params);} 处理上下限也很好弄了。 下限不用说，就是 marginLeft 和 marginTop 的初始值： 12final int marginLeftLowerLimit = mTargetML;final int marginTopLowerLimit = mTargetMT; 上限从图上分析也很容易计算： 12final int marginLeftUpperLimit = mParentW - mTargetW - mParentPL - mParentPR - mTargetMR;final int marginTopUpperLimit = mParentH - mTargetH - mParentPT - mParentPB - mTargetMB; 那么完整的就是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 使用 layout params 的方法进行滑动 */private void startScrollWithLayoutParams() { mTarget.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { final int x = (int) event.getX(); final int y = (int) event.getY(); switch (event.getActionMasked()) { case MotionEvent.ACTION_DOWN: stopAllAnimAndThread(); mLastX = x; mLastY = y; break; case MotionEvent.ACTION_MOVE: int xOffset = x - mLastX; int yOffset = y - mLastY; FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) mTarget.getLayoutParams(); final int oldMarginLeft = params.leftMargin; final int newMarginLeft = oldMarginLeft + xOffset; final int marginLeftLowerLimit = mTargetML; if (newMarginLeft &lt; marginLeftLowerLimit) { xOffset = marginLeftLowerLimit - oldMarginLeft; } final int marginLeftUpperLimit = mParentW - mTargetW - mParentPL - mParentPR - mTargetMR; if (newMarginLeft &gt; marginLeftUpperLimit) { xOffset = marginLeftUpperLimit - oldMarginLeft; } final int oldMarginTop = params.topMargin; final int newMarginTop = oldMarginTop + yOffset; final int marginTopLowerLimit = mTargetMT; if (newMarginTop &lt; marginLeftLowerLimit) { yOffset = marginTopLowerLimit - oldMarginTop; } final int marginTopUpperLimit = mParentH - mTargetH - mParentPT - mParentPB - mTargetMB; if (newMarginTop &gt; marginTopUpperLimit) { yOffset = marginTopUpperLimit - oldMarginTop; } scrollByOffset(xOffset, yOffset); break; } return true; } });} 那么最终就可以达到这样的效果： 其中的信息输出是一个 Toast ，可以在 move 事件中加入。 1234567...case MotionEvent.ACTION_MOVE: ... scrollByOffset(xOffset, yOffset); /* 打印滑动时的view信息 */ printViewInfo(event, xOffset, yOffset); break; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 在屏幕打印坐标信息 * * @param event 触摸事件 * @param xOffset x轴偏移 * @param yOffset y轴偏移 */ private void printViewInfo(MotionEvent event, final int xOffset, final int yOffset) { T.show( getOutPutString( mParent.getScrollX(), mParent.getScrollY(), (int) event.getX(), (int) event.getY(), (int) event.getRawX(), (int) event.getRawY(), xOffset, yOffset, mTarget.getWidth(), mTarget.getHeight(), (int) mTarget.getX(), (int) mTarget.getY(), mTarget.getScrollX(), mTarget.getScrollY(), (int) mTarget.getTranslationX(), (int) mTarget.getTranslationY(), mTarget.getLeft(), mTarget.getRight(), mTarget.getTop(), mTarget.getBottom() ) ); } /** * 获取格式化的坐标信息字符串 * * @param pScrollX parent view getScrollX * @param pScrollY parent view getScrollY * @param mGetX motion event getX * @param mGetY motion event getY * @param mGetRawX motion event getRawX * @param mGetRawY motion event getRawY * @param mOffsetX x轴偏移 * @param mOffsetY y轴偏移 * @param tWidth target view width * @param tHeight target view height * @param tGetX target view getX * @param tGetY target view getY * @param tScrollX target view getScrollX * @param tScrollY target view getScrollY * @param tTranslationX target view getTranslationX * @param tTranslationY target view getTranslationY * @param tLeft target view getLeft * @param tRight target view getRight * @param tTop target view getTop * @param tBottom target view getBottom * @return result string */ private static String getOutPutString(int pScrollX, int pScrollY, int mGetX, int mGetY, int mGetRawX, int mGetRawY, int mOffsetX, int mOffsetY, int tWidth, int tHeight, int tGetX, int tGetY, int tScrollX, int tScrollY, int tTranslationX, int tTranslationY, int tLeft, int tRight, int tTop, int tBottom) { return &quot;Parent: {&quot; + &quot;\\nscrollX: &quot; + pScrollX + &quot;\\nscrollY: &quot; + pScrollY + &quot;\\n}\\n&quot; + &quot;MotionEvent: {&quot; + &quot;\\n&quot; + &quot;getX: &quot; + mGetX + &quot;\\ngetY: &quot; + mGetY + &quot;\\ngetRawX: &quot; + mGetRawX + &quot;\\ngetRawY: &quot; + mGetRawY + &quot;\\noffsetX: &quot; + mOffsetX + &quot;\\noffsetY:&quot; + mOffsetY + &quot;\\n}\\n&quot; + &quot;TargetView: {&quot; + &quot;\\nwidth: &quot; + tWidth + &quot;\\nheight: &quot; + tHeight + &quot;\\ngetX: &quot; + tGetX + &quot;\\ngetY: &quot; + tGetY + &quot;\\ngetScrollX: &quot; + tScrollX + &quot;\\ngetScrollY: &quot; + tScrollY + &quot;\\ngetTranslationX: &quot; + tTranslationX + &quot;\\ngetTranslationY: &quot; + tTranslationY + &quot;\\ngetLeft: &quot; + tLeft + &quot;\\ngetRight: &quot; + tRight + &quot;\\ngetTop: &quot; + tTop + &quot;\\ngetBottom: &quot; + tBottom + &quot;\\n}&quot;; } 12345678910111213141516171819202122232425/* toast 工具类 */public final class T { private static Toast sToast; @SuppressLint(&quot;ShowToast&quot;) public static void init(Context context) { sToast = Toast.makeText(context, &quot;&quot;, Toast.LENGTH_SHORT); TextView view = new TextView(context); view.setTextColor(Color.BLACK); view.setLayoutParams( new ViewGroup.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT ) ); sToast.setView(view); } public static void show(String text) { ((TextView)sToast.getView()).setText(text); sToast.setDuration(Toast.LENGTH_SHORT); sToast.show(); }} 弹性滑动上面介绍了 View 的滑动方法，也实现了实例中的前 3 个需求，但这些都只是被动的被控制的滑动，那么怎么让它自动滑动呢，就是自动从一个地方平滑到另一个地方，那么针对以上的 5 中方法，每种都有对应的处理方式，现在就有了以下三个方法，这些方法将被用来实现第4个需求：模拟悬浮窗的横向吸附效果，当松手时，如果ImageView偏左，则ImageView会平滑吸附到ViewGroup的左边缘，反之吸附到右边缘。 Animator首先就想到了属性动画，它会使用内部线程自动更新 View 的属性，再通过 View 的重绘，使 View 的形态发生变化，平常都很常用的就是平移、缩放、旋转动画，其中平移动画就是更新的 translationX 和 translationY 两种属性，那么很自然的就把滑动方法中的 translation 给搞定了，当然还可以使用动画更新自定的属性，好的，现在来着手实现自动吸附吧，首先就想到是在 View 的触摸事件中的 ACTION_UP 事件中判断 View 的当前位置，看它偏左还是偏右，如果偏左，就让它向左平滑滑向下限位置也就是初始位置，否则向右滑向上限位置，然后在开始具体的不同方法的平滑滚动。下面是使用属性动画的两种解决方案， 使用 ObjectAnimator 更新 translationX 属性实现平滑滚动。 属性动画实例化： 12/* 初始化为默认值 */mTransAnimator = ObjectAnimator.ofFloat(mTarget, &quot;translationX&quot;, 0, 0); 处理 ACTION_UP 事件 12345678910111213141516171819202122232425/** * (此方法将在ACTION_UP事件中调用) * 通过 object animator 更新 &quot;translationX&quot; 属性进行平滑 */private void scrollToSideWithTranslation() { /* translation滑动上限 */ final int transXLimit = mParentW - mParentPL - mParentPR - mTargetMR - mTargetML - mTargetW; /* 中间值 */ final int transXHalfLimit = transXLimit / 2; final float translationX = mTarget.getTranslationX(); if (translationX == 0 || translationX == transXLimit) { return; } if (translationX &lt; transXHalfLimit) { /* 根据滑动距离设置滑动时间 */ mTransAnimator.setDuration((long) (SPEED_A_PIXEL * translationX)); /* 从当前值更新到初始值0 */ mTransAnimator.setFloatValues(translationX, 0); } else { mTransAnimator.setDuration((long) (SPEED_A_PIXEL * (transXLimit - translationX))); /* 从当前值更新到上限值 */ mTransAnimator.setFloatValues(translationX, transXLimit); } mTransAnimator.start();} 使用 ValueAnimator 自定义更新 LayoutParams 中 margin 属性实现平滑滚动。 初始化动画： 123456789101112mLayoutParamsAnimator = ValueAnimator.ofInt(0);/* 在动画监听器中自定义更新layoutParams的属性 */mLayoutParamsAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { final int marginLeft = (int) animation.getAnimatedValue(); /* 动态更新layoutParams中的margin属性来做到平滑滚动 */ FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) mTarget.getLayoutParams(); params.leftMargin = marginLeft; mTarget.setLayoutParams(params); }}); 实现吸附： 1234567891011121314151617181920212223/** * (此方法将在ACTION_UP事件中调用) * 通过使用 value animator 更新 layout params 的方法进行平滑 */private void scrollToSideWithLayoutParams() { /* marginLeft下限 */ final int marginLeftMinLimit = mTargetML; /* marginLeft上限 */ final int marginLeftMaxLimit = mParentW - mParentPR - mTargetMR - mTargetW - mParentPL; /* 中间分界线 */ final int marginLeftHalfLimit = (marginLeftMaxLimit + marginLeftMinLimit) / 2; final int marginLeft = ((FrameLayout.LayoutParams) mTarget.getLayoutParams()).leftMargin; if (marginLeft &lt; marginLeftHalfLimit) { /* 滚动到下限也就是初始位置 */ mLayoutParamsAnimator.setIntValues(marginLeft, marginLeftMinLimit); mLayoutParamsAnimator.setDuration(SPEED_A_PIXEL * (marginLeft - marginLeftMinLimit)); } else { /* 滚动到上限位置 */ mLayoutParamsAnimator.setIntValues(marginLeft, marginLeftMaxLimit); mLayoutParamsAnimator.setDuration(SPEED_A_PIXEL * (marginLeftMaxLimit - marginLeft)); } mLayoutParamsAnimator.start();} 这样就非常容易的实现吸附到边缘的效果了。注意在 ACION_DOWM 事件中停止动画，还有最后对动画的回收。 1234567891011/** * 停止所有可能的动画 */private void stopAllAnimAndThread() { if (mTransAnimator != null &amp;&amp; mTransAnimator.isRunning()) { mTransAnimator.cancel(); } if (mLayoutParamsAnimator != null &amp;&amp; mLayoutParamsAnimator.isRunning()) { mLayoutParamsAnimator.cancel(); }} 这里已经实现了 translation 和 layout params 两种方法的滑动解决方案。 ScrollerScroller 是 Android 的 API 提供的一个帮助平滑滚动的工具类，它专为 scrollTo方法设计，使用它可以轻易的实现 View 内容的平滑滚动，首先介绍它的使用方法： 第一步实例化对象： 1mScroller = new Scroller(mParent.getContext()); 然后在使用它来平滑滚动之前需要在 View 的 void computeScroll() 方法中实现它滑动所必须的逻辑，因为它本身并不具备直接使 View 滑动的能力，而是在外部模拟滚动发生时的数值变化： 12345678@Overridepublic void computeScroll() { /* 继续滚动直到到mScroller设置的结束点 */ if (mScroller.computeScrollOffset()) { /* 调用scrollTo对view内容进行滚动 */ view.scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); }} Scroller 提供了 3 个 API 以供使用。 123456/* 开始平滑滚动，start为scroll 起始值，d为偏移量，向右偏移 */void startScroll(int startX, int startY, int dx, int dy);/* 这个可以指定时间 */void startScroll(int startX, int startY, int dx, int dy, int duration);/* 模拟抛出的动作，start为起始值，velocity为初速度，min为下限，max上限 */void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY); 这里平滑滚动可使用前两个，最后一个可以模拟抛出，可以用这个实现 ListView 的抛出效果。 那么直接可以使用这个来实现了，首先需要重写 computeScroll() 方法，但是现在是从外部调用触摸事件的，而且需要对 parent view 进行滚动的，怎么办，有一个办法就是实现 parent view 的子类，写一个回调就行，这里继承了 FrameLayout 写了一个 ScrollerLayout，其中就有 computeScroll() 对外部的回调 12345678910111213141516171819public final class ScrollerLayout extends FrameLayout { ...//此处省略构造器 private OnComputeScrollListener mOnComputeScrollListener; public void setOnComputeScrollListener(OnComputeScrollListener onComputeScrollListener) { this.mOnComputeScrollListener = onComputeScrollListener; } public interface OnComputeScrollListener { void onComputeScroll(); } @Override public void computeScroll() { if (mOnComputeScrollListener != null) { mOnComputeScrollListener.onComputeScroll(); } }} 现在可以初始化 Scroller 了： 12345678910mScroller = new Scroller(mParent.getContext());((ScrollerLayout) mParent).setOnComputeScrollListener( new ScrollerLayout.OnComputeScrollListener() { @Override public void onComputeScroll() { if (mScroller.computeScrollOffset()) { mParent.scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); } } }); 初始化完毕，现在可以直接使用了。 123456789101112131415161718192021/** * 通过 Scroller 进行平滑 */private void scrollToSideWithScrollTo() { /* scroll最大值 */ final int scrollXLimit = mParentW - mParentPR - mTargetMR - mTargetW - mTargetML; final int scrollX = -mParent.getScrollX(); /* 中值 */ final int scrollXHalfLimit = scrollXLimit / 2; if (scrollX &lt; scrollXHalfLimit) { /* 向x轴的起始位置滚动 */ mScroller.startScroll(mParent.getScrollX(), mParent.getScrollY(), scrollX, 0, SPEED_A_PIXEL * scrollX); } else { /* 向x轴的终点位置滚动 */ mScroller.startScroll(mParent.getScrollX(), mParent.getScrollY(), -(scrollXLimit - scrollX), 0, SPEED_A_PIXEL * (scrollXLimit - scrollX)); } /* 激活computeScroll的回调 */ mParent.invalidate();} Handler使用 Handler 进行平滑处理的方法主要是在它的消息处理方法中不断调用view的滑动方法，以此达到view不断滑动的效果，可以使用线程向 Handler 不断发送消息，也可以使用 Handler的 post 方法发送 Runnable 任务，在 Runnable 中再次发送自身即可，不断更新handler。 那么现在还剩下 offsetXXAndXX 和 layout 方法没有对应的平滑处理方法了，现在就用 handler来完成它们的平滑处理吧。 初始化： 12345678private Handler mLayoutHandler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { /* arg1为需要滚动的x轴偏移 */ scrollByOffset(msg.arg1, 0); return true; }}); 1234567private void scrollByOffset(int xOffset, int yOffset) { /* 选用一种即可 */ mTarget.offsetLeftAndRight(xOffset); mTarget.offsetTopAndBottom(yOffset); //mTarget.layout(mTarget.getLeft() + xOffset, mTarget.getTop() + yOffset, // mTarget.getRight() + xOffset, mTarget.getBottom() + yOffset);} 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 通过使用 thread 发送消息至 handler 不断调用 offset 或 layout 方法进行平滑 */private void scrollToSideWithLayoutOrOffsetFun() { final int layoutXMaxLimit = mParentW - mParentPR - mTargetMR - mTargetW; final int layoutXMinLimit = mParentPL + mTargetML; final int layoutXHalfLimit = (layoutXMaxLimit + layoutXMinLimit) / 2; final int targetLeft = mTarget.getLeft(); if (targetLeft == layoutXMinLimit || targetLeft == layoutXMaxLimit) { return; } mStartLayoutThread = true; if (targetLeft &lt; layoutXHalfLimit) { final int transDistance = targetLeft - layoutXMinLimit; final int time = SPEED_A_PIXEL * transDistance; /* 以10ms为单位计算每次需要累加的偏移 */ final int buffer = transDistance * 10 / time; mLayoutThread = new Thread(new Runnable() { @Override public void run() { int left = targetLeft; while (mStartLayoutThread) { Message msg = Message.obtain(mLayoutHandler); left -= buffer; if (left &lt; layoutXMinLimit) { msg.arg1 = -(layoutXMinLimit - left); msg.sendToTarget(); break; } else { msg.arg1 = -buffer; msg.sendToTarget(); } if (left == layoutXMinLimit) { break; } try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } } }); } else { final int transDistance = layoutXMaxLimit - targetLeft; final int time = SPEED_A_PIXEL * transDistance; /* 以10ms为单位计算每次需要累减的偏移 */ final int buffer = transDistance * 10 / time; mLayoutThread = new Thread(new Runnable() { @Override public void run() { int left = targetLeft; while (mStartLayoutThread) { Message msg = Message.obtain(mLayoutHandler); left += buffer; if (left &gt; layoutXMaxLimit) { msg.arg1 = layoutXMaxLimit - left; msg.sendToTarget(); break; } else { msg.arg1 = buffer; msg.sendToTarget(); } try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } } }); } mLayoutThread.start();} 在 ACTION_DOWM 事件里面检查并关闭线程： 123456789/** * 停止所有可能执行的线程 */private void stopAllThread() { if (mLayoutThread != null) { mStartLayoutThread = false; mLayoutThread = null; }} 最终效果如下，这里我把这几种方法整合到菜单里了，这和一种方法的效果是一样的： 滑动方法总结首先总结5中滑动方法： 通过改变 translation 的值使 View 的位置发生平移，但是并未真正改变view的布局位置，可以使用属性动画直接对其进行更新，可以很方便的做出各种平移效果。 通过改变 View 的LayoutParams 的 margin 属性使 View 发生平移，比较灵活，但是受到父 View 的限制，父 View 必须支持 margin 等一些属性，并且改变 margin 值可能会对同一个父 View 下的其他子 View 造成影响。 使用 offsetXXAndXX 和 layout 方法使 View 平移，这两种方法所造成的影响是一致的，它们是通过直接改变 View 的位置参数来使 View 发生平移的，但是要注意调用 requestLayout 会使 View 重新布局导致它的 mLeft,mRight 等属性重新赋值，View 会还原到原位置。 使用 scrollTo 和 scrollBy 方法使 View 的内容发生滚动，这个方法不适用于单个 View 的平移，更适合做一些内容滑动的控件，类似的有 ScrollView 和 ListView 这种控件。 平滑滚动： Animator 使用属性动画，可以直接使用 View 已经有的属性 translation 来进行平滑，还可以自定义动画来更新自定义的属性。在这里它比线程更好用，同时还能使用丰富的差值器来改变平移时的速率，非常方便。 使用 Scroller ，它只配合于 scrollTo 方法来使view的内容发生平滑滚动，使用方便，还有一个方法可以模拟甩出的动作，可以用它来做一些内部滑动的控件。 使用 Handler ，Handler 能干很多事，它是android中很重要的线程间通讯工具，配合线程可以自由的选择 View 的平移方式，但是使用起来可能麻烦一些，因为需要自己控制线程，但是自由发挥的空间更大。 源码https://github.com/l0neman/AnalysisAndCreate/tree/master/coordinateandscroll","link":"/2019/02/12/android-%E5%9D%90%E6%A0%87%E7%B3%BB%E5%92%8C-view-%E6%BB%91%E5%8A%A8%E6%96%B9%E6%B3%95/"},{"title":"Android 自定义 View","text":"概述View 是由视图和属性组成的控件，实现一个 View 的自定义，主要包括定义它自身的尺寸，以及绘制它的内容，并且在自身属性发生改变时能正确更新其绘制的内容。 ViewGroup 是 View 的容器类型，内部可容纳多个 View，并对子 View 的位置进行规划，根据自身特性的不同，子 View 的摆放特点也各不相同。由于 ViewGroup 本身也是 View 的子类，所以 ViewGroup 本身也可作为子View 出现。自定义 ViewGroup 时，更着重于对子 View 位置的处理，并且尺寸由子 View 的尺寸和摆放位置决定，在一些复杂的自定义 View 中，内容的绘制和子 View 位置的处理可能显的同等重要。 MeasureSpecMeasureSpec 负责生成 View 的 onMeasure方法中所传递的 measureSpec 参数和从中提取信息，measureSpec 参数将携带父 View 提供的尺寸和测量模式信息，作为确定 View 自身尺寸和 View 继续子View的测量参考。 measureSpec 参数是一个32位int型值，其中高两位将保存测量模式的值，低30位保存尺寸大小，MeasureSpec 提供了生成 measureSpec 参数的方法，它使用位运算将模式和尺寸信息保存至 measureSpec 参数中。 MeasureSpec 部分源码 1234567891011121314151617181920212223242526/* 移位 */private static final int MODE_SHIFT = 30;/* 1100 0000 0000 0000 0000 0000 0000 0000 方便取mode值 */private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT;/* 三种测量模式 */private static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;private static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;private static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT;/** 产生MeasureSpec */public static int makeMeasureSpec(int size, int mode){ if(isUseBrokenMakeMeasureSpec){ return size + mode; }else{ /* 合并mode和size */ return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); }}/** 取出高2位的 mode 值 */public static int getMode(int measureSpec){ return (measureSpec &amp; MODE_MASK);}/** 取出低30位的 size 大小 */public static int getSize(int measureSpec){ return (measureSpec &amp; ~MODE_MASK);} 当实现View的 onMeasure 方法时，可根据测量模式确定View的尺寸，下面是3种测量模式。 模式 描述 对应布局参数 AT_MOST 父容器指定了 View 最大可用大小 一般对应 WRAP_CONTENT EXACTLY 父容器检测到 View 精确大小 MATCH_PARENT 或 固定 dp UNSPECIFIED 父容器对 View 大小无限制 其他 每个 View 的 measureSpec 参数由父容器结合 View 自身的布局参数将要对 View 进行测量时生成，下面是 ViewGroup 的 getChildMeasureSpec 方法，负责生成子 View 的 measureSpec。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) { resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) { resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) { resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } return MeasureSpec.makeMeasureSpec(resultSize, resultMode);} 在 ViewGroup 的 measureChild 方法中有对 getChildMeasureSpec 的调用。 123456789protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final ViewGroup.LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);} 自定义 View 属性概述一个合格的 View 是拥有多种可设置属性的，包括从 Java 代码和 XML 布局文件中设置两种方式，Android SDK 提供的原生 View 本身具有丰富的属性，这里实现自定义 View 的 XML 属性。 首先需要创建自定义 View 的 Java 类型 然后在 res/values/ 目录下建立 attrs.xml，在其中建立自定义View对应的自定义属性 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;TestView&quot;&gt; &lt;attr name=&quot;attr name&quot; format=&quot;value type&quot; /&gt; ... &lt;/declare-styleable&gt;&lt;/resources&gt; 使用 &lt;declare-styleable/&gt; 标签创建view的自定义属性，其中 name 最好指定为自定义View的名字，方便和 View 对应。在内部包含的 &lt;attr/&gt; 标签为该 View 支持的自定义属性列表，包含一个属性名字和引用的类型，定义后即可在布局中使用自定义 View 的属性，与系统属性所用的 android 命名空间不同，自定义属性需要使用 app 命名空间，自定义属性支持以下的所有 Format 类型。 format类型 描述 integer 指定一个整型数值 boolean 指定一个布尔型值 float 指定一个浮点型数值 string 指定一个字符串类型值 color 指定一个颜色的16进制数值或color资源的引用 dimension 指定Android中支持的尺寸类型（dp,sp,px…）或dimen资源的引用 fraction 指定一个百分比（20%，10%p），带p的支持分母因子 reference 指定一个引用类型，可以使任何资源的引用（drawable,color,dimen…） flag 只能使用flag内定义的值，值的类型只能为整型 enum 和flag功能相同，但可以和integer类型混用，可指定定义外的int值 定义完属性后，即可在view的构造方法里，通过 AttributeSet 参数获取在xml中定义的属性值 。 123456789public constrac(Context context, @Nullable AttributeSet attrs) { super(context, attrs); /* 解析出自定义属性 */ TypedArray array = getContext().obtainStyledAttributes(attrs, R.styleable.AttrTestView); /* 获取色彩资源 */ final int colorAttr = array.getColor(R.styleable.AttrTestView_colorAttr, 0); final xx attr = array.getXX(..); ...} 下面是每种类型定义以及获取的完整示例： 基本类型基本类型 int，boolean，float，String。 定义 1234567&lt;declare-styleable name=&quot;AttrTestView&quot;&gt; &lt;attr name=&quot;intAttr&quot; format=&quot;integer&quot; /&gt; &lt;attr name=&quot;boolAttr&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;floatAttr&quot; format=&quot;float&quot; /&gt; &lt;attr name=&quot;stringAttr&quot; format=&quot;string&quot; /&gt; ...&lt;/declare-styleable&gt; 使用 123456&lt;com.example.viewtest.view.AttrTestView ... app:intAttr=&quot;52&quot; app:boolAttr=&quot;true&quot; app:floatAttr=&quot;0.56&quot; app:stringAttr=&quot;hello&quot; /&gt; 获取值，后面的参数提供无结果时默认值 1234final int intAttr = array.getInt(R.styleable.AttrTestView_intAttr, 0);final boolean boolAttr = array.getBoolean(R.styleable.AttrTestView_boolAttr, false);final float floatAttr = array.getFloat(R.styleable.AttrTestView_floatAttr, 0F);final String stringAttr = array.getString(R.styleable.AttrTestView_stringAttr); 色彩和尺寸类型 定义 12&lt;attr name=&quot;dimenAttr&quot; format=&quot;dimension&quot; /&gt;&lt;attr name=&quot;colorAttr&quot; format=&quot;color&quot; /&gt; 使用，色彩类型可指定16进制颜色值或资源的引用，尺寸类型可指定支持的尺寸类型和引用 1234567&lt;com.example.viewtest.view.AttrTestView ... app:dimenAttr=&quot;10dp&quot; app:dimenAttr=&quot;15px&quot; app:dimenAttr=&quot;@dimen/testDimen&quot; app:colorAttr=&quot;@color/testColor&quot; app:colorAttr=&quot;#ffaabbcc&quot;/&gt; 获取值 12final int colorAttr = array.getColor(R.styleable.AttrTestView_colorAttr, 0);final float dimenAttr = array.getDimension(R.styleable.AttrTestView_dimenAttr, 0); 引用类型 定义 1&lt;attr name=&quot;refAttr&quot; format=&quot;reference&quot; /&gt; 使用，引用类型可指定各种资源的引用 123456&lt;com.example.viewtest.view.AttrTestView ... app:refAttr=&quot;@dimen/testDimen&quot; app:refAttr=&quot;@drawable/ic_test&quot; app:refAttr=&quot;@string/testString&quot; app:refAttr=&quot;@color/testColor&quot;/&gt; 获取时，针对对应的资源类型获取 123final Drawable refIcon = array.getDrawable(R.styleable.AttrTestView_refAttr);final int refColor = array.getColor(R.styleable.AttrTestView_refAttr, 0);... 百分比类型 定义 1&lt;attr name=&quot;fractionAttr&quot; format=&quot;fraction&quot; /&gt; 使用，有两种方式，默认(x%)和带有分母因子(x%p)的，在获取时有差异 1234&lt;com.example.viewtest.view.AttrTestView ... app:fractionAttr=&quot;10%&quot; app:fractionAttr=&quot;10%p&quot;/&gt; 获取方法的定义 123456/** * @param base 标准分数形式的因子 * @param pbase 母体分数形式的因子(nn%p) * base 对应 10% 形式 pbase 对应 10%p 形式，两者不能存在 */float getFraction(int index, int base, int pbase, float defValue) 获取示例 12345678910// app:fractionAttr=&quot;10%&quot;/* result is 0.2 */array.getFraction(R.styleable.AttrTestView_fractionAttr, 1, 2, 0F);/* result is 0.2 */array.getFraction(R.styleable.AttrTestView_fractionAttr, 2, 2, 0F);// app:fractionAttr=&quot;10%p&quot;/* result is 0.2 */array.getFraction(R.styleable.AttrTestView_fractionAttr, 2, 1, 0F);/* result is 0.2 */array.getFraction(R.styleable.AttrTestView_fractionAttr, 2, 2, 0F); flag 类型 定义，flag 可指定一组限制值，定义后，属性只能使用组内的数值，数值类型为数字 12345&lt;attr name=&quot;flagAttr&quot;&gt; &lt;flag name=&quot;FLAG_0&quot; value=&quot;0x01&quot; /&gt; &lt;flag name=&quot;FLAG_1&quot; value=&quot;0x02&quot; /&gt; ...&lt;/attr&gt; 使用，使用时还可以使用按位或 | 运算符组合多个值 1234&lt;com.example.viewtest.view.AttrTestView ... app:flagAttr=&quot;FLAG_0|FLAG_1&quot; app:flagAttr=&quot;FLAG_0&quot;/&gt; 使用获取整形的方式获取值 1final int flagAttr = array.getInt(R.styleable.AttrTestView_flagAttr, 0); 枚举类型 定义，和 flag 定义形式相同，不过可以组合 integer 类型 12345&lt;attr name=&quot;enumAttr&quot; format=&quot;integer&quot;&gt; &lt;flag name=&quot;ENUM_0&quot; value=&quot;0&quot;/&gt; &lt;flag name=&quot;ENUM_1&quot; value=&quot;1&quot;/&gt; ...&lt;/attr&gt; 当组合 Integer 类型时，可直接指定数字，否则和 flag 一样，只能使用组内定义的值 12345&lt;com.example.viewtest.view.AttrTestView ... app:flagAttr=&quot;123&quot; app:flagAttr=&quot;ENUM_0|ENUM_1&quot; app:flagAttr=&quot;ENUM_0&quot;/&gt; 获取 1final int enumAttr = array.getInt(R.styleable.AttrTestView_enumAttr, 0); 自定义 View 实现一个自定义 View，首先需要定义自身尺寸，然后绘制自身内容，最后提供自定义的 View 属性。 首先需要实现 onMeasure 测量方法，以指明 View 尺寸，根据 measureSpec 参数中的模式和基础尺寸，确定最终尺寸，下面提供一种通用的实现： 1234567891011121314151617@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { final int baseWidth = View.MeasureSpec.getSize(widthMeasureSpec); final int baseHeight = View.MeasureSpec.getSize(heightMeasureSpec); final int widthMode = View.MeasureSpec.getMode(widthMeasureSpec); final int heightMode = View.MeasureSpec.getMode(heightMeasureSpec); /* 如果是精确模式（match_parent 或 固定尺寸）则使用获取的基础尺寸，否则使用 基础尺寸和提供的 wrapSize 的最小值。 */ final int width = widthMode == MeasureSpec.EXACTLY ? baseWidth : Math.min(baseWidth, getWrapWidth(baseWidth)); final int height = heightMode == MeasureSpec.EXACTLY ? baseHeight : Math.min(baseWidth, getWrapHeight(baseHeight)); super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode), MeasureSpec.makeMeasureSpec(height, heightMode));} 这里最后调用的父类的 onMeasure 方法，将会调用 setMeasuredDimension 方法设置自身尺寸，当然也可以直接调用这个方法 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));} 在 onMeasure 方法执行后，可以使用 getMeasuredWidth() 和 getMeasuredHeight() 获取自身宽高 实现 onDraw 方法，绘制 View 内容，使用 Canvas 和 Paint 组合进行绘制工作 123456@Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); /* 绘制自定义图形 */ canvas.drawXX(...); ...} 下面编写一个非常简单的自定义View，模拟一个简单的按钮，当手触摸上去时，会变色，手指放开时，颜色还原。 SimpleButtonTest 实例首先建立一个空的 SimpleButtonTest 类，需要实现父类的构造器 12345678910111213public class TestSimpleButton extends View {public TestSimpleButton(Context context) { this(context, null); } public TestSimpleButton(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public TestSimpleButton(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); }} 定义控件的尺寸，重写 onMeasure，这里为内容包裹模式提供了一个固定的尺寸 123456789101112131415161718192021222324252627282930@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { final int baseWidth = View.MeasureSpec.getSize(widthMeasureSpec); final int baseHeight = View.MeasureSpec.getSize(heightMeasureSpec); final int widthMode = View.MeasureSpec.getMode(widthMeasureSpec); final int heightMode = View.MeasureSpec.getMode(heightMeasureSpec); /* 如果是精确模式（match_parent 或 固定尺寸）则使用获取的基础尺寸，否则使用 基础尺寸和提供的 wrapSize 的最小值。 */ int wrapWidth = getWrapWidth(); final int width = widthMode == MeasureSpec.EXACTLY ? baseWidth : Math.min(baseWidth, wrapWidth); int wrapHeight = getWrapHeight(); final int height = heightMode == MeasureSpec.EXACTLY ? baseHeight : Math.min(baseWidth, wrapHeight); super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode), MeasureSpec.makeMeasureSpec(height, heightMode));}/* 提供内容包裹时的宽和高 88dp, 64dp */private int getWrapWidth() { return (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 88F, getResources().getDisplayMetrics());}private int getWrapHeight() { return (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 64F, getResources().getDisplayMetrics());} 然后实现手指触摸时的颜色变化，首先绘制颜色，重写 onDraw 方法绘制内容 12345private int mColor;...@Override protected void onDraw(Canvas canvas) { canvas.drawColor(mBtnColor);} 定义两种状态时的色彩 12345678910private int mPressedColor;private int mBtnColor;...public TestSimpleButton(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); mColor = getResources().getColor(R.color.colorPrimary); mPressedColor = getResources().getColor(R.color.colorPrimaryDark); mBtnColor = mColor;} 实现触摸的监听需要重写 onTouchEvent 方法，为了使 View 的事件默认不被拦截，所以需要在构造器中设置 12setClickable(true);setFocusable(true); 最后实现 onTouchEvent 方法的内容 123456789101112@Override public boolean onTouchEvent(MotionEvent event) { int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { mBtnColor = mPressedColor; /* 重绘 */ invalidate(); } else if (actionMasked == MotionEvent.ACTION_UP) { mBtnColor = mColor; invalidate(); } return super.onTouchEvent(event); } 其中的 invalidate 方法为请求 View 重新绘制，他将会再次回调 onDraw 方法刷新绘制的内容，此时颜色改变，View 的显示自然发生变化。以上就完成了一个简单 View 的自定义。 LayoutParamsLayoutParams 是设置在 View 上的与父布局相关属性的映射。一个View在xml文件中设置的属性由两部分组成，一部分属于 View 自身的属性，交给 View 自身处理，另一部分属于 LayoutParams，交给所在的 ViewGroup 处理。 系统默认提供了 ViewGroup.LayoutParams，它本身拥有丰富的属性，如果需要自定义自己的 LayoutParams，需要实现它的子类。 一般 LayoutParams 的属性都是带有 layout_ 前缀的属性，例如 layout_width ，layout_Height ，自定义属性时也许需要遵循这个命名规范。 下面自定义一个简单的 LayoutParams，由于 LayoutParams 必须有关联的的 ViewGroup 的支持，所以这里先定义一个空的 ViewGroup。 1public class TestViewGroup extends ViewGroup { ... } 然后和 View 的自定义属性一样，首先定义 attrs.xml 文件，一般 LayoutParams 的 styleable 的 name 属性定义为 ViewGroup 的名称加 _Layout 后缀。 12345678&lt;declare-styleable name=&quot;TestViewGroup_Layout&quot;&gt; &lt;attr name=&quot;layout_gravity&quot;&gt; &lt;flag name=&quot;left&quot; value=&quot;0x0001&quot; /&gt; &lt;flag name=&quot;right&quot; value=&quot;0x0002&quot; /&gt; &lt;flag name=&quot;top&quot; value=&quot;0x0004&quot; /&gt; &lt;flag name=&quot;bottom&quot; value=&quot;0x0008&quot; /&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; 这样就定义了一个简单的 layout_gravity 属性。接下来在 TestViewGroup 实现一个 LayoutParams 来承载上面自定义的属性。 12345678910111213public static final class LayoutParams extends LayoutParams { ... public LayoutParams(Context c, AttributeSet attrs) { super(c, attrs); getGravity(c, attrs); } /* 从 attrs 中解析出 layout_gravity 属性的值 */ private void getGravity(Context c, AttributeSet attrs) { TypedArray array = c.obtainStyledAttributes(attrs, R.styleable.TestViewGroup_Layout); gravity = array.getInt(R.styleable.TestViewGroup_Layout_layout_gravity, 0); array.recycle(); }} 最后一步，将这个 LayoutParams 与 ViewGroup 相关联，需要重写 ViewGroup 的几个方法： 123456789101112131415161718public class TestViewGroup extends ViewGroup { ... @Override protected boolean checkLayoutParams(ViewGroup.LayoutParams p) { return p instanceof LayoutParams; } @Override protected LayoutParams generateDefaultLayoutParams() { return new LayoutParams(); } @Override protected LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) { return new LayoutParams(p); } @Override public LayoutParams generateLayoutParams(AttributeSet attrs) { return new LayoutParams(getContext(), attrs); }} 实现了这些方法后，LayoutParams 就与 ViewGroup 建立了关联，在 ViewGroup 调用 addView 添加子 View 时，会使用上面重新的方法为每个子 View 建立一个 LayoutParams。 123456789101112/* ViewGroup.java */public void addView(View child, int index) { ... LayoutParams params = child.getLayoutParams(); if (params == null) { params = generateDefaultLayoutParams(); if (params == null) { throw new IllegalArgumentException(&quot;generateDefaultLayoutParams() cannot return null&quot;); } } addView(child, index, params); } 最后在 XML 布局中使用 12345678910&lt;com.example.viewtest.view.TestViewGroup android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;View app:layout_gravity=&quot;left&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/com.example.viewtest.view.TestViewGroup&gt; 如果想让自定义的 LayoutParams 支持 Margin 属性， 可以继承 ViewGroup.MarginLayoutParams。 自定义 ViewGroup 实现一个 ViewGroup，除了需要实现 View 的基本的尺寸定义和提供自定义属性，还需要实现对子 View 位置的控制，如果需要更为细致的针对每个子 View 有不同的处理，则需要实现自定义的 LayoutParams， onLayout 方法为必须实现的抽象方法，它是 ViewGroup 的核心，负责控制所有子 View 的位置摆放，具体方法是通过计算子 View 的 left, right, top, bottom 的位置后，调用它们的 layout 方法为每个子 View 设置最终位置。 下面将会用一个实例来说明 ViewGroup 的自定义。 BorderLayoutSample 实例下面要定义一个类似 Java中的 Border 布局的 ViewGroup，它拥有以下特性： 子 View 可使用 layout_gravity 属性设置自身的位置，基本位置属性值包括 left, right, top, bottom, centerX, centerY, center ，还可使用按位或 | 符号组合属性值使用，例如 left | bottom 代表左下方。 为了简单，一旦放入布局中，所有子 View 的尺寸将统一，默认使用最小宽度和最小高度的子View（宽高不为0dp）的尺寸作为统一子 View 尺寸，可以使用 requestWidth 和 requestHeight 请求统一的子 view 的宽和高，BorderLayout 的宽高为统一子 View 宽高的3倍（为了给其他方位的子View留出空间），如果默认和请求的子View尺寸的3倍超过尺寸限制（measureSpec包含的 size），则强制另统一子 View 的尺寸为限制尺寸的 1/3。 如果所有子 View 的宽高都为0，则 BorderLayout 的宽高为0。 最终效果如下： 123456789101112131415161718192021222324252627282930313233343536&lt;com.example.viewtest.view.BorderLayoutSample android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#dadada&quot; app:requestHeight=&quot;60dp&quot; app:requestWidth=&quot;60dp&quot;&gt; &lt;!--右上方--&gt; &lt;View android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:background=&quot;#ff7474&quot; app:layout_gravity=&quot;right&quot; /&gt; &lt;!--正中间--&gt; &lt;View android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:background=&quot;#74ff74&quot; app:layout_gravity=&quot;center&quot; /&gt; &lt;!--左边中间--&gt; &lt;View android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:background=&quot;#74b0ff&quot; app:layout_gravity=&quot;centerY&quot; /&gt; &lt;!--右下方--&gt; &lt;View android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:background=&quot;#ffe874&quot; app:layout_gravity=&quot;bottom|right&quot; /&gt;&lt;/com.example.viewtest.view.BorderLayoutSample&gt; 实机测试 下面开始实现 BorderLayoutSample 首先建立 BorderLayoutSample 类，由于继承了 ViewGroup ，并且需要支持自定义属性，所以这里重写了三个构造器方法和一个 onLayout 方法的空实现。 123456789101112131415public class BorderLayoutSample extends ViewGroup { public BorderLayoutSample (Context context) { this(context, null); } public BorderLayoutSample (Context context, AttributeSet attrs) { this(context, attrs, 0); } public BorderLayoutSample (Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override protected void onLayout(boolean changed, int l, int t, int r, int b) {}} 然后是对两个自定义属性 requestWidth 和 requestHeight 的支持，新建 borderlayoutsample_attrs.xml 文件，定义如下属性： 123456&lt;declare-styleable name=&quot;BorderLayoutSample&quot;&gt; &lt;!--请求子View宽度--&gt; &lt;attr name=&quot;requestWidth&quot; format=&quot;dimension&quot; /&gt; &lt;!--请求子View高度--&gt; &lt;attr name=&quot;requestHeight&quot; format=&quot;dimension&quot; /&gt;&lt;/declare-styleable&gt; 在构造器中获取值，方便后面访问 123456789101112...public BorderLayoutSample(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(attrs);}private void init(AttributeSet attrs) { TypedArray array = getContext().obtainStyledAttributes(attrs, R.styleable.BorderLayoutSample); mRequestWidth = array.getDimensionPixelOffset(R.styleable.BorderLayoutSample_requestWidth, -1); mRequestHeight = array.getDimensionPixelOffset(R.styleable.BorderLayoutSample_requestHeight, -1); array.recycle();} 根据前面定义的 Border布局特性，实现 onMeasure 定义自身尺寸 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950... -private int mChildWidth = -1;private int mChild Height = -1;private int mRequestWidth;private int mRequestHeight;...@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { final int count = getChildCount(); if (count == 0) { return; } final int baseWidth = MeasureSpec.getSize(widthMeasureSpec); final int baseHeight = MeasureSpec.getSize(heightMeasureSpec); if (mRequestWidth != -1 &amp;&amp; mRequestHeight != -1) { /* 如果指定了最终子View尺寸 则根据 指定的最终子View尺寸 确定 最终子View的尺寸 */ mChildWidth = mRequestWidth * 3 &gt; baseWidth ? baseWidth / 3 : mRequestWidth; mChildHeight = mRequestHeight * 3 &gt; baseHeight ? baseHeight / 3 : mRequestHeight; } else { /* 确定请求的子View宽和高(最小的子View尺寸) */ int minWidth = Integer.MAX_VALUE; int minHeight = Integer.MAX_VALUE; for (int i = 0; i &lt; count; i++) { View child = getChildAt(i); measureChild(child, widthMeasureSpec, heightMeasureSpec); if (child.getMeasuredWidth() == 0 || child.getMeasuredHeight() == 0) { continue; } minWidth = Math.min(minWidth, child.getMeasuredWidth()); minHeight = Math.min(minHeight, child.getMeasuredHeight()); } /* 如果所有子View尺寸都是0 */ if (minWidth == Integer.MAX_VALUE) { minWidth = 0; } if (minHeight == Integer.MAX_VALUE) { minHeight = 0; } mChildWidth = minWidth * 3 &gt; baseWidth ? baseWidth / 3 : minWidth; mChildHeight = minHeight * 3 &gt; baseHeight ? baseHeight / 3 : minHeight; } super.onMeasure(getMeasureSpec(widthMeasureSpec, mChildWidth * 3), getMeasureSpec(heightMeasureSpec, mChildHeight * 3));}/* 生成 measureSpec */private static int getMeasureSpec(int measureSpec, int wrapSize) { final int baseSize = View.MeasureSpec.getSize(measureSpec); final int mode = View.MeasureSpec.getMode(measureSpec); final int size = mode == View.MeasureSpec.AT_MOST /* dp or match parent */ ? Math.min(wrapSize, baseSize) : baseSize; return View.MeasureSpec.makeMeasureSpec(size, mode);} 其中使用了 measureChild 对子 View 进行测量，还可使用 measureChildWithMargins 测量子 View 尺寸，它会在测量时考虑子 View 的 margin 值。 接着实现核心方法 onLayout，由于需要给子 View 提供 layout_gravity 的属性，这个属性将会影响每个子 View 自身所处位置，这里首先定义 LayoutParams 类来支持这个属性。 在刚才的 borderlayoutsample_attrs.xml 文件中加一个自定义属性 12345678910111213&lt;declare-styleable name=&quot;BorderLayoutSample_Layout&quot;&gt; &lt;!--布局重力--&gt; &lt;attr name=&quot;layout_gravity&quot;&gt; &lt;flag name=&quot;left&quot; value=&quot;0x0001&quot; /&gt; &lt;flag name=&quot;right&quot; value=&quot;0x0002&quot; /&gt; &lt;flag name=&quot;top&quot; value=&quot;0x0004&quot; /&gt; &lt;flag name=&quot;bottom&quot; value=&quot;0x0008&quot; /&gt; &lt;flag name=&quot;centerX&quot; value=&quot;0x0010&quot; /&gt; &lt;flag name=&quot;centerY&quot; value=&quot;0x0020&quot; /&gt; &lt;!--centerY | centerX--&gt; &lt;flag name=&quot;center&quot; value=&quot;0x0030&quot; /&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; 在定义 layout_gravity 的属性值的时候，由于需要支持 left|right 形式的组合值，所以需要对属性值进行设计，这里用的就是，0x0001, 0x0002, 0x0004...，他们对应的二进制值分别为 0001,0010,0100,1000... 可以使用按位或运算进行组合和区分。 定义属性文件后，实现对应的 LayoutParams 类，这里先抽出一个对应 gravity 属性值的类 Gravity，它包含 gravity 属性值的定义和计算。 12345678910111213141516171819202122232425public static final class Gravity { public static final int BASE = 0x0001; public static final int LEFT = BASE; public static final int RIGHT = BASE &lt;&lt; 1; public static final int TOP = BASE &lt;&lt; 2; public static final int BOTTOM = BASE &lt;&lt; 3; /** 0x0010 */ public static final int CENTER_X = BASE &lt;&lt; 4; /** 0x0020 */ public static final int CENTER_Y = BASE &lt;&lt; 5; /** 0x0030 */ public static final int CENTER = CENTER_X | CENTER_Y; public static boolean hasLeft(int gravity) { return (gravity &amp; LEFT) == LEFT; } public static boolean hasRight(int gravity) { return (gravity &amp; RIGHT) == RIGHT; } public static boolean hasTop(int gravity) { return (gravity &amp; TOP) == TOP; } public static boolean hasBottom(int gravity) { return (gravity &amp; BOTTOM) == BOTTOM; } public static boolean hasCenterX(int gravity) { return (gravity &amp; CENTER_X) == CENTER_X; } public static boolean hasCenterY(int gravity) { return (gravity &amp; CENTER_Y) == CENTER_Y; }} 下面是 LayoutParams 类的实现 12345678910111213141516171819202122232425262728public static final class LayoutParams extends ViewGroup.LayoutParams { private int gravity = Gravity.LEFT | Gravity.TOP; public LayoutParams() { super(0, 0); } public LayoutParams(ViewGroup.LayoutParams source) { super(source); if (source instanceof LayoutParams) { setGravity(((LayoutParams)source).gravity); } } public LayoutParams(Context c, AttributeSet attrs) { super(c, attrs); getGravity(c, attrs); } private void getGravity(Context c, AttributeSet attrs) { TypedArray array = c.obtainStyledAttributes(attrs, R.styleable.BorderLayoutSample_Layout); gravity = array.getInt(R.styleable.BorderLayoutSample_Layout_layout_gravity, 0); array.recycle(); } public void setGravity(int gravity) { this.gravity = gravity; } public int getGravity() { return gravity; }} 最后建立 BorderLayoutSample 的关联 123456789101112131415@Override protected boolean checkLayoutParams(ViewGroup.LayoutParams p) { return p instanceof LayoutParams;}@Override protected LayoutParams generateDefaultLayoutParams() { return new LayoutParams();}@Override protected LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) { return new LayoutParams(p);}@Override public LayoutParams generateLayoutParams(AttributeSet attrs) { return new LayoutParams(getContext(), attrs);} 在完成了 LayoutParams 的定义后，就可以结合属性值进行 onLayout 的最终实现了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Override protected void onLayout(boolean changed, int l, int t, int r, int b) { if (mChildWidth == 0 || mChildHeight == 0) { return; } int count = getChildCount(); for (int i = 0; i &lt; count; i++) { View child = getChildAt(i); LayoutParams layoutParams = (LayoutParams)child.getLayoutParams(); layoutChild(child, layoutParams.getGravity()); }}private void layoutChild(View child, int gravity) { int left = 0; int right = left + mChildWidth; int top = 0; int bottom = top + mChildHeight; final int width = getMeasuredWidth(); final int height = getMeasuredHeight(); if (Gravity.hasLeft(gravity)) { left = 0; right = left + mChildWidth; } if (Gravity.hasRight(gravity)) { right = width; left = right - mChildWidth; } if (Gravity.hasTop(gravity)) { top = 0; bottom = top + mChildHeight; } if (Gravity.hasBottom(gravity)) { bottom = height; top = bottom - mChildHeight; } if (Gravity.hasCenterX(gravity)) { left = (width - mChildWidth) &gt;&gt; 1; right = left + mChildWidth; } if (Gravity.hasCenterY(gravity)) { top = (height - mChildHeight) &gt;&gt; 1; bottom = top + mChildHeight; } child.layout(left, top, right, bottom);} 以上就完成了一个 BorderLayoutSample 实例。 常用方法总结以下记录一些自定义 View 时常用的辅助方法 1234567891011121314151617/* 一般在 onMeasure 方法的末尾调用，用来保存测量后的View宽高，保存后可使用 getMeasureWidth() 和 getMeasureHeight() 方法获取 */void setMeasuredDimension(int measuredWidth, int measuredHeight);/* 将View的绘制层次提到顶层，在api19(android 4.4)之前调用，还需要在其后调用 requestLayout 和 invalidate 方法刷新图层 */void bringToFront();/* 使View绘制无效，之后会回调 onDraw 重新绘制，只能在主线程 */void invalidate();/* 同 invalidate 可在子线程调用 */void postInvalidate();/* 使View布局无效，之后将触发视图树的layout过程 */void requestLayout();/* 用父级调用，请求子View计算 mScrollX 和 mScrollY 的新值，通常在使用 Scroller 类的时候重写 */void computeScroll(); 参考 https://staticallytyped.wordpress.com/2011/04/16/android-custom-xml-attributes-and-views/ https://developer.android.com/reference/android/view/View.html","link":"/2019/02/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89-view/"},{"title":"Android arsc 文件解析","text":"apk 文件结构在使用 Android SDK 编译 Android 工程时，它会将工程的源代码和资源打包为一个 apk 文件，apk 文件实质为一个压缩包，一个未签名的 apk 文件典型结构如下： 1234567apk file:assets/ - assets 原始资源文件lib/ - so 库文件res/ - 资源文件 classes.dex - 编译后的代码resources.arsc - 资源信息文件AndroidManifest.xml - 二进制的清单文件 在 Android 项目的编译过程中，Java 代码将会被编译为 classes.dex 文件，JNI 代码被编译为 .so 文件存放在 lib 目录下，assets 目录和 res/raw 目录中文件的将不会发生变化，对于资源文件中 xml 形式的资源将会被编译为优化过的特定的二进制 xml 格式，而类似于图片这种本身为二进制的类型也不会发生变化，AndroidManifest.xml 清单文件被编译为优化过的二进制格式。 资源编译过程在开发 Android 项目时，需要在布局中引用资源，当资源在工程中被创建时，IDE 将会使用 Android SDK 中的 aapt 工具自动生成 R.java 文件，这时在代码或布局文件中即可使用资源 id 来引用资源。 在 aapt 工具生成 R 文件的同时，还同时生成了一个 resources.arsc 文件，它负责记录资源信息，类似于一张表，当 apk 运行在 Android 设备时，应用将会首先将 resources.arsc 包含的资源信息映射到内存中的数据结构中，当需要使用资源 id 引用具体资源时，只需要在内存中的数据结构中进行查询，即可得到具体的资源文件路径。 一个典型的资源 id 如下： 10x7f020000 它由 3 部分组成： 首字节为 Package ID，代表资源所在的资源包 ID，一般 apk 中只包含两种资源包，系统资源包和应用资源包，它们的包 ID 分别为 0x01 和 0x7f。 次字节为 Type ID，代表资源类型，即 animator、anim、color、drawable、layout、menu、raw、string 和 xml 等类型，每种类型对应一个 id。 末两个字节为 Entry ID，代表资源在其类型中的次序。 aapt 工具编译资源的过程是比较复杂的，其中的步骤非常细致，在它编译时会将资源逐步保存至一个 ResourceTable 类中，它的源码路径是 frameworks\\base\\tools\\aapt\\ResourceTable，下面简述资源编译过程（参考了罗升阳的博客）。 1. Parse AndroidManifst.xml解析 Android 清单文件中的 package 属性，为了提供生成 R 文件的包名。 2. Add Included Resources添加被引用的资源包，此时会引用系统资源包，在 android 源码工程的 out/target/common/obj/APPS/framework-res_intermediates/package-export.apk，可通过资源 id 引用其中的资源。 3. Collection Resource Filesaapt 工具开始收集需要编译的资源，将每种类型的资源以及对应的配置维度保存起来。 12345678910Type Name Config Dataanimxmlcolordrawable main.png... sub.png ok.png mdpi ... hdpi xhdpi binary ... 4. Add Resources to Resource Table将资源加入资源表。 12345678910Package Type Name Config Pathcom.xx.xx anim xml color drawable main.png ... sub.png ok.png mdpi ... hdpi res/drawable-hdpi/ok.png xhdpi res/drawable-xhdpi/ok.png ... ... 5. Compile Values Resources收集 value 下的资源。 1234Package Name Config Valuestring app_name default TestAppstring sub_title default SubTitleText... ... ... ... 6. Assign Resource ID to Bag给特殊的 Bag 资源类型分配 id，例如 style，array 等资源。 12345Type Name Configt Valuestyle orientation default -... layout_vertical default 0 layout_horizontal default 1 ... ... ... 7. Compile Xml Resources这一步是将 xml 类型的资源编译为优化过后的二进制格式，便于压缩大小和解析时提高性能。有 6 个子步骤。 Parser Xml File（解析原始 xml 文件中的节点树） 12345XMLNode-elementName -Xml 元素标签-chars -Xml 元素的文本内容-attributes -Xml 元素的属性列表-children -Xml 的子元素 Assign Resource IDs（赋予属性名资源 id） 1234android:layout_width -&gt; find ResID From ResourceTable -&gt; set ResIDandroid:layout_height -&gt; find ResID From ResourceTable -&gt; set ResIDandroid:gravity -&gt; find ResID From ResourceTable -&gt; set ResID... Parse Values（解析属性的原始值） 12android:orientation = horizontal -&gt; 0... 对于 @+ 符号表示无此 id，则新建此 id。 1234name Config Valueet_name default -et_pwd default -... Flatten（平铺，即转化为最终的二进制格式） Collect Resource ID Strings（收集有资源 id 的属性的名称字符串） 12String orientation layout_width layout_height id ...Resource ID 0x010100c4 0x010100f4 0x010100f5 0x010100d0 ... Collect Strings（收集其他字符串） 1String android http://schemas.android.com/apk/res/android LinearLayout ... Write Xml header（写入 xml 头部） Write String Pool（依 id 次序写入字符串池） 1orientation layout_width layout_height id android http://schemas.android.com/apk/res/android LinearLayout Button Write Resource IDs（写入资源 id 值二进制的 xml 文件中） Flatten Nodes（平铺，即将二进制的 xml 文件中的资源全部替换为资源索引） 8. Add Resource Symbols添加资源符号，根据资源在其资源类型中的位置，为每个资源分配资源 id。 9. Write resource.arsc将上述收集的资源写入 resoruce.arsc 文件中。分为 7 个步骤。 Collect Type Strings（收集每个 package 的类型字符串） 1drawable layout string id ... Collect Key Strings（收集每个 package 的资源项的名称字符串） 1main icon app_name et_name ... Collect Value Strings（收集资源原始值字符串） 1res/drawable-ldpi/icon.png TestApp SubTitleText Generate Package Trunk（生成 package 数据块） Write Package Header（写入 package 资源的原信息数据块） Write Type Strings（写入类型字符串资源池） Write Key Strings（写入资源项名称字符串资源池） Write Type Specification（写入类型规范数据块） Write Type Info（写入类型资源项数据块） Write Resource Table Header（写入资源表的头部数据块） Write Value Strings（ 写入上面收集的资源项的值字符串） Write Package Trunk（写入上面收集的 Package 数据块） 10. Compile AndroidManifest.xml将 AndroidManifest.xml 编译为二进制。 11. Write R.java生成 R 文件。 12. Write APK写入 apk 文件。 arsc 文件结构arsc 文件作为资源信息的存储结构，其结构将会遵循上述编译过程的写入顺序。整体结构如下图所示： （图片来自互联网） arsc 文件的由若干 chunk 结构组成，所有 chunk 在 android 源码中的 ResourceTypes.h 头文件中均有定义，路径为 frameworks\\base\\include\\utils\\ResourceTypes.h。 对于不同 android 版本的 ResourceTypes.h 头文件，为了保证向下兼容性，所以其定义的 chunk 结构相同，不过高版本相对于低版本可能增加了一些配置的常量，例如适配高分辨率设备的 xxhdpi，xxxhdpi 维度选项。 每个 chunk 都会包含一个基础描述类型的对象，它的原始定义如下： 123456789struct ResChunk_header{ /* Chunk 类型 */ uint16_t type; /* Chunk 头部大小 */ uint16_t headerSize; /* Chunk 大小 */ uint32_t size;}; 其中类型 type 的值定义如下： 1234567891011121314151617181920212223enum { RES_NULL_TYPE = 0x0000, RES_STRING_POOL_TYPE = 0x0001, RES_TABLE_TYPE = 0x0002, RES_XML_TYPE = 0x0003, // Chunk types in RES_XML_TYPE RES_XML_FIRST_CHUNK_TYPE = 0x0100, RES_XML_START_NAMESPACE_TYPE= 0x0100, RES_XML_END_NAMESPACE_TYPE = 0x0101, RES_XML_START_ELEMENT_TYPE = 0x0102, RES_XML_END_ELEMENT_TYPE = 0x0103, RES_XML_CDATA_TYPE = 0x0104, RES_XML_LAST_CHUNK_TYPE = 0x017f, // This contains a uint32_t array mapping strings in the string // pool back to resource identifiers. It is optional. RES_XML_RESOURCE_MAP_TYPE = 0x0180, // Chunk types in RES_TABLE_TYPE RES_TABLE_PACKAGE_TYPE = 0x0200, RES_TABLE_TYPE_TYPE = 0x0201, RES_TABLE_TYPE_SPEC_TYPE = 0x0202}; 它表示每种 chunk 的类型，类似于标识文件类型的魔数，而 chunk 大小 size 则表示此 chunk 的容量。 下面开始对 arsc 文件的结构进行解析，这里使用 java 语言进行解析，为了方便，对于 ResourceTypes.h 中的类型，在 java 中都应该定义对应的类，例如基础描述结构体 ResChunk_header 使用 java 定义如下： 1234567891011/** * 资源表 Chunk 基础描述结构。 */public class ResChunkHeader { /** Chunk 类型 */ public short type; /** Chunk 头部大小 */ public short headerSize; /** Chunk 大小 */ public int size;} arsc 文件解析为了便于解析，这里使用了我自己写的工具类，参考这里的简介： ObjectIO。 解析方法针对上述 arsc 文件结构，采用如下方式进行解析： 定义指针变量标识当前解析的字节位置，每解析完一个 chunk 则向下移动指针 chunk 的大小。 采用循环解析的方式，通过 chunk 的 type 判断将要解析哪种 chunk，解析对应的结构。 这里定义了 ArscParser 解析器，mIndex 为指针变量，parse(ObjectIO objectIO) 为解析子方法。 1234567891011121314151617181920212223242526public class ArscParser { private int mIndex; ... private void parse(ObjectIO objectIO) { // 是否到达文件底部。 while (!objectIO.isEof(mIndex)) { // 获取将要解析的 chunk 头部信息。 ResChunkHeader header = objectIO.read(ResChunkHeader.class, mIndex); // 根据类型解析对应格式。 switch (header.type) { case ResourceTypes.RES_TABLE_TYPE: ... break; case ResourceTypes.RES_STRING_POOL_TYPE: ... break; case ResourceTypes.RES_TABLE_PACKAGE_TYPE: ... break; case ResourceTypes.RES_TABLE_TYPE_SPEC_TYPE: ... break; case ResourceTypes.RES_TABLE_TYPE_TYPE: ... break; default: } }} parse RES_TABLE_TYPE参考上面的 arsc 结构所示，首先解析的是资源表头部，它描述了整个 arsc 文件的大小，以及包含的资源包数量。 它的 type 值为 RES_TABLE_TYPE，对应的数据结构为 struct ResTable_header，java 对应的表示为： 1234567891011121314151617/** * 资源表头结构，对应 ResourceTypes.h 中定义的 ResTable_header。 */public class ResTableHeader implements Struct { /** * {@link ResChunkHeader#type} = {@link ResourceTypes#RES_TABLE_TYPE} * &lt;p&gt; * {@link ResChunkHeader#headerSize} = sizeOf(ResTableHeader.class) 表示头部大小。 * &lt;p&gt; * {@link ResChunkHeader#size} = 整个 resources.arsc 文件的大小。 */ public ResChunkHeader header; /** * 被编译的资源包数量。 */ public int packageCount;} 那么解析代码即： 12345678910111213// ArscParser.javaprivate void parse(ObjectIO objectIO) { ... ResChunkHeader header = objectIO.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_TABLE_TYPE: parseResTableType(objectIO); break; ... } ...} 12345678910// ArscParser.javaprivate void parseResTableType(ObjectIO objectIO) { final ResTableHeader tableType = objectIO.read(ResTableHeader.class, mIndex); System.out.println(&quot;resource table header:&quot;); System.out.println(tableType); // 向下移动资源表头部的大小。 mIndex += tableType.header.headerSize;} 测试广点通的 arsc 文件（resources_gdt1.arsc）打印结果如下： 12resource table header:{header={type=2(RES_TABLE_TYPE), headerSize=12, size=6384}, packageCount=1} parse RES_STRING_POOL_TYPE接下来是全局字符串池的解析，它包括如下几个部分： ResStringPool_header 字符串池头部，包含字符串池的信息，大小，数量，数组偏移等。 String Offset Array 字符串在字符串内容中的字节位置数组，32 位 int 类型。 Style Offset Array 字符串样式在字符串样式中的字节位置数组，32 位 int 类型。 String Content 字符串内容块。 Style Content 字符串样式块。 字符串池的头部使用 struct ResStringPool_header 数据结构描述，java 表示为： 1234567891011121314151617181920212223242526/** * 字符串池头部。 */public class ResStringPoolHeader implements Struct { public static final int SORTED_FLAG = 1; public static final int UTF8_FLAG = 1 &lt;&lt; 8; /** * {@link ResChunkHeader#type} = {@link ResourceTypes#RES_STRING_POOL_TYPE} * &lt;p&gt; * {@link ResChunkHeader#headerSize} = sizeOf(ResStringPoolHeader.class) 表示头部大小。 * &lt;p&gt; * {@link ResChunkHeader#size} = 整个字符串 Chunk 的大小，包括 headerSize 的大小。 */ public ResChunkHeader header; /** 字符串的数量 */ public int stringCount; /** 字符串样式的数量 */ public int styleCount; /** 0, SORTED_FLAG, UTF8_FLAG 它们的组合值 */ public int flags; /** 字符串内容块相对于其头部的距离 */ public int stringStart; /** 字符串样式块相对于其头部的距离 */ public int styleStart;} 其中 flags 包含 UTF8_FLAG 表示字符串格式为 utf8， SORTED_FLAG 表示已排序。 字符串的偏移数组使用 struct ResStringPool_ref 数据结构描述，java 表示为： 1234567/** * 字符串在字符串内容块中的字节偏移。 */public class ResStringPoolRef implements Struct{ /** 字符串在字符串池中的索引 */ public int index;} 字符串样式则使用 struct ResStringPool_span 数据结构描述，java 表示为： 12345678910111213/** * 字符串样式块中的字符串样式信息。 */public class ResStringPoolSpan implements Struct{ public static final int END = 0xFFFFFFFF; /** 本样式在字符串内容块中的字节位置 */ public ResStringPoolRef name; /** 包含样式的字符串的第一个字符索引 */ public int firstChar; /** 包含样式的字符串的最后一个字符索引 */ public int lastChar;} 其中 name 表示字符串样式本身字符串的索引，比如 &lt;b&gt; 样式本身的字符串为 b，即为 b 在字符串池中的索引。 firstChar 和 lastChar 则为具有样式的字符串的中字符串首位的索引，例如 he&lt;b&gt;ll&lt;/b&gt;o，则为 2 和 3。 字符串样式块和字符串内容块是一一对应的，就是说第一个字符串的样式对应第一个字符串样式块中的样式，如果对应的字符串中有不具有样式的字符串，则对应的 ResStringPool_span 的 name 为 0xFFFFFFFF，起占位的作用。 解析过程如下： 首先解析 ResStringPool_header，其中包含字符串和样式池的信息。 通过 header 中 stringCount（字符串数量） 和 styleContent（样式数量）解析出字符串和样式偏移数组。 通过 header 中的 stringStart 找到字符串块的起始字节位置，结合字符串偏移数组解析字符串内容。 通过 header 中的 styleStart 找到样式块的起始字节位置，结合样式偏移数组解析样式内容。 需要注意的是每个字符串的前两个字节表示这个字符串的长度，末尾则为结束符 0。 下面是解析代码： 12345678910111213// ArscParser.javaprivate void parse(ObjectIO objectIO) { ... ResChunkHeader header = objectIO.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_STRING_POOL_TYPE: parseStringPool(objectIO); break; ... } ...} 1234567891011121314151617181920212223242526272829303132333435363738394041424344// ArscParser.java...private void parseStringPool(ObjectIO objectIO) throws Exception { final long stringPoolIndex = mIndex; ResStringPoolHeader stringPoolHeader = objectIO.read(ResStringPoolHeader.class, stringPoolIndex); System.out.println(&quot;string pool header:&quot;); System.out.println(stringPoolHeader); StringPoolChunkParser stringPoolChunkParser = new StringPoolChunkParser(); stringPoolChunkParser.parseStringPoolChunk(objectIO, stringPoolHeader, stringPoolIndex); System.out.println(); System.out.println(&quot;string index array:&quot;); System.out.println(Arrays.toString(stringPoolChunkParser.getStringIndexArray())); System.out.println(); System.out.println(&quot;style index array:&quot;); System.out.println(Arrays.toString(stringPoolChunkParser.getStyleIndexArray())); stringPool = stringPoolChunkParser.getStringPool(); System.out.println(); System.out.println(&quot;string pool:&quot;); System.out.println(Arrays.toString(stringPool)); System.out.println(); System.out.println(&quot;style pool:&quot;); final List&lt;ResStringPoolSpan&gt;[] stylePool = stringPoolChunkParser.getStylePool(); System.out.println(Arrays.toString(stylePool)); System.out.println(); System.out.println(&quot;style detail:&quot;); for (List&lt;ResStringPoolSpan&gt; spans : stylePool) { System.out.println(&quot;---------&quot;); for (ResStringPoolSpan span : spans) { System.out.println(stringPool[span.name.index]); } } // 向下移动字符串池的大小。 mIndex += stringPoolHeader.header.size;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// StringPoolChunkParser.javapublic class StringPoolChunkParser { private ResStringPoolRef[] stringIndexArray; private ResStringPoolRef[] styleIndexArray; private String[] stringPool; private List&lt;ResStringPoolSpan&gt;[] stylePool; private ResStringPoolRef[] parseStringIndexArray(ObjectIO objectIO, ResStringPoolHeader header, long index) throws IOException { stringIndexArray = new ResStringPoolRef[header.stringCount]; long start = index; final int resStringPoolRefSize = ObjectIO.sizeOf(ResStringPoolRef.class); for (int i = 0; i &lt; header.stringCount; i++) { stringIndexArray[i] = objectIO.read(ResStringPoolRef.class, start); start += resStringPoolRefSize; } return stringIndexArray; } private ResStringPoolRef[] parseStyleIndexArray(ObjectIO objectIO, ResStringPoolHeader header, long index) throws IOException { styleIndexArray = new ResStringPoolRef[header.styleCount]; long start = index; final int resStringPoolRefSize = ObjectIO.sizeOf(ResStringPoolRef.class); for (int i = 0; i &lt; header.styleCount; i++) { styleIndexArray[i] = objectIO.read(ResStringPoolRef.class, start); start += resStringPoolRefSize; } return styleIndexArray; } private static int parseStringLength(byte[] b) { return b[1] &amp; 0x7F; } private String[] parseStringPool(ObjectIO objectIO, ResStringPoolHeader header, long stringPoolIndex) throws IOException { String[] stringPool = new String[header.stringCount]; for (int i = 0; i &lt; header.stringCount; i++) { final long index = stringPoolIndex + stringIndexArray[i].index; final int parseStringLength = parseStringLength(objectIO.readBytes(index, Short.BYTES)); // 经过测试，发现 flags 为0 时，字符串每个字符间会间隔一个空白符，长度变为 2 倍。 final int stringLength = header.flags == 0 ? parseStringLength * 2 : parseStringLength; // trim 去除多余空白符。 stringPool[i] = Formatter.trim(new String(objectIO.readBytes(index + Short.BYTES, stringLength), 0, stringLength, StandardCharsets.UTF_8)); } return stringPool; } private List&lt;ResStringPoolSpan&gt;[] parseStylePool(ObjectIO objectIO, ResStringPoolHeader header, long stylePoolIndex) throws IOException { @SuppressWarnings(&quot;unchecked&quot;) List&lt;ResStringPoolSpan&gt;[] stylePool = new List[header.styleCount]; for (int i = 0; i &lt; header.styleCount; i++) { final long index = stylePoolIndex + styleIndexArray[i].index; int end = 0; long littleIndex = index; List&lt;ResStringPoolSpan&gt; stringPoolSpans = new ArrayList&lt;&gt;(); while (end != ResStringPoolSpan.END) { ResStringPoolSpan stringPoolSpan = objectIO.read(ResStringPoolSpan.class, littleIndex); stringPoolSpans.add(stringPoolSpan); littleIndex += ObjectIO.sizeOf(ResStringPoolSpan.class); end = objectIO.readInt(littleIndex); } stylePool[i] = stringPoolSpans; } return stylePool; } public void parseStringPoolChunk(ObjectIO objectIO, ResStringPoolHeader header, long stringPoolHeaderIndex) throws IOException { // parse string index array. final long stringIndexArrayIndex = stringPoolHeaderIndex + ObjectIO.sizeOf(ResStringPoolHeader.class); stringIndexArray = header.stringCount == 0 ? new ResStringPoolRef[0] : parseStringIndexArray(objectIO, header, stringIndexArrayIndex); final long styleIndexArrayIndex = stringIndexArrayIndex + header.stringCount * ObjectIO.sizeOf(ResStringPoolRef.class); styleIndexArray = header.styleCount == 0 ? new ResStringPoolRef[0] : parseStyleIndexArray(objectIO, header, styleIndexArrayIndex); // parse string pool. if (header.stringCount != 0) { final long stringPoolIndex = stringPoolHeaderIndex + header.stringStart; stringPool = parseStringPool(objectIO, header, stringPoolIndex); } else { stringPool = new String[0]; } // parse style pool. if (header.styleCount != 0) { final long stylePoolIndex = stringPoolHeaderIndex + header.styleStart; stylePool = parseStylePool(objectIO, header, stylePoolIndex); } else { //noinspection unchecked stylePool = new List[0]; } } public ResStringPoolRef[] getStringIndexArray() { return stringIndexArray; } public ResStringPoolRef[] getStyleIndexArray() { return styleIndexArray; } public String[] getStringPool() { return stringPool; } public List&lt;ResStringPoolSpan&gt;[] getStylePool() { return stylePool; }} 示例文件 resources_gdt1.arsc 的解析示例如下： 1234567891011121314string pool header:{header={type=1(RES_STRING_POOL_TYPE), headerSize=28, size=1220}, stringCount=42, styleCount=0, flags=256, stringStart=196, styleStart=0}string index array:[{index=0}, {index=25}, {index=52}, {index=78}, {index=110}, {index=135}, {index=181}, {index=205}, {index=240}, {index=278}, {index=315}, ... , {index=879}, {index=904}, {index=932}, {index=960}, {index=972}, {index=995}, {index=1010}]style index array: []string pool:[res/drawable/arrow.png, res/drawable/gdticon.png, res/drawable/gridbt.png, res/drawable/header_arrow.png, res/drawable/icon1.png, ... , 应用墙, CustomFeeds2Activity, 加载更多, TranspAct]style pool:[]style detail: 这个文件没有样式，换一个示例文件 resources_cm.arsc 文件的 style 内容示例如下： 12345678910111213141516171819style pool:[[{name={index=15915}, firstChar=13, lastChar=16}], [{name={index=15916}, firstChar=4, lastChar=7}, {name={index=15917}, firstChar=11, lastChar=14}], [{name={index=15916}, firstChar=4, lastChar=7}, {name={index=15917}, firstChar=11, lastChar=14}], [{name={index=15918}, firstChar=9, lastChar=12}], [{name={index=15919}, firstChar=66, lastChar=69}], [{name={index=15916}, firstChar=15, lastChar=26}, {name={index=15917}, firstChar=32, lastChar=45}]]style detail:---------g;id=app_name---------a;href=http://www.cmcm.com/protocol/cmbackup/terms-of-use.htmla;href=http://www.cmcm.com/protocol/cmbackup/privacy.html---------a;href=http://www.cmcm.com/protocol/cmbackup/terms-of-use.htmla;href=http://www.cmcm.com/protocol/cmbackup/privacy.html---------g;id=number---------g;id=string---------a;href=http://www.cmcm.com/protocol/cmbackup/terms-of-use.htmla;href=http://www.cmcm.com/protocol/cmbackup/privacy.html parse RES_TABLE_PACKAGE_TYPE下面是资源项元信息的解析，它包含如下几个部分： ResTable_package 资源项元信息头部，包括 Package ID，包名和资源项索引信息。 Type String Pool 资源类型字符串池，例如 drawable, color, xml, animator。 Key String Pool 资源名字符串池。 Type Specification Trunk 类型规范数据块，描述资源的配置信息。 Type Info Trunk 类型资源项数据块。 资源项元信息头部使用 struct ResTable_package 数据结构描述，使用 java 表示为： 12345678910111213141516171819202122232425262728293031323334/** * Package 资源项元信息头部。 */public class ResTablePackage implements Struct { /** * {@link ResChunkHeader#type} = {@link ResourceTypes#RES_TABLE_PACKAGE_TYPE} * &lt;p&gt; * {@link ResChunkHeader#headerSize} = sizeOf(ResTablePackage.class) 表示头部大小。 * &lt;p&gt; * {@link ResChunkHeader#size} = head.headerSize + 类型字符串资源池大小 + 类型规范名称字符串池大小 + * 类型规范数据块大小 + 数据项信息数据块大小。 */ public ResChunkHeader header; /** Package ID */ public int id; /** Package Name */ public char[] name = new char[128]; /** * 类型字符串资源池相对头部的偏移位置。 */ public int typeStrings; /** * 最后一个导出的 public 类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的大小。 */ public int lastPublicType; /** * 资源项名称字符串相对头部的偏移位置。 */ public int keyStrings; /** * 最后一个导出的 public 资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的大小。 */ public int lastPublicKey;} Type String Pool 和 Key String Pool 的结构和上面的全局字符串结构完全相同。 Type Specification Trunk 和 Type Info Trunk 的 chunk type 分别为 RES_TABLE_TYPE_SPEC_TYPE 和 RES_TABLE_TYPE_TYPE，将在下面的步骤进行解析。 那么元信息头部和两个字符串池的解析代码如下： 12345678910111213141516// ArscParser.javaprivate void parse(ObjectIO objectIO) { ... ResChunkHeader header = objectIO.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_STRING_POOL_TYPE: parseStringPool(objectIO); break; case ResourceTypes.RES_TABLE_PACKAGE_TYPE: parseTablePackageType(objectIO); break; ... } ...} 123456789101112// ArscParser.javaprivate void parseTablePackageType(ObjectIO objectIO) throws IOException { final long tablePackageIndex = mIndex; final ResTablePackage tablePackage = objectIO.read(ResTablePackage.class, tablePackageIndex); System.out.println(&quot;table package type:&quot;); System.out.println(tablePackage); // 向下移动资源表元信息头部的大小。 mIndex += tablePackage.header.headerSize;} 解析示例文件 resources_gdt1.arsc 的结果为： 123456789101112131415161718192021222324252627282930313233=== RES_TABLE_PACKAGE_TYPE ===:table package type:{header={type=512(RES_TABLE_PACKAGE_TYPE), headerSize=288, size=5152}, id=0x7f000000, name=com.qq.e.demo, typeStrings=0, lastPublicType=0, keyStrings=0, lastPublicKey=0}=== RES_STRING_POOL_TYPE (Type String Pool) ===:string pool header:{header={type=1(RES_STRING_POOL_TYPE), headerSize=28, size=136}, stringCount=9, styleCount=0, flags=256, stringStart=64, styleStart=0}string index array:[{index=0}, {index=7}, {index=18}, {index=27}, {index=35}, {index=43}, {index=52}, {index=60}, {index=67}]style index array: []string pool:[attr, drawable, layout, color, dimen, string, style, menu, id]style pool: []style detail:=== RES_STRING_POOL_TYPE (Key String Pool) ===:string pool header:{header={type=1(RES_STRING_POOL_TYPE), headerSize=28, size=1720}, stringCount=76, styleCount=0, flags=256, stringStart=332, styleStart=0}string index array:[{index=0}, {index=17}, {index=40}, {index=48}, {index=58}, {index=67}, {index=82}, {index=90}, {index=117}, {index=124}, {index=142}, {index=165}, {index=187}, {index=215}, {index=236}, {index=257}, {index=275}, {index=292}, {index=308}, {index=337}, {index=364}, {index=375}, ... , {index=1214}, {index=1234}, {index=1249}, {index=1265}, {index=1280}, {index=1301}, {index=1312}, {index=1324}, {index=1336}, {index=1350}, {index=1363}, {index=1373}]style index array: []string pool:[buttonBarStyle, buttonBarButtonStyle, arrow, gdticon, gridbt, header_arrow, icon1, listview_item_background, logo, main_background, activity_banner_demo, activity_fullscreen, activity_gdtnativead_demo, activity_list_view, activity_main_demo, headercontainer, nativelistitem, ... , showBannerInListHeaderButton, destoryBtn, splashcontainer, btn_refresh, ad_container, list, showBannerButton, showInterstitialAdButton, showAppWallButton, splashButton, gdtnativeAdbt, imageButton1, headframecontainer, img_logo, text_name, text_desc, text_status, img_poster, divider, btn_download]style pool: []style detail: parse RES_TABLE_TYPE_SPEC_TYPE类型规范数据块为了描述资源项的配置差异性，通过它可以了解到每类资源的配置情况。 类型规范数据块由 ResTable_typeSpec 数据结构描述，java 表示为： 12345678910111213141516171819202122/** * 类型规范数据块。 */public class ResTableTypeSpec implements Struct { private static final int SPEC_PUBLIC = 0x40000000; /** * {@link ResChunkHeader#type} = {@link ResourceTypes#RES_TABLE_TYPE_SPEC_TYPE} * &lt;p&gt; * {@link ResChunkHeader#headerSize} = sizeOf(ResTableTypeSpec.class) 表示头部大小。 * &lt;p&gt; * {@link ResChunkHeader#size} = header.headerSize + {@link Integer#BYTES} * {@link #entryCount} */ public ResChunkHeader header; /** 资源 Type ID */ public byte id; /** 0，保留 */ public byte res0; /** 0，保留 */ public short res1; /** 本类型的资源项个数，即名称相同的资源项的个数 */ public int entryCount;} 其中的 id 字段表示资源的类型 id，res0 和 res1 为固定的 0，entryCount 则为资源项的个数，在 ResTable_typeSpec 之后会有一个 int 型数组，来记录在哪些配置发生变化后，需要重新加载该资源。 配置项在 ResourceTypes.h 中有定义： 123456789101112131415161718enum { CONFIG_MCC = ACONFIGURATION_MCC, CONFIG_MNC = ACONFIGURATION_MNC, CONFIG_LOCALE = ACONFIGURATION_LOCALE, CONFIG_TOUCHSCREEN = ACONFIGURATION_TOUCHSCREEN, CONFIG_KEYBOARD = ACONFIGURATION_KEYBOARD, CONFIG_KEYBOARD_HIDDEN = ACONFIGURATION_KEYBOARD_HIDDEN, CONFIG_NAVIGATION = ACONFIGURATION_NAVIGATION, CONFIG_ORIENTATION = ACONFIGURATION_ORIENTATION, CONFIG_DENSITY = ACONFIGURATION_DENSITY, CONFIG_SCREEN_SIZE = ACONFIGURATION_SCREEN_SIZE, CONFIG_SMALLEST_SCREEN_SIZE = ACONFIGURATION_SMALLEST_SCREEN_SIZE, CONFIG_VERSION = ACONFIGURATION_VERSION, CONFIG_SCREEN_LAYOUT = ACONFIGURATION_SCREEN_LAYOUT, CONFIG_UI_MODE = ACONFIGURATION_UI_MODE, CONFIG_LAYOUTDIR = ACONFIGURATION_LAYOUTDIR, CONFIG_SCREEN_ROUND = ACONFIGURATION_SCREEN_ROUND,}; 下面是解析过程： 12345678910111213// ArscParser.javaprivate void parse(ObjectIO objectIO) { ... ResChunkHeader header = objectIO.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_TABLE_TYPE_SPEC_TYPE: parseTableTypeSpecType(objectIO); break; ... } ...} 123456789101112131415161718// ArscParser.javaprivate void parseTableTypeSpecType(ObjectIO objectIO) throws IOException { final long typeSpecIndex = mIndex; ResTableTypeSpec tableTypeSpec = objectIO.read(ResTableTypeSpec.class, typeSpecIndex); System.out.println(&quot;table type spec type:&quot;); System.out.println(tableTypeSpec); int[] entryArray = TableTypeChunkParser.parseSpecEntryArray(objectIO, tableTypeSpec, typeSpecIndex); System.out.println(); System.out.println(&quot;table type spec type entry array:&quot;); System.out.println(Arrays.toString(entryArray)); // 向下移动资源表类型规范内容的大小。 mIndex += tableTypeSpec.header.size;} 12345678910111213// TableTypeChunkParser.javapublic static int[] parseSpecEntryArray(ObjectIO objectIO, ResTableTypeSpec tableTypeSpec, long typeSpecIndex) throws IOException { int[] entryArray = new int[tableTypeSpec.entryCount]; long index = typeSpecIndex + tableTypeSpec.header.headerSize; for (int i = 0; i &lt; entryArray.length; i++) { entryArray[i] = objectIO.readInt(index); index += Integer.BYTES; } return entryArray;} 解析示例文件 resource_gdt1.arsc 的结构： 12345table type spec type:{header={type=514(RES_TABLE_TYPE_SPEC_TYPE), headerSize=16, size=24}, id=0x01, res0=0, res1=0, entryCount=2}table type spec type entry array:[0, 0] parse RES_TABLE_TYPE_TYPE最后是类型资源项数据块，它用来描述资源项的具体信息，通过它可以了解每一个资源项名称、值和配置等信息。类型资源项数据是按照类型和配置来组织的，也就是说，一个具有 N 个配置的类型一共对应有 N 个类型资源项数据块。 类型资源项数据块使用 ResTable_type 数据结构描述，java 表示为： 123456789101112131415161718192021222324252627/** * 类型资源项数据块。 */public class ResTableType implements Struct { public static final int NO_ENTRY = 0xFFFFFFFF; /** * {@link ResChunkHeader#type} = {@link ResourceTypes#RES_TABLE_TYPE_TYPE} * &lt;p&gt; * {@link ResChunkHeader#headerSize} = sizeOf(ResTableType.class) 表示头部大小。 * &lt;p&gt; * {@link ResChunkHeader#size} = header.headerSize + {@link Integer#BYTES} * {@link #entryCount} */ public ResChunkHeader header; /** 资源 Type ID */ public byte id; /** 0，保留 */ public byte res0; /** 0，保留 */ public short res1; /** 本类型的资源项个数，即名称相同的资源项的个数 */ public int entryCount; /** 资源项数据块相对头部的偏移值 */ public int entriesStart; /** 描述配置信息 */ public ResTableConfig tableConfig;} 其中 entryCount 表示资源项的数量，entriesStart 表示数据块的其实位置字节偏移。 ResTableConfig 描述了资源的配置信息，内部由多个 Union 联合体构成，由于代码过长，所以具体结构可参考项目源码。 每个资源项通过 ResTable_entry 数据结构描述，java 表示为： 12345678910111213141516171819/** * 资源项。 */public class ResTableEntry implements Struct { public static final int FLAG_COMPLEX = 0x0001; public static final int FLAG_PUBLIC = 0x0002; /** {@link #BYTES} 资源项头部大小 */ public short size; /** * 资源项标志位。如果是一个 Bag 资源项，那么 FLAG_COMPLEX 位就等于 1，并且在 ResTable_entry 后面跟有一个 ResTable_map 数组， * 否则的话，在 ResTable_entry {@link ResTableEntry} 后面跟的是一个 Res_value。如果是一个可以被引用的资源项，那么 FLAG_PUBLIC 位就等于1 */ public short flags; /** * 资源项名称在资源项名称字符串资源池的索引。 */ public ResStringPoolRef key;} 如果其中的 flags 的 FLAG_COMPLEX 位为 1，那么这个 struct ResTable_entry 则是一个 struct ResTable_map_entry 类型，然后下面就会跟一个 struct ResTable_map 的数组。 struct ResTable_map_entry 是 struct ResTable_entry 的子结构类型，java 表示为： 12345678public class ResTableMapEntry extends ResTableEntry { /** * 指向父 ResTable_map_entry 的资源 ID，如果没有父 ResTable_map_entry，则等于 0。 */ public ResTableRef parent; /** bag 项的个数。 */ public int count;} ResTable_map 的 java 表示为： 123456public class ResTableMap implements Struct { /** 引用资源地址 */ public ResTableRef name; /** 资源值 */ public ResValue value;} ResValue 对应数据结构 struct Res_value，它表示资源的具体数值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class ResValue implements Struct { /** ResValue 值大小 */ public short size; /** 0, 保留 */ public byte res0; // 数据类型取值。 public static final short TYPE_NULL = 0x00; public static final short TYPE_REFERENCE = 0x01; public static final short TYPE_ATTRIBUTE = 0x02; public static final short TYPE_STRING = 0x03; public static final short TYPE_FLOAT = 0x04; public static final short TYPE_DIMENSION = 0x05; public static final short TYPE_FRACTION = 0x06; public static final short TYPE_DYNAMIC_REFERENCE = 0x07; public static final short TYPE_FIRST_INT = 0x10; public static final short TYPE_INT_DEC = 0x10; public static final short TYPE_INT_HEX = 0x11; public static final short TYPE_INT_BOOLEAN = 0x12; public static final short TYPE_FIRST_COLOR_INT = 0x1c; public static final short TYPE_INT_COLOR_ARGB8 = 0x1c; public static final short TYPE_INT_COLOR_RGB8 = 0x1d; public static final short TYPE_INT_COLOR_ARGB4 = 0x1e; public static final short TYPE_INT_COLOR_RGB4 = 0x1f; public static final short TYPE_LAST_COLOR_INT = 0x1f; public static final short TYPE_LAST_INT = 0x1f; /** 数据类型 */ public byte dataType; public static final int COMPLEX_UNIT_SHIFT = 0; public static final int COMPLEX_UNIT_MASK = 0xf; // 数据类型描述。 public static final int COMPLEX_UNIT_PX = 0; public static final int COMPLEX_UNIT_DIP = 1; public static final int COMPLEX_UNIT_SP = 2; public static final int COMPLEX_UNIT_PT = 3; public static final int COMPLEX_UNIT_IN = 4; public static final int COMPLEX_UNIT_MM = 5; public static final int COMPLEX_UNIT_FRACTION = 0; public static final int COMPLEX_UNIT_FRACTION_PARENT = 1; public static final int COMPLEX_RADIX_SHIFT = 4; public static final int COMPLEX_RADIX_MASK = 0x3; public static final int COMPLEX_RADIX_23p0 = 0; public static final int COMPLEX_RADIX_16p7 = 1; public static final int COMPLEX_RADIX_8p15 = 2; public static final int COMPLEX_RADIX_0p23 = 3; public static final int COMPLEX_MANTISSA_SHIFT = 8; public static final int COMPLEX_MANTISSA_MASK = 0xffffff; public static final int DATA_NULL_UNDEFINED = 0; public static final int DATA_NULL_EMPTY = 1; /** 数据 */ public int data; // 将 dataType 翻译为字符串。 private String dataTypeStr() { switch (dataType) { case TYPE_NULL: return &quot;TYPE_NULL&quot;; case TYPE_REFERENCE: return &quot;TYPE_REFERENCE&quot;; case TYPE_ATTRIBUTE: return &quot;TYPE_ATTRIBUTE&quot;; case TYPE_STRING: return &quot;TYPE_STRING&quot;; case TYPE_FLOAT: return &quot;TYPE_FLOAT&quot;; case TYPE_DIMENSION: return &quot;TYPE_DIMENSION&quot;; case TYPE_FRACTION: return &quot;TYPE_FRACTION&quot;; case TYPE_DYNAMIC_REFERENCE: return &quot;TYPE_DYNAMIC_REFERENCE&quot;; // case TYPE_FIRST_INT: return &quot;TYPE_FIRST_INT&quot;; case TYPE_INT_DEC: return &quot;TYPE_INT_DEC&quot;; case TYPE_INT_HEX: return &quot;TYPE_INT_HEX&quot;; case TYPE_INT_BOOLEAN: return &quot;TYPE_INT_BOOLEAN&quot;; // case TYPE_FIRST_COLOR_INT: return &quot;TYPE_FIRST_COLOR_INT&quot;; case TYPE_INT_COLOR_ARGB8: return &quot;TYPE_INT_COLOR_ARGB8&quot;; case TYPE_INT_COLOR_RGB8: return &quot;TYPE_INT_COLOR_RGB8&quot;; case TYPE_INT_COLOR_ARGB4: return &quot;TYPE_INT_COLOR_ARGB4&quot;; case TYPE_INT_COLOR_RGB4: return &quot;TYPE_INT_COLOR_RGB4&quot;; // case TYPE_LAST_COLOR_INT: return &quot;TYPE_LAST_COLOR_INT&quot;; // case TYPE_LAST_INT: return &quot;TYPE_LAST_INT&quot;; default: return &quot;&quot; + dataType; } } // 将值翻译为对应类型的 public String dataStr() { switch (dataType) { case TYPE_NULL: return &quot;null&quot;; case TYPE_REFERENCE: return &quot;@&quot; + Formatter.toHex(Formatter.fromInt(data, true)); case TYPE_ATTRIBUTE: return &quot;@:id/&quot; + Formatter.toHex(Formatter.fromInt(data, true)); case TYPE_STRING: return &quot;stringPool[&quot; + data + ']'; case TYPE_FLOAT: return String.valueOf(data); case TYPE_DIMENSION: int complex = data &amp; (COMPLEX_UNIT_MASK &lt;&lt; COMPLEX_UNIT_SHIFT); switch (complex) { case COMPLEX_UNIT_PX: return data + &quot;px&quot;; case COMPLEX_UNIT_DIP: return data + &quot;dip&quot;; case COMPLEX_UNIT_SP: return data + &quot;sp&quot;; case COMPLEX_UNIT_PT: return data + &quot;pt&quot;; case COMPLEX_UNIT_IN: return data + &quot;in&quot;; case COMPLEX_UNIT_MM: return data + &quot;mm&quot;; default: return data + &quot;(dimension)&quot;; } case TYPE_FRACTION: return data + &quot;(fraction)&quot;; case TYPE_DYNAMIC_REFERENCE: return data + &quot;(dynamic_reference)&quot;; // case TYPE_FIRST_INT: return &quot;TYPE_FIRST_INT&quot;; case TYPE_INT_DEC: return String.valueOf(data); case TYPE_INT_HEX: return Formatter.toHex(Formatter.fromInt(data, true)); case TYPE_INT_BOOLEAN: return data == 0 ? &quot;false&quot; : &quot;true&quot;; // case TYPE_FIRST_COLOR_INT: return &quot;TYPE_FIRST_COLOR_INT&quot;; case TYPE_INT_COLOR_ARGB8: return data + &quot;(argb8)&quot;; case TYPE_INT_COLOR_RGB8: return data + &quot;(rgb8)&quot;; case TYPE_INT_COLOR_ARGB4: return data + &quot;(argb4)&quot;; case TYPE_INT_COLOR_RGB4: return data + &quot;(rgb4)&quot;; // case TYPE_LAST_COLOR_INT: return &quot;TYPE_LAST_COLOR_INT&quot;; // case TYPE_LAST_INT: return &quot;TYPE_LAST_INT&quot;; default: return Formatter.toHex(Formatter.fromInt(data, true)); } }} 解析过程： 12345678910111213// ArscParser.javaprivate void parse(ObjectIO objectIO) { ... ResChunkHeader header = objectIO.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_TABLE_TYPE_TYPE: parseTableTypeType(arsc, header); break; ... } ...} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ArscParser.javaprivate void parseTableTypeType(ObjectIO objectIO) throws IOException { final long tableTypeIndex = mIndex; final ResTableType tableType = objectIO.read(ResTableType.class, tableTypeIndex); System.out.println(&quot;table type type:&quot;); System.out.println(tableType); int[] offsetArray = TableTypeChunkParser.parseTypeOffsetArray(objectIO, tableType, tableTypeIndex); System.out.println(); System.out.println(&quot;offset array:&quot;); System.out.println(Arrays.toString(offsetArray)); final long tableEntryIndex = tableTypeIndex + tableType.entriesStart; for (int i = 0; i &lt; offsetArray.length; i++) { final long entryIndex = offsetArray[i] + tableEntryIndex; final ResTableEntry tableEntry = objectIO.read(ResTableEntry.class, entryIndex); System.out.println(); System.out.println(&quot;table type type entry &quot; + i + &quot;:&quot;); System.out.println(&quot;header: &quot; + tableEntry); System.out.println(&quot;entry name: &quot; + typeStringPool[tableEntry.key.index]); if (tableEntry.flags == ResTableEntry.FLAG_COMPLEX) { // parse ResTable_map final ResTableMapEntry tableMapEntry = objectIO.read(ResTableMapEntry.class, entryIndex); System.out.println(tableMapEntry); int index = 0; for (int j = 0; j &lt; tableMapEntry.count; j++) { final long tableMapIndex = index + entryIndex + tableMapEntry.size; ResTableMap tableMap = objectIO.read(ResTableMap.class, tableMapIndex); System.out.println(&quot;table map &quot; + j + &quot;:&quot;); System.out.println(tableMap); index += ObjectIO.sizeOf(ResTableMap.class); } } else { // parse Res_value final int entrySize = ObjectIO.sizeOf(ResTableEntry.class); final ResValue value = objectIO.read(ResValue.class, entryIndex + entrySize); System.out.println(value); } } mIndex = objectIO.size();} 12345678910111213// TableTypeChunkParser.javapublic static int[] parseTypeOffsetArray(ObjectIO objectIO, ResTableType tableType, long typeIndex) throws IOException { int[] entryArray = new int[tableType.entryCount]; long index = typeIndex + tableType.header.headerSize; for (int i = 0; i &lt; entryArray.length; i++) { entryArray[i] = objectIO.readInt(index); index += Integer.BYTES; } return entryArray;} 示例文件 resources_gdt1.arsc 的解析结果为： 12345678910111213141516171819table type type:{header={type=513(RES_TABLE_TYPE_TYPE), headerSize=68, size=132}, id=0x01, res0=0, res1=0, entryCount=2, entriesStart=76, config={size=48, localeScript= , localeVariant= , mobile={data=Struct{mcc=0, mnc=0}, imsi=0}, locale={data={language= , country= }, locale=0}, screenType={data={orientation=0, touchscreen=0, density=0}, screenType=0}, input={data={keyboard=0, navigation=0, inputFlags=0, inputPad0=0}, input=0}, screenSize={data={screenWidth=0, screenHeight=0}, screenSize=0}, version={data={sdkVersion=0, minorVersion=0}, screenSize=0}, screenConfig={data={screenLayout=0, uiMode=0, screenConfigPad1=0, screenConfigPad2=0}, screenConfig=0}, screenSizeDp={data={screenWidth=0, screenHeight=0}, screenSizeDp=0}, screenConfig2={data={screenLayout2=0, screenConfigPad1=0, screenConfigPad2=0}, screenConfig2=0}}}offset array:[0, 28]table type type entry 0:header: {size=16, flags=1, key={index=0}}entry name: buttonBarStyle{parent={ident=0x00000000}, count=1, size=16, flags=1, key={index=0}}table map 0:{name={ident=0x01000000}, value={size=8, res0=0, dataType=TYPE_INT_DEC, data=1}}table type type entry 1:header: {size=16, flags=1, key={index=1}}entry name: buttonBarButtonStyle{parent={ident=0x00000000}, count=1, size=16, flags=1, key={index=1}}table map 0:{name={ident=0x01000000}, value={size=8, res0=0, dataType=TYPE_INT_DEC, data=1}} 源码ArscParser 参考 Android应用程序资源的编译和打包过程分析 https://github.com/fourbrother/parse_androidarsc","link":"/2019/02/14/android-arsc-%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"},{"title":"Android Binder 设计分析","text":"前言以下 Binder 设计部分整理至 universus 的博客 Android Bander设计与实现 - 设计篇。 Binder 的优势简介Binder 是 Android 系统中的进程间通信方式之一，它是基于 Client-Server 的通信方式。相较于 Linux 系统中的其他进程间通信方式而言，它具有传输效率高、开销小的特点。 Linux IPCLinux 的进程间通信方式包括管道、system V IPC、socket、消息队列等。 Socket 是一个通用的进程间通信接口，传输效率低，开销大，主要用在跨网络的进程间通信和本机的进程间通信。 管道和消息队列采用存储-转发的方式，首先将数据从发送方复制到内核缓冲区，然后再复制到接收方。 共享内存无需拷贝数据，但是需要复制的控制，难以使用。 IPC 对比各个 IPC 方式的拷贝次数： 通信方式 拷贝次数 共享内存 0 Binder 1 Socker/管道/消息队列 2 Binder 特点相较于以上 Linux 进程间通信方式，针对 Android 设计的 Binder 通信具有如下特点： Binder 采用共享内存的方式，将数据缓存同时映射到接收方和内核空间，发送方只需要拷贝一次数据即可完成通信。 Binder 驱动在转发数据的过程中在通过内核向数据中写入进程的 UID 和 PID，使接收端可验证发送端身份，保证通信安全性，而传统的 Linux IPC 方式则无法通过这种方式鉴别发送方身份。 Binder 使用了面向对象的思想来描述 Server 端的访问接入点和 Client 端的入口，Binder 是一个实体位于 Server 端的对象，它提供了一套访问 Server 端的方法，类似于类的成员方法，Client 端的入口则作为这个 Binder 对象的“句柄”，此时 Client 端访问 Server 端就像调用对象的方法一样容易，同时 Client 端的本地“句柄”对象也可以在进程间相互传递，使各处都可访问同一个 Server，Binder 弱化了进程间通信过程，使整个系统仿佛运行在面向对象的程序中。 总结Binder 作为 Android 系统的主要的进程间通信方式，保证性能的同时，还兼顾了通信安全性和使用的便捷性。 基于 Client-Server 的方式，支持实名和匿名通信，是一种非常适合于便携式和嵌入式设备通信的 IPC 方式 。 Binder 通信模型Binder 通信框架定义了 4 个组件角色，Server，Client，ServiceManager 和 Binder 驱动。 其中 Binder 驱动运行于内核层，它负责实现进程间通信的核心功能，管理每个 Server 端的 Binder 实体对象，以及 Client 中的 Binder 引用，Client 表示向 Server 端发起请求的客户端，Server 作为服务端负责处理 Client 端的请求，ServiceManager 负责管理 Server 的注册和申请，类似 DNS 服务器中注册服务器的域名，和浏览器向 DNS 服务器请求网站真实的 IP 地址的过程。 Binder 驱动 Binder 驱动是一个运行在内核态的标准设备驱动，但是和硬件没有关系，它的实现遵循标准驱动的实现。 Binder 驱动提供了 open()，mmap()，poll()，ioctl() 等标准文件操作，它以字符驱动设备中的 misc 设备注册在 /dev/ 下，用户通过/dev/binder 访问该它。 Binder 驱动负责进程之间 Binder 通信的建立，Binder 在进程间的建立，Binder 在进程间的传递，Binder 引用技术管理，数据包在进程间的传递等底层支持。 Binder 驱动使用 ioctl() 接口实现，它可实现一次调用，读写操作依次同时执行，相较于 read() 和 write() 更加灵活方便。 ServiceManager 和 Server ServiceManager 建立 Binder 名字和 Binder 实体的映射，Client 可通过字符形式的 Binder 名字请求 Binder 的引用。 Server 创建 Binder 实体后，通过驱动将 Binder 名字及实体通过 Binder 驱动发至 ServiceManager 请求注册，驱动在内核中创建对应此 Server 进程中 Binder 实体的对应节点，以及 ServiceManager 中对此 Binder 的引用，然后将 Binder 名字和引用通过数据包传送给 ServiceManager，此时 ServiceManager 将名字和 Binder 引用存入查找表中。 当 Server 向 ServiceManager 请求注册时，这个过程本身就需要进程间通信，需要获取 ServiceManager 中 Binder 实体的引用，由于 ServiceManager 本身负责管理 Binder 的注册和引用的分配，所以在此之前，ServiceManager 通过向驱动发送 BINDER_SET_CONTEXT_MGR 命令请求注册自身为 ServiceManager，当 Server 需要请求 ServiceManager 的 Binder 引用时，只要向驱动请求 0 号引用即可获得，所有 Server 都可通过 0 号引用通过驱动向 ServiceManager 发送注册请求。 对于 ServiceManager 来说，所有的 Server 都是 Client，只不过任务很单一，知识为了注册 Server。 ClientClient 使用 0 号引用通过驱动向 ServiceManager 发送 Binder 名字请求获取 Server 端 Binder 的引用，ServiceManager 此时将会从表中查询 Binder 引用然后通过驱动回复给 Client。此时 Binder 引用在 Client 和 ServiceManager 各存在一个。 BinderBinder 可分为实名 Binder 和匿名 Binder。 实名 Binder 所有将名字和引用注册到 ServiceManager 的 Binder 实体都是实名 Binder。 匿名 Binder 匿名 Binder 指没有在 ServiceManager 中注册名字的 Binder，当 Client 与 Server 建立连接时可将新创建的 Binder 传递给 Client，此时 Client 将和匿名 Binder 实现私密通道，第三方进程无法通过穷举获取匿名 Binder 的引用。 Binder 协议ioctlBinder 协议使用 ioctl(fd, cmd, arg) 函数实现，fd 为驱动的文件描述符，cmd 参数为命令，arg 为参数，每种 cmd 对应的 arg 结构也不同。当通过驱动进行通信时，首先使用 open 打开驱动文件，然后使用返回的文件描述符调用 ioctl 进行通信。 cmd 解释 参数 BINDER_WRITE_READ 向 Binder 发送读写命令，参数分为写和读两部分，如果 write_size 不为 0 则首先将 write_buffer 里的数据写入 Binder，其次 read_size 不为 0 再从 Binder 中读取数据存入 read_buffer 中，write_consumed 和 read_consumed 表示操作完成时 Binder 驱动实际发送的 struct binder_write_read{signed long write_size;signed long write_consumed;unsigned long write_buffer;signed long read_size;signed long read_consumed;unsigned long read_buffer;}; BINDER_SET_MAX_THREADS 告知 Binder 驱动接收方（Server 端）线程池的最大线程数，Client 告知 Server 端需要开辟多大的线程池为并发请求提供服务，为了让驱动发现线程数达到该值时不要再命令接收端启动新的线程。 int max_threads; BINDER_SET_CONTEXT_MGR 注册当前进程为 ServiceManager，直到当前 ServiceManager 调用 close()，系统中只能存在一个 ServiceManager。 - BINDER_THREAD_EXIT 通知 Binder 驱动当前线程退出，驱动会释放为参与 Binder 通信的相应线程建立的结构。 - BINDER_VERSION 获取 Binder 驱动的版本号。 - BINDER_WRITE_READ 写入BINDER_WRITE_READ 命令的数据写入格式为命令+数据，多条命令可连续存放，对应的命令后面写入对应的数据结构，最后将这段内存的指针赋给 binder_write_read 结构体的 write_buffer。 命令 解释 数据 BC_TRANSACTIONBC_REPLY 1. BC_TRANSACTION 用于 Client 端向 Server 端发送请求。2. BC_REPLY 用于 Server 端向 Client 回复数据。3. 命令后面接 binder_transaction_data 用于存放数据。 struct bindertransaction_data BC_ACQUIRE_RESULTBC_ATTEMPT_ACQUIRE 暂未实现 - BC_FREE_BUFFER 释放映射的内存空间，Binder 接收方通过 mmap 方法映射了一块内存，Binder 驱动使用这块内存，采用佳匹配算法实现接收数据缓存的动态分配和释放，满足并发请求对接收缓存区的需求。应用程序处理完这片数据后需要使用该命令释放缓存区，避免因为缓存区耗尽而无法接收新数据。 指向需要释放的缓存区的指针；指针位于收到的 Binder数据包中。 BC_INCREFS BC_ACQUIREBC_RELEASEBC_DECREFS 这组命令增加或减少 Binder 的引用计数，用以实现强指针或弱指针的功能。 32 位 Binder引用号。 BC_INCREFS_DONE BC_ACQUIRE_DONE 1. 第一次增加 Binder 实体引用计数时，驱动向 Binder 实体所在的进程发送 BR_INCREFS, BR_ACQUIRE 消息。2. Binder 实体所在的进程处理完毕回复 BC_INCREFS_DONE，BC_ACQUIRE_DONE。 1. void *ptr：Binder实体在用户空间中的指针。2. void *cookie：与该实体相关的附加数据。 BC_REGISTER_LOOPER BC_ENTER_LOOPERBC_EXIT_LOOPER 1. 与 BINDER_SET_MAX_THREADS 共同实现 Binder 驱动对接收方线程池管理。2. BC_REGISTER_LOOPER 通知驱动线程池中的一个线程已经创建了。3. BC_ENTER_LOOPER 通知驱动该线程已经进入主循环，可以接受数据。4. BC_EXIT_LOOPER 通知驱动该线程退出主循环，不再接受数据。 - BC_REQUEST_DEATH_NOTIFICATION 已经获得 Binder 引用的进程通过此命令请求驱动在 Binder 实体销毁时得到通知。虽然强指针可以确保引用存在时实体不会被销毁，但没人能保证是否由于实体所在的 Server 关闭 Binder 驱动或者异常退出而消失，引用者能做的就是要求 Server 在此时给出通知。 1. uint32 *ptr 需要得到死亡通知的 Binder 引用。2. void **cookie 与死亡通知相关的信息，驱动会在发出死亡通知时返回给发出请求的进程。 BC_DEAD_BINDER_DONE 收到 Binder 实体通知的进程在删除 Binder 引用后使用本命令告知驱动。 void **cookie BINDER_WRITE_READ 读取从 Binder 读取的格式与写入数据格式一致，使用（消息 ID+数据）的形式，多条可连续存放。 命令 解释 参数 BR_ERROR 发生内部错误（如内存分配失败） - BR_OKBR_NOOP 操作完成 - BR_SPAWN_LOOPER 用于接收方线程管理，当驱动发现接收方所有线程都处于忙碌状态且线程池里的线程总数没有 BINDER_SET_MAX_THREADS 设置的最大线程数时，向接收方发送该命令要求创建更多线程以备接受数据。 - BR_TRANSACTIONBR_REPLY 对应发送方的 BC_TRANSCATION 和 BC_REPLY binder_transcation_data BR_ACQUIRE_RESULTBR_ATTEMPT_ACQUIREBR_FINISHED 尚未实现 - BR_DEAD_REPLY 交互过程中如果发现对方进程或线程已经死亡则返回该消息。 - BR_TRANSACTION_COMPLETE 发送方通过 BC_TRANSACTION 或 BC_REPLY 发送完一个数据包后，都能收到该消息作为成功的反馈。无论异步或同步。 - BR_INCREFSBR_ACQUIREBR_RELEASEBR_DECREFS 用于管理强/弱指针的引用计数，只有提供 Binder 实体的进程才能收到该组消息。 1. void *ptr Binder 实体在用户空间的指针。2. void *cookie 与该实体相关的附加数据。 BR_DEAD_BINDERBR_CLEAR_DEATH_NOTIFICATION_DONE 1. 向获得 Binder 引用的进程发送Binder 实体死亡通知书。2. 收到死亡通知书的进程接下来会返回 BC_DEAD_BINDER_DONE 做确认。 void **cookie 在使用BC_REQUEST_DEATH_NOTIFICATION 注册死亡通知时的附加参数。 BR_FAILED_REPLY 如果发送非法引用号则返回该消息。 - binder_transaction_data 结构binder_transaction_data 表示收发数据包结构，使用时将它接在 TRANSACTION 和 RELPY 命令后面。 成员 解释 union {size_t handle;void *ptr;} target; 1. 对于发送数据包的一方，该成员指定发送目的地。由于目的地在远端，所以这里填入的是对 Binder 实体的引用，存放在 target.handle 中。2. 当数据包到达接收方时，驱动将该成员转换成 Binder 实体，即指向 Binder 对象内存的指针，使用 target.ptr 来保存。3. target.ptr 指针是接收方在将 Binder 实体传输给其他进程时提交给驱动的，驱动能够自动将发送方填入的引用转换成接收方 Binder 对象的指针，接收方可直接作为对象指针使用。（通常使用 reinterpret_cast 转换）。 void *cookie 1. 发送方忽略该成员。2. 接收方收到数据包时，该成员存放的是创建 Binder 实体时由该接收方自定义的任意数值，作为与 Binder 指针相关的额外信息存放在驱动中，驱动基本不关心该数据。 unsigned int code; 该成员存放收发双方约定的命令码，驱动完全不关心该成员的内容。一般为 Server 端定义的公共接口函数的编号。 unsigned int flags; 1. 交互相关的标志位2. 当为 TF_ONE_WAY 表示这次交互为异步的，Server 端不会返回数据。驱动利用该位来决定是否建立与返回有关的数据结构。3. 当为 TF_ACCEPT_FDS 是处于安全考虑，如果发起请求的一方不希望再收到回复中接受文件形式的 Binder，当收到一个文件形式的 Binder 会自动为数据接收方打开一个文件，这时可以使用该位避免打开文件过多。 pid_t sender_pid;uid_t sender_euid; 1. 该成员存放发送方的进程 ID 和用户 ID，由驱动负责填入。2. 接收方可以读取该成员获知发送方的身份。 size_t data_size; 1. 该成员表示 data.buffer 指向的缓冲区存放的数据长度。发送数据时由发送方填入，表示即将发送的数据长度。2. 在接收方用来告知接收到数据的长度。 size_t offsets_size; Binder 驱动通常不关心 data.buffer 里存放的数据，但如果有 Binder 在其中传输则需要将其相对 data.buffer 的偏移位置指出来让驱动知道。可能存在多个 Binder 同时在数据中传递，所以须用数组表示所有偏移位置。本成员表示该数组的大小。 union {struct {const void *buffer;const void *offsets;} ptr;uint8_t buf[8];} data; 1. data.buffer 存放要发送或接收到的数据。2. data.offsets 指向 Binder 偏移位置数组，该数组可以位于 data.buffer 中，也可以在另外的内存空间中，并无限制。buf[8] 是为了无论保证 32 位还是 64 位平台，成员 data 的大小都是 8 个字节。 下图说明了 BINDER_WRITE_READ 通信的数据包示例： Binder 层次概述Binder 位于系统以下几个部分： 应用层：位于 Server 进程和 Client 进程中。 Binder 驱动层：分别管理 Server 端的 Binder 实体和 Client 端的引用。 Binder 传输结构：跨进程传递 Binder，使用数据结构描述。 Binder 应用层Binder 使用面向对象的思想设计，但不限于必须使用面向对象的语言实现通信，Native 层的 ServiceManager 就是使用 C 语言实现的。 存在于 Android 应用层的 Server 端通常使用面向对象实现，首先 Server 端为了给 Client 端提供服务，需要实现一套提供服务的接口函数，这时通常采用 Proxy 设计模式，将功能函数抽象成一个接口，Server 和 Client 端同时实现这个接口，Server 实现对应函数的功能，而 Client 则实现对 Server 端对应功能的请求，及代理，此时 Client 端使用 Server 端服务就像直接使用本地方法一样简单。 如何将 Binder 通信和 Proxy 设计模式结合起来是应用程序实现面向对象Binder通信的根本问题。 Binder Server 端 Binder 实体是 Binder 在 Server 端的表述 使用 Binder 通信首先定义包含功能函数的接口，然后 Server 端和 Client 端的 Proxy 类各自实现该接口，由于功能函数需要跨进程调用，所以需要使用数字一一编号，Server 端接收到编号即可决定调用哪个功能函数。此时需要引入 Binder，Server 端定义另一个 Binder 抽象类处理来自 Client 端的 Binder 请求数据包，其中核心成员为 onTransact() 方法，该方法负责接收数据包，然后根据分析数据包处理不同请求。 Binder 数据包的接收 使用继承方式构建一个同时实现功能函数接口和 Binder 抽象类的 Server 端 Binder 实体，并实现所有函数，包括数据包处理函数 onTransact()，它的输入来自 Client 端发出的 binder_transaction_data 结构的数据包。其中有一个 code 成员即为约定的函数调用编号，onTransact() 方法将 case-by-case 解析 code 值，并从数据包中提取函数参数，请求调用相应的功能函数，并将函数执行完毕的数据写回一个新构建的 binder_transaction_data 数据包中返回。 Binder 数据包的分发 Binder 实体必须以 Binder 传输结构 flat_binder_object 的形式发送给其他进程才能建立进程间通信，其中 Binder 实体的引用号存在于其 handle 成员中，Binder 驱动根据 Binder 实体的位置从传输数据结构中获取该 Binder 的传输结构，并创建对应的 Binder 在内核中的节点，当有其他进程向该 Binder 发送数据时，驱动会根据内核节点中记录的信息将 Binder 实体指针填入 binder_transaction_data 中的 target.ptr 成员中返回给接收线程。接收线程中数据包中解析出该指针，使用 reinterpret_cast 将 Binder 转换成 Binder 抽象类，并调用其 onTransact() 函数，即可调用到不同的 Binder 实体的对应的 onTransact() 函数的实现。 Binder Client 端 Binder 引用是 Binder 在 Client 端的表述 Client 端的 Binder 也需要实现和服务的相同的功能函数的接口，但并不是实现功能，而是作为代理实现对远程功能函数的包装，将函数的参数通过 Binder 打包发送至 Server 端，此时 Client 还需要知道 Binder 实体相关的信息，即对实体 Binder 的引用，该引用由 ServiceManager 返回，或者是另一种由另一个进程直接发送过来的对匿名 Binder 的引用。 发送 Binder 请求 由于 Client 端 Binder 实现了和 Server 端相同的功能函数接口，所以 Client 端使用起来就像使用本地的功能函数一样，对用户无感知。对远端功能函数的包装方法为：创建一个 binder_transaction_data 数据包，将对应的功能函数编码填入 code 成员中，将函数参数填入 data.buffer 成员中，并将目标 Binder 的引用填入数据包的 target.handle 成员中，target 本身是一个联合体，有 ptr 和 handle 两个成员，前者用于 Server 端，其中存放了指向 Binder 实体对应的内存空间的指针，后者用于 Client 端，存放 Binder 实体的引用号，告知驱动需要发送的目标 Binder 实体，数据包打包完成后，通过 Binder 驱动的方法通过 BC_TRANSACTION/BC_REPLY 指令完成和远程功能函数的调用交互。 Binder 传输结构 Binder 通过 flat_binder_object 结构在数据包中进行跨进程传输 成员 解释 unsigned long type 表明 Binder 的类型，有如下几种：BINDER_TYPE_BINDER：表示传递的是 Binder 实体，并且指向该实体的引用都是强类型。BINDER_TYPE_WEAK_BINDER：表示传递的是 Binder 实体，并且指向该实体的引用都是弱引用。BINDER_TYPE_HANDLE：表示传递的是 Binder 强引用类型。BINDER_TYPE_WEAK_HANDLE，表示传递的是 Binder 弱引用类型。BINDER_TYPE_FD 表示传递的是文件形式的 Binder。 unsigned long flags 此成员只对首次传递 Binder 有效，因为首次传递，Binder 驱动将在内核中创建 Binder 对应的实体节点，需要从此成员获取值。0-7 位，使用 FLAT_BINDER_FLAG_PRIORITY_MASK 取出值，表示处理本实体请求数据包的线程的最低优先级。当一个应用程序提供多个实体时，可以通过该参数调整分配给各个实体的处理能力。第 8 位：代码中用 FLAT_BINDER_FLAG_ACCEPTS_FDS 取出值，值为 1 表示该实体可以接收其它进程发过来的文件形式的 Binder，由于接收文件形式的Binder会在本进程中自动打开文件，有些Server可以用该标志禁止该功能，以防打开过多文件。 union {void *binder;signed long handle;} 当传递的是 Binder 实体时使用 binder 域，指向 Binder 实体在应用程序中的地址。当传递的是 Binder 引用时使用 handle 域，存放 Binder 在进程中的引用号。 void *cookie 该域只对 Binder 实体有效，存放与该 Binder 有关的附加信息。 Binder 传输结构的传输 不管是 Binder 实体还是其引用，都可能属于任意一个进程，所以 Binder 传输结构不能透明的在进程间传递，其中的信息必须经过驱动的翻译转换，才能让每个进程正确的使用 Binder 进程通信，例如在 Server 端将 Binder 实体传递给 Client 时，通过 flat_binder_object 结构进程传递，此时其中的 type 成员是 BINDER_TYPE_BINDER 类型，Binder 指向的是 Server 端的用户空间的内存地址，对 Client 端无用，驱动此时必须对 Binder 进行转换，将 type 改成 BINDER_TYPE_HANDLE ，为这个 Binder 在接收进程中创建位于内核中的引用，并将 Binder 实体的引用号填入 handle 中，对于 Binder 传输结构中发送的 Binder 引用类型也要做相同的转换，经过驱动翻译处理后的 Binder 引用才是可用的，此时才能填入 flat_binder_object 中的 handle 成员，向 Binder 实体发送请求。 Binder 验证 由于 Binder 在进程间的传输需要驱动的翻译，所以进程不能随意猜测一个 Binder 引用号就能向 Server 端请求服务，必须是由驱动在内核中创建对应的合法引用才行，需要使用由驱动注册相应的 Binder 节点亲自授予的引用号,必须经过驱动进行合法的验证，通过后才能进行通信，否则将被拒绝。 驱动对 flat_binder_object 结构的转换 Binder 类型（type 成员） 发送方的操作 接收方的操作 BINDER_TYPE_BINDERBINDER_TYPE_WEAK_BINDER 1. 只有实体所在的进程能发送该类型的Binder。2. 如果是第一次发送驱动将创建实体在内核中的节点，并保存binder，cookie 和 flag 成员。 1. 如果是第一次接收该 Binder 则创建实体在内核中的引用；将 handle 成员替换为新建的引用号；将 type 成员替换为 BINDER_TYPE_HANDLE 或 BINDER_TYPE_WEAK_HANDLE。 BINDER_TYPE_HANDLEBINDER_TYPE_WEAK_HANDLE 1. 获得 Binder 引用的进程都能发送该类型 Binder。2. 驱动根据 handle 域提供的引用号查找建立在内核的引用，如果找到说明引用号合法，否则拒绝该发送请求。 1. 如果收到的 Binder 实体位于接收进程中：将 ptr 成员替换为保存在节点中的 binder 值；cookie 替换为保存在节点中的 cookie 值；type 替换为 BINDER_TYPE_BINDER 或 BINDER_TYPE_WEAK_BINDER。2. 如果收到的 Binder 实体不在接收进程中：如果是第一次接收则创建实体在内核中的引用；将 handle 域替换为新建的引用号。 BINDER_TYPE_FD 验证 handle 成员中提供的打开文件号是否有效，无效则拒绝该发送请求。 在接收方创建新的打开文件号并将其与提供的打开文件描述结构绑定。 文件形式的 Binder 文件形式的 Binder 是一种特殊的 Binder，将文件看作一个 Binder 实体，进程打开的文件号看作 Binder 的引用，一个进程可将打开文件的文件号传递给另一个进程，从而另一个进程也打开了同一个文件。 一个进程打开一个文件，获得与之对应的文件号，从 Binder 角度，Linux 在内核创建的对应的文件描述结构 struct file 做为 Binder 实体，这时可通过 flat_binder_object 结构在进程间进行传递，type 成员此时为 BINDER_TYPE_FD，表示此 Binder 为文件 Binder，驱动将会对发送者的文件号做转换，在接收进程创建一个新的文件号与内核中的文件描述结构对应，然后替换 flat_binder_object 结构中的文件号传递给接收进程。 通过 Binder 发送的文件与多个进程打开同一个文件的意义不同，通过 Binder 打开的文件共享 Linux 虚拟文件系统中的 struct file，struct dentry，struct inode 结构，当一个进程使用 read()/write()/seek() 改变文件指针，另一个进程的文件指针也会同时改变。 Binder 驱动层Binder 驱动式实现 Binder 进程间通信的核心，它记录了所有 Binder 实体以及每个实体在各个进程中的引用；它能够通过 Binder 引用查询对应的 Binder 实体；它为 Binder 实体创建以及查找对应引用，它记录 Binder 实体所在进程；管理 Binder 强/弱引用，创建/销毁 Binder 实体等。 驱动中的第一个 Binder 是 ServiceManager，它用于管理实名 Binder 的 Binder 实体的注册，负责实名 Binder 注册过程中的进程间通信。驱动将所有进程中的 0 号 Binder 引用都指向 ServiceManager，那么索引进程将很方便的统一使用 0 号引用访问 ServiceManager，各个进程通过 flat_binder_object 结构穿过驱动进程进程间通信，Binder 驱动将会监听 binder_transaction_data 中的 data.offset 数组，所有 Binder 都在驱动的检查下传递，驱动通过 type 成员检查，如果为 BINDER_TYPE_BINDER 或 BINDER_TYPE_WEAK_BINDRE 则创建对应的 Binder 实体，如果为 BINDER_TYPE_HANDLE或 BINDER_TYPE_WEAK_HANDLE 则创建 Binder 引用，内核中的 Binder 实体和 Binder 引用将随着 Binder 通信过程逐渐增加，整个过程对用户透明。 Binder 实体在驱动中的表述 Binder 实体在驱动中以树的节点的形式存在，使用 struct binder_node 结构表示。 成员 解释 int debug_id; 用于调试 struct binder_work work; 当本节点的引用计数发生改变时，需要通知所属进程，通过该成员挂入所属进程的 to-do 队列里，唤醒所属进程执行 Binder 实体引用计数的修改。 union {struct rb_node rb_node;struct hlist_node_dead_node;} 每个进程都维护一棵红黑树，以 ptr 成员为索引存放该进程所有的 Binder 实体，它是 Binder 实体在用户空间的指针，这样 Binder 驱动就可以根据 ptr 指针找到位于内核的 Binder 节点。rb_node 用于将该节点链接到红黑树中，节点被销毁时需要将 rb_node 从树中移除，如果本节点引用还没有断开，就将节点使用 dead_node 记录到独立的链表中，直到通知所有进程切断与该节点的引用后，该节点才能被销毁。 struct binder_proc *proc; 本成员指向节点所属的进程，即提供该节点的进程。 struct hlist_strong_refs; 本成员是队列头，所有指向本节点的引用都链接在该队列里。这些引用可能隶属于不同的进程。通过该队列可以遍历指向该节点的所有引用。 int internal_strong_refs; 用以实现强指针的计数器：产生一个指向本节点的强引用该计数就会加 1。 int local_weak_refs; 驱动为传输中的 Binder 设置的弱引用计数。如果一个 Binder 通过数据包从一个进程发送到另一个进程，驱动会为该 Binder 增加引用计数，直到接收进程通过 BC_FREE_BUFFER 通知驱动释放该数据包的数据区为止。 int local_strong_refs; 驱动为传输中的 Binder 设置的强引用计数，同上。 void __user *ptr; 指向用户空间 Binder 实体的指针，来自于 flat_binder_object 的 Binder 成员。 void __user *cookie; 向用户空间的附加指针，来自于 flat_binder_object 的 cookie 成员。 unsigned has_strong_ref;unsigned pedning_strong_ref;unsigned has_weak_ref;unsigned pending_weak_ref; 用于控制驱动与 Binder 实体所在进程交互式修改引用计数 unsigned has_async_transaction; 该成员表明该节点在 to-do 队列中有异步交互尚未完成。驱动将所有发送往接收端的数据包暂存在接收进程或线程开辟的 to-do 队列里。对于异步交互，驱动做了适当流控：如果 to-do 队列里有异步交互尚待处理则该成员置 1，这将导致新到的异步交互存放在本结构成员 – asynch_todo 队列中，而不直接送到 to-do 队列里。目的是为同步交互让路，避免长时间阻塞发送端。 unsigned accept_fds; 表明节点是否同意接受文件方式的 Binder，来自 flat_binder_object 中 flags 成员的 FLAT_BINDER_FLAG_ACCEPTS_FDS 位。由于接收文件 Binder 会为进程自动打开一个文件，占用有限的文件描述符，节点可以设置该位拒绝这种行为。 int min_priority; 设置处理 Binder 请求的线程的最低优先级。发送线程将数据提交给接收线程处理时，驱动会将发送线程的优先级也赋予接收线程，使得数据即使跨了进程也能以同样优先级得到处理。不过如果发送线程优先级过低，接收线程将以预设的最小值运行。 struct list_head_async_todo; 该域的值来自于 flat_binder_object 中 flags 成员。异步交互等待队列；用于分流发往本节点的异步交互包。 Binder 引用在驱动中的表述 Binder 引用使用 binder_ref 结构表示。 成员 含义 int debug_id 用于调试 struct rb_node rb_node_desc; 每个进程有一棵红黑树，进程所有引用以引用号（即本结构的 desc 成员）为索引添入该树中。本成员用做链接到该树的一个节点。 struct rb_node rb_node_node; 每个进程又有一棵红黑树，进程所有引用以节点实体在驱动中的内存地址（即本结构的 node 成员）为所引添入该树中。本成员用做链接到该树的一个节点。 struct hlist_node node_entry; 将本引用做为节点链入所指向的 Binder 实体结构 binder_node 中的 refs 队列。 struct binder_proc *proc; 本引用所属的进程。 struct binder_node *node; 本引用所指向的 Binder 实体节点。 uint32_t desc; 本结构的引用号 int strong; 强引用计数 int weak; 弱引用计数 struct binder_ref_death *death; 应用程序向驱动发送 BC_REQUEST_DEATH_NOTIFICATION 或 BC_CLEAR_DEATH_NOTIFICATION 命令从而当 Binder 实体销毁时能够收到来自驱动的提醒。该成员不为空表明用户订阅了对应实体销毁的“讣告”。 同一个 Binder 实体可能存在多个 Binder 引用，而这些引用分布在不同的进程中，和实体一样，每个进程维护一颗红黑树存放 Binder 引用，Binder 引用可通过两个键索引： 对应 Binder 实体在内核中的地址。它是内核中 binder_node 结构的地址，它的地址在内核中具有唯一性，Binder 实体在不同用户进程地址可能重合，所以不能用来做索引，Binder 驱动利用红黑树在进程中快速查找 Binder 实体对应的引用（一个实体在进程中之间里一个引用）。 引用号。它是驱动为 Binder 引用分配的一个 32 位标识，在一个进程中具有唯一性，多个进程中引用号可能相同，引用号可做为 Binder 引用在用户进程的句柄，由驱动动态分配，0 号为特殊引用号，固定指向 ServiceManager。当向 Binder 发送数据包时，应用程序将 Binder 引用号填入 binder_transaction_data 结构中的 target.handle 成员中，表明该数据包的目的 Binder，驱动根据引用号在红黑树中找到对应的 binder_ref 结构，然后可通过其 node 成员获取对应的 Binder 实体所在的进程及相关信息，实现数据包的发送。 Binder 驱动实现Binder 内存映射和接收缓存区实现 传统的 IPC 通信方式 在传统的 IPC 通信中，通常发送方发送数据时，首先将数据放入缓存区，然后通过 system call 陷入内核，内核服务在内核分配内存，将发送方数据拷贝到内核缓冲区，同时接收方需要分配同样的缓存区，然后内核将数据从内核缓存区拷贝到接收方并唤醒接收线程，完成数据的发送，这种方式具有两个缺陷： 效率低下，需要两次数据复制过程，Linux 通过 copy_from_user()/copy_to_user() 实现跨内核复制数据，如果此过程中使用了高端内存，需要临时建立和取消页映射，会造成性能损失。 接收方需要提供数据缓存，而缓存大小未知，只能尽量开辟足够的空间，或者提前调用 API 获取大小，两种方式都会造成时间或空间的浪费。 Binder IPC 实现 Binder 采用与通常 IPC 方式不同的内存管理策略，Binder 驱动负责数据接收缓存的管理，它实现了 mmap() 系统调用，mmap() 通常用于具有物理介质的文件系统上，而 Binder 驱动做为字符设备支持 mmap() 并不是为了在物理介质和用户空间做映射，而是用来创建用于接收数据的缓存空间。 创建接收缓存区的方法如下： 12fd = open(&quot;/dev/binder&quot;, O_RDWR); // 打开 Binder 驱动。mmap(NULL, MAP_SIZE, PROT_READ, MAP_PRIVATE, fd, 0); 以上操作为接受方创建了一片大小为 MAP_SIZE 的接收缓存区，mmap() 返回内存映射在用户空间的地址，这段空间由驱动管理，用户不能直接访问（类型为 PROT_READ 只读映射）。 Binder 接收线程实现Binder 通信的最终形态其实是不同进程中的线程之间的通信，Client 端中的线程 1 通过 Binder 引用向 Server 端发送请求，Server 将启动线程 2 来处理 Client 端的请求，此时 Client 端中的线程 1 将等待回应，Server 端的线程 2 处理完毕返回结果，然后 Client 端中的线程 1 被唤醒并接收数据，在此过程中，Server 端中的线程 2 仿佛 Client 端线程 1 的影子，这个影子穿越进程执行任务后再回到线程 1 中，就像同一个线程执行一个任务一样，驱动会帮助此行为，为线程 2 设置与线程 1 相同的线程优先级，为了使 Server 端线程 2 的执行时间接近 Client 端线程 1 的执行时间，减小环境之间的差异。不过除了线程优先级类似，两个线程从的身份，打开的文件，栈大小，私有数据等并无相同之处。 Binder 线程池管理 考虑多个 Client 端同时向一个 Server 端发起请求的情况，对于 Socket 处理方式而言，每当它监听到 Client 端的请求后，它就会对每一个 Client 启动一个线程来单独处理 Client 端发出的请求。对于 Binder 来说则不是这样。 Binder 会提前创建好若干线程，同时每个线程使用 BINDER_WRITE_READ 命令读取 Binder 请求，此时这些线程将处于阻塞状态，并存放于队列中，当有 Client 端请求时，Binder 驱动将从队列中唤醒一个线程用于处理 Client 请求，由于需要提前创建一定数量的线程，为避免浪费资源，Binder 协议提供了如下命令控制线程池： 12345BINDER_SET_MAX_THREADSBC_REGISTER_LOOPBC_ENTER_LOOPBC_EXIT_LOOPBC_SPAWN_LOOPER 应用程序 Client 端通过 BINDER_SET_MAX_THREADS 通知 Binder 驱动最多可以创建线程的数量，在每个线程创建，进入循环，退出循环时会调用 BC_REGISTER_LOOP BC_ENTER_LOOP BC_EXIT_LOOP 通知 Binder 驱动，驱动会收集线程相关信息，在每次驱动接收到 Client 端数据包并后返回给线程时，都会检查十是否还有闲置线程，如果没有了，则 Binder 驱动会在数据包中附加 BC_SPAWN_LOOPER 命令通知 Client 端，线程将不足以响应请求，希望能够再创建若干线程。这样就构成一个持续的处理和响应的过程。 线程启动优化 当 Client 端进程中的线程 1 向 Server 端进程发送请求时，Binder 驱动会首先查看线程 1 是否也在等待处理 Server 端进程的某个线程的响应（两个进程间互相发送消息时），如果 Server 端存在一个这样个线程 2，那么驱动将要求线程 2 来处理这个请求，因为可以确定的是线程 1 在等待线程 2 的响应，线程 2 也阻塞在读取返回包的过程，这样可以有效利用线程资源，避免线程 2 的空闲，同时避免了创建额外的线程。 数据包接收队列与（线程）等待队列实现数据接收端通常存在两个队列，数据包接收队列和线程等待队列，数据包接收队列负责接收数据包并缓存，之后会分发给线程处理，而线程等待队列则为等待处理请求的线程，在 Binder 驱动中，每个进程都具有一个全局接收队列，称为 to-do 队列，负责存放不是发往特定线程的数据包，相应的有一个全局等待队列，等待处理全局接受队列中的数据包，同时每个线程有自己私有的 to-do 队列，存放发送给自己的数据包，对应的私有等待队列用于接收私有 to-do 队列中的数据包，其中只有一个线程，就是这个线程自身。 数据包接收规则 Binder 驱动将根据以下规则确定数据包存放在全局或私有队列中： Client 端发送至 Server 端的数据包全部提交到进程全局的 to-do 队列，除了前面线程启动优化中的情况，Client 端的线程 1 发送的数据包将存放在满足条件的 Server 端的线程 2 的私有 to-do 队列中。 对于同步请求的返回数据包，都放入发起请求的线程的私有 to-do 队列中。 根据以上规则得到了线程进入全局等待队列的规则，即如果一个线程不接收返回数据包则应该在等待队列中等待接收新任务，否则就应该在其私有的队列中等待 Server 端的返回数据包。 驱动为 Binder 通信所加的这些规则，在应用程序的同步交互中体现出了线程一致性原则： Client 端发送数据包的线程必须和等待返回包的线程是同一个，否则将无法接收到返回包。 Server 端发送返回包的线程必须和接收到请求的线程是同一个，否则将数据包返回至请求的线程。（返回数据包的 Binder 由驱动记录在接收请求数据包的线程中，所以发送数据包的线程也需要是它） 同步异步交互 在 Binder 通信中，同步交互和异步交互的区别在于，同步交互时 Client 端需要等待 Server 端的响应数据包，而异步交互则由于没有返回数据需要接收，所以 Client 端发出请求后可立即结束。Binder 驱动对于两种交互的处理并不是把它们直接加入对应的 to-do 队列中，而是定义了异步为同步请求让步的策略： 对于 Binder 实体，如果存在一个异步交互未被线程处理完时，那么后来的发送给该 Binder 实体的异步请求将不再加入 to-do 队列中，而是阻塞在 Binder 驱动为该 Binder 实体开辟的异步交互队列中（Binder 节点的 async_node 成员中），在此期间同步交互依旧不受限制直接进入 to-do 队列接受处理，直到该异步交互处理完毕，下一个异步交互方可以脱离异步交互队列进入 to-do 队列中。这样做是因为同步交互的请求端需要等待返回包，必须迅速处理完毕以免影响请求端的响应速度，而异步交互属于‘发射后不管“，即使延时一些不会阻塞其它线程，所以使用专用队列将过多的异步交互暂存起来，避免突发大量异步交互挤占 Server 端的处理能力或耗尽线程池里的线程，进而阻塞同步交互。 结语以上”Binder 设计“部分是阅读博客所做的记录，由于可能出现理解偏差，所以里面可能会存在错误的论述，需要我在后期学习过程中去确认修正。","link":"/2019/04/08/android-binder-%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/"},{"title":"Android 二进制 XML 文件解析","text":"前言Android SDK 在编译 Android 工程时，将会把诸如资源文件和清单文件之类的相关 XML 文件编译为特定的二进制格式，目的是为了压缩其容量以及优化其在运行时的解析效率。 将 XML 文件编译为二进制的 XML 文件是 Android 编译资源时的一个子步骤，Android 在完整的资源编译过程结束后将会生成一个 resources.arsc 文件，它是一个资源文件表，应用在运行时会将它映射在内存中，为了资源的查询和引用。编译 Xml 文件为生成 arsc 文件的一个子步骤，如果 Xml 文件中引用了资源，例如字符串资源，那么 Xml 文件中引用字符串的位置将会包含一个全局字串池的索引，通过索引在 arsc 文件中的全局字符串池中即可查询到引用的具体字符串。 有关 arsc 文件的结构和解析方法可参考：Android arsc 文件解析。 XML 文件结构编译后的二进制文件结构如下图： 和 arsc 文件的构成方式类似，二进制 XML 文件的结构也是由若干 Chunk 结构组成，且它们在 Android 源码中的 ResourceTypes.h 头文件中均有对应结构的定义。下面分别说明二进制 Xml 中 4 部分 Chunk 的内容。 XML Chunk HeaderXML Chunk Header 描述了 XML 文件的基本信息，它在 ResourceTypes.h 中的结构为 struct ResXMLTree_header，这里使用 Java 描述为： 12345678910public class ResXMLTreeHeader implements Struct { /** * {@link ResChunkHeader#type} = {@link ResourceTypes#RES_XML_TYPE} * &lt;p&gt; * {@link ResChunkHeader#headerSize} = sizeOf(ResXMLTreeHeader.class) 表示头部大小。 * &lt;p&gt; * {@link ResChunkHeader#size} = 整个二进制 Xml 文件的大小，包括头部的大小。 */ public ResChunkHeader header;} 其中 ResChunkHeader 为资源 Chunk 的基础描述头部结构，对应的定义为 struct ResChunk_header，Java 表示为： 12345678public class ResChunkHeader implements Struct { /** Chunk 类型 */ public short type; /** Chunk 头部大小 */ public short headerSize; /** Chunk 大小 */ public int size;} 在 XML 文件中，此时的 type 值为 0x003 等于 ResourceTypes.h 中定义的 XML 类型的 type 值： 12345// 这里使用 Java 描述。public class ResourceTypes {2public static final short RES_XML_TYPE = 0x0003; ...} headerSize 为 ResXMLTreeHeader 头部结构自身的大小，即 ResChunkHeader 的大小，为 8 字节。 size 为当前 Chunk 大小，此时为 XML 文件的大小，包括头结构的大小。 String Pool ChunkString Pool Chunk 为字符串池结构，它包含了此 XML 文件中出现的所有字符串内容。它的结构和 arsc 文件中的全局字符串结构完全一致，下面是引用上篇解析 arsc 文件中的字符串池的描述： 字符串池包括如下几个部分： ResStringPool_header 字符串池头部，包含字符串池的信息，大小，数量，数组偏移等。 String Offset Array 字符串在字符串内容中的字节位置数组，32 位 int 类型。 Style Offset Array 字符串样式在字符串样式中的字节位置数组，32 位 int 类型。 String Content 字符串内容块。 Style Content 字符串样式块。 字符串池的头部使用 struct ResStringPool_header 数据结构描述，Java 表示为： 1234567891011121314151617181920212223242526/** * 字符串池头部。 */public class ResStringPoolHeader implements Struct { public static final int SORTED_FLAG = 1; public static final int UTF8_FLAG = 1 &lt;&lt; 8; /** * {@link ResChunkHeader#type} = {@link ResourceTypes#RES_STRING_POOL_TYPE} * &lt;p&gt; * {@link ResChunkHeader#headerSize} = sizeOf(ResStringPoolHeader.class) 表示头部大小。 * &lt;p&gt; * {@link ResChunkHeader#size} = 整个字符串 Chunk 的大小，包括 headerSize 的大小。 */ public ResChunkHeader header; /** 字符串的数量 */ public int stringCount; /** 字符串样式的数量 */ public int styleCount; /** 0, SORTED_FLAG, UTF8_FLAG 它们的组合值 */ public int flags; /** 字符串内容块相对于其头部的距离 */ public int stringStart; /** 字符串样式块相对于其头部的距离 */ public int styleStart;} 其中 flags 包含 UTF8_FLAG 表示字符串格式为 utf8， SORTED_FLAG 表示已排序。 字符串的偏移数组使用 struct ResStringPool_ref 数据结构描述，Java 表示为： 1234567/** * 字符串在字符串内容块中的字节偏移。 */public class ResStringPoolRef implements Struct{ /** 字符串在字符串池中的索引 */ public int index;} 字符串样式则使用 struct ResStringPool_span 数据结构描述，Java 表示为： 12345678910111213/** * 字符串样式块中的字符串样式信息。 */public class ResStringPoolSpan implements Struct{ public static final int END = 0xFFFFFFFF; /** 本样式在字符串内容块中的字节位置 */ public ResStringPoolRef name; /** 包含样式的字符串的第一个字符索引 */ public int firstChar; /** 包含样式的字符串的最后一个字符索引 */ public int lastChar;} 其中 name 表示字符串样式本身字符串的索引，比如 &lt;b&gt; 样式本身的字符串为 b，即为 b 在字符串池中的索引。 firstChar 和 lastChar 则为具有样式的字符串的中字符串首位的索引，例如 he&lt;b&gt;ll&lt;/b&gt;o，则为 2 和 3。 字符串样式块和字符串内容块是一一对应的，就是说第一个字符串的样式对应第一个字符串样式块中的样式，如果对应的字符串中有不具有样式的字符串，则对应的 ResStringPool_span 的 name 为 0xFFFFFFFF，起占位的作用。 Resource Ids ChunkResource Ids Chunk 包含了 xml 文件中相关的资源 ID，例如 AndroidManifest.xml 中 versionCode 属性的 id 为 0x0101021b，那么 Resource Ids 块中就包括这个 id 值。 这里 Resource Ids Chunk 的结构很简单，包含一个 struct ResChunk_header 结构的 header，然后后面包含一个大小为 header.size - header.headerSize 的 int 型 id 数组。 XML Content ChunkXML Content Chunk 是二进制 XML 的核心块结构，包含了 XML 的主要内容。 ResXMLTree_node此 Chunk 结构包含多种子 Chunk 结构，它们都有相同的头部结构，使用 struct ResXMLTree_node 结构描述，Java 表示为： 12345678910111213141516171819202122232425public class ResXMLTreeNode implements Struct { /** * {@link ResChunkHeader#type} = * {@link ResourceTypes#RES_XML_START_NAMESPACE_TYPE} or * {@link ResourceTypes#RES_XML_END_NAMESPACE_TYPE} or * {@link ResourceTypes#RES_XML_START_ELEMENT_TYPE} or * {@link ResourceTypes#RES_XML_END_ELEMENT_TYPE} or * {@link ResourceTypes#RES_XML_CDATA_TYPE} * &lt;p&gt; * {@link ResChunkHeader#headerSize} = sizeOf(ResXMLTreeNode.class) 表示头部大小。 * &lt;p&gt; * if (type == RES_XML_START_NAMESPACE_TYPE) * &lt;p&gt; * {@link ResChunkHeader#size} = sizeof(ResXMLTreeNode.class) + sizeof(ResXMLTreeNamespaceExt.class) */ public ResChunkHeader header; /** * 命名空间开始标签在原来文本格式的 XML 文件出现的行号 */ public int lineNumber; /** * 命名空间的注释在字符池资源池的索引。 */ public ResStringPoolRef comment;} 其中 header 描述此 Chunk 的基本信息，lineNumber 保存了原始行号，comment 则为注释信息。 Start Namespace Chunk 当一个 XML 文件包含命名空间时，首次解析到的 Chunk 为 Start Namespace Chunk，然后后面解析到和 XML 命名空间数量一致的 Start Namespace Chunk，它们使用 struct ResXMLTree_namespaceExt 结构描述，Java 表示为： 123456public class ResXMLTreeNamespaceExt implements Struct { /** 命名空间字符串在字符串资源池中的索引 */ public ResStringPoolRef prefix; /** uri 字符串在字符串资源池中的索引 */ public ResStringPoolRef uri;} 其中包含命名空间的 prefix 和 uri，例如布局文件中经常出现的： 1xmlns:http://schemas.android.com/apk/res/android=&quot;android&quot; 它的 prefix 为 android，uri 为 http://schemas.android.com/apk/res/android Start Element Chunk当有 XML 元素标签出现时，将会解析到 Start Element Chunk，它表示一个元素标签的开始，使用 struct ResXMLTree_attrExt 结构描述，Java 表示为： 1234567891011121314151617181920212223242526public class ResXMLTreeAttrExt implements Struct { /** 元素所在命令空间在字符池资源池的索引，未指定则为 -1 */ public ResStringPoolRef ns; /** 元素名称在字符串池资源的索引 */ public ResStringPoolRef name; /** * 等于 sizeOf(ResXMLTreeAttrExt.class)，表示元素属性 chunk 相对于 RES_XML_START_ELEMENT_TYPE 头部的偏移。 */ public short attributeStart; /** sizeOf(ResXMLTreeAttribute.class)，表示每一个属性占据的 chunk 大小 */ public short attributeSize; /** 表示属性 chunk 数量 */ public short attributeCount; /** * 如果元素有一个名称为 id 的属性，那么将它出现在属性列表中的位置再加上 1 的值记录在 idIndex 中，否则 idIndex 的值等于 0。 */ public short idIndex; /** * 如果元素有一个名称为 class 的属性，那么将它出现在属性列表中的位置再加上 1 的值记录在 classIndex 中，否则 classIndex 的值等于 0。 */ public short classIndex; /** * 如果元素有一个名称为 style 的属性，那么将它出现在属性列表中的位置再加上 1 的值记录在 styleIndex 中，否则 styleIndex 的值等于 0。 */ public short styleIndex;} 例如： 123&lt;LinearLayout xmlns:http://schemas.android.com/apk/res/android=&quot;android&quot; xmlns:http://schemas.android.com/apk/res-auto=&quot;app&quot; layout_gravity=&quot;0x00000050&quot; id=&quot;@0x7f09002b&quot; background=&quot;@0x0106000d&quot; layout_width=&quot;-1&quot; layout_height=&quot;-2&quot;&gt; ...&lt;/LinearLayout&gt; 它的 name 为 LinearLayout，ns 为 null，attributeCount 等于 5。 通过 ResXMLTree_attrExt 结构给出的元素信息，可以解析出它所包含的属性，属性使用 struct ResXMLTree_attribute 结构描述，使用 Java 表示为： 12345678910public class ResXMLTreeAttribute implements Struct { /** 表示属性的命令空间在字符池资源池的索引，未指定则等于 -1 */ public ResStringPoolRef ns; /** 属性名称字符串在字符池资源池的索引 */ public ResStringPoolRef name; /** 属性的原始值在字符池资源池的索引，这是可选的，如果不保留，它的值等于 -1 */ public ResStringPoolRef rawValue; /** resValue */ public ResValue typeValue;} CData Chunk当一个元素标签包含值内容时，将会解析到 CData Chunk 结构。 例如 &lt;string&gt;abc&lt;/string&gt;，其中的 CData 为 abc，CData Chunk 使用 struct ResXMLTree_cdataExt 描述，Java 表示为： 123456public class ResXMLTreeCdataExt implements Struct { /** CDATA 原始值在字符串池中的索引 */ public ResStringPoolRef data; /** CDATA 的资源类型 */ public ResValue typeData;} End Element ChunkEnd Element Chunk 表示元素标签的结束，和 Start Element Chunk 对应，它使用 struct ResXMLTree_endElementExt 描述，Java 表示为： 123456public class ResXMLTreeEndElementExt implements Struct { /** 元素的命名空间的字符串在字符串池中的索引，未指定则为 -1 */ public ResStringPoolRef ns; /** 元素名称字符串在字符串池中的索引 */ public ResStringPoolRef name;} End Namespace ChunkEnd Element Chunk 表示命名空间的结束符，和 Start Namespace Chunk 对应，描述结构也是一样的。 Chunk Header Type上述结构对应的 Chunk Header 的 type 值如下： 123456789101112131415161718public class ResourceTypes { // XML Chunk Header. public static final short RES_XML_TYPE = 0x0003; // String Pool Chunk. public static final short RES_STRING_POOL_TYPE = 0x0001; // Start Namespace Chunk. public static final short RES_XML_START_NAMESPACE_TYPE = 0x0100; // End Namspace Chunk. public static final short RES_XML_END_NAMESPACE_TYPE = 0x0101; // Start Element Chunk. public static final short RES_XML_START_ELEMENT_TYPE = 0x0102; // End ELement Chunk. public static final short RES_XML_END_ELEMENT_TYPE = 0x0103; // CData Chunk. public static final short RES_XML_CDATA_TYPE = 0x0104; // Resource IDs Chunk. public static final short RES_XML_RESOURCE_MAP_TYPE = 0x0180;} XML 文件解析为了便于解析，这里使用了我自己写的工具类，参考这里的简介： ObjectIO。 解析方法针对上述二进制 XML 文件结构，采用如下方式进行解析： 定义指针变量标识当前解析的字节位置，每解析完一个 chunk 则向下移动指针 chunk 的大小。 采用循环解析的方式，通过 chunk 的 type 判断将要解析哪种 chunk，解析对应的结构。 这里定义了 AXmlParser 解析器，mIndex 为指针变量，parse(ObjectIO objectIO) 为解析子方法。 123456789101112131415161718192021222324252627private void parse(ObjectInput objectInput) throws IOException { // 是否到达文件底部。 while (!objectInput.isEof(mIndex)) { // 获取将要解析的 chunk 头部信息。 ResChunkHeader header = objectInput.read(ResChunkHeader.class, mIndex); // 根据类型解析对应格式。 switch (header.type) { case ResourceTypes.RES_XML_TYPE: ... break; case ResourceTypes.RES_STRING_POOL_TYPE: ... break; case ResourceTypes.RES_XML_RESOURCE_MAP_TYPE: ... break; case ResourceTypes.RES_XML_START_NAMESPACE_TYPE: ... break; case ResourceTypes.RES_XML_START_ELEMENT_TYPE: ... break; case ResourceTypes.RES_XML_CDATA_TYPE: ... break; case ResourceTypes.RES_XML_END_ELEMENT_TYPE: ... break; case ResourceTypes.RES_XML_END_NAMESPACE_TYPE: ... break; } }} XML Chunk Header首先解析 XML Chunk Header，直接一步就行。 12345678910111213// AXmlParser.javaprivate void parse(ObjectInput objectInput) throws IOException { // ... ResChunkHeader header = objectInput.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_XML_TYPE: parseXMLTreeHeader(objectInput); break; ... }} 123456789// AXmlParser.javaprivate void parseXMLTreeHeader(ObjectInput objectInput) throws IOException { ResXMLTreeHeader xmlTreeHeader = objectInput.read(ResXMLTreeHeader.class, mIndex); System.out.println(xmlTreeHeader); // 移动到下一个位置。 mIndex += xmlTreeHeader.header.headerSize;} String Pool Chunk接下来是符串池的解析了，解析代码如下： 1234567891011121314// AXmlParser.javaprivate void parse(ObjectIO objectIO) { ... ResChunkHeader header = objectIO.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_STRING_POOL_TYPE: parseStringPool(objectIO); break; ... } ...} 1234567891011121314151617181920212223242526272829303132333435363738394041424344// AXmlParser.java...private void parseStringPool(ObjectIO objectIO) throws Exception { final long stringPoolIndex = mIndex; ResStringPoolHeader stringPoolHeader = objectIO.read(ResStringPoolHeader.class, stringPoolIndex); System.out.println(&quot;string pool header:&quot;); System.out.println(stringPoolHeader); StringPoolChunkParser stringPoolChunkParser = new StringPoolChunkParser(); stringPoolChunkParser.parseStringPoolChunk(objectIO, stringPoolHeader, stringPoolIndex); System.out.println(); System.out.println(&quot;string index array:&quot;); System.out.println(Arrays.toString(stringPoolChunkParser.getStringIndexArray())); System.out.println(); System.out.println(&quot;style index array:&quot;); System.out.println(Arrays.toString(stringPoolChunkParser.getStyleIndexArray())); stringPool = stringPoolChunkParser.getStringPool(); System.out.println(); System.out.println(&quot;string pool:&quot;); System.out.println(Arrays.toString(stringPool)); System.out.println(); System.out.println(&quot;style pool:&quot;); final List&lt;ResStringPoolSpan&gt;[] stylePool = stringPoolChunkParser.getStylePool(); System.out.println(Arrays.toString(stylePool)); System.out.println(); System.out.println(&quot;style detail:&quot;); for (List&lt;ResStringPoolSpan&gt; spans : stylePool) { System.out.println(&quot;---------&quot;); for (ResStringPoolSpan span : spans) { System.out.println(stringPool[span.name.index]); } } // 向下移动字符串池的大小。 mIndex += stringPoolHeader.header.size;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// StringPoolChunkParser.javapublic class StringPoolChunkParser { private ResStringPoolRef[] stringIndexArray; private ResStringPoolRef[] styleIndexArray; private String[] stringPool; private List&lt;ResStringPoolSpan&gt;[] stylePool; private ResStringPoolRef[] parseStringIndexArray(ObjectIO objectIO, ResStringPoolHeader header, long index) throws IOException { stringIndexArray = new ResStringPoolRef[header.stringCount]; long start = index; final int resStringPoolRefSize = ObjectIO.sizeOf(ResStringPoolRef.class); for (int i = 0; i &lt; header.stringCount; i++) { stringIndexArray[i] = objectIO.read(ResStringPoolRef.class, start); start += resStringPoolRefSize; } return stringIndexArray; } private ResStringPoolRef[] parseStyleIndexArray(ObjectIO objectIO, ResStringPoolHeader header, long index) throws IOException { styleIndexArray = new ResStringPoolRef[header.styleCount]; long start = index; final int resStringPoolRefSize = ObjectIO.sizeOf(ResStringPoolRef.class); for (int i = 0; i &lt; header.styleCount; i++) { styleIndexArray[i] = objectIO.read(ResStringPoolRef.class, start); start += resStringPoolRefSize; } return styleIndexArray; } private static int parseStringLength(byte[] b) { return b[1] &amp; 0x7F; } private String[] parseStringPool(ObjectIO objectIO, ResStringPoolHeader header, long stringPoolIndex) throws IOException { String[] stringPool = new String[header.stringCount]; for (int i = 0; i &lt; header.stringCount; i++) { final long index = stringPoolIndex + stringIndexArray[i].index; final int parseStringLength = parseStringLength(objectIO.readBytes(index, Short.BYTES)); // 经过测试，发现 flags 为0 时，字符串每个字符间会间隔一个空白符，长度变为 2 倍。 final int stringLength = header.flags == 0 ? parseStringLength * 2 : parseStringLength; // trim 去除多余空白符。 stringPool[i] = Formatter.trim(new String(objectIO.readBytes(index + Short.BYTES, stringLength), 0, stringLength, StandardCharsets.UTF_8)); } return stringPool; } private List&lt;ResStringPoolSpan&gt;[] parseStylePool(ObjectIO objectIO, ResStringPoolHeader header, long stylePoolIndex) throws IOException { @SuppressWarnings(&quot;unchecked&quot;) List&lt;ResStringPoolSpan&gt;[] stylePool = new List[header.styleCount]; for (int i = 0; i &lt; header.styleCount; i++) { final long index = stylePoolIndex + styleIndexArray[i].index; int end = 0; long littleIndex = index; List&lt;ResStringPoolSpan&gt; stringPoolSpans = new ArrayList&lt;&gt;(); while (end != ResStringPoolSpan.END) { ResStringPoolSpan stringPoolSpan = objectIO.read(ResStringPoolSpan.class, littleIndex); stringPoolSpans.add(stringPoolSpan); littleIndex += ObjectIO.sizeOf(ResStringPoolSpan.class); end = objectIO.readInt(littleIndex); } stylePool[i] = stringPoolSpans; } return stylePool; } public void parseStringPoolChunk(ObjectIO objectIO, ResStringPoolHeader header, long stringPoolHeaderIndex) throws IOException { // parse string index array. final long stringIndexArrayIndex = stringPoolHeaderIndex + ObjectIO.sizeOf(ResStringPoolHeader.class); stringIndexArray = header.stringCount == 0 ? new ResStringPoolRef[0] : parseStringIndexArray(objectIO, header, stringIndexArrayIndex); final long styleIndexArrayIndex = stringIndexArrayIndex + header.stringCount * ObjectIO.sizeOf(ResStringPoolRef.class); styleIndexArray = header.styleCount == 0 ? new ResStringPoolRef[0] : parseStyleIndexArray(objectIO, header, styleIndexArrayIndex); // parse string pool. if (header.stringCount != 0) { final long stringPoolIndex = stringPoolHeaderIndex + header.stringStart; stringPool = parseStringPool(objectIO, header, stringPoolIndex); } else { stringPool = new String[0]; } // parse style pool. if (header.styleCount != 0) { final long stylePoolIndex = stringPoolHeaderIndex + header.styleStart; stylePool = parseStylePool(objectIO, header, stylePoolIndex); } else { //noinspection unchecked stylePool = new List[0]; } } public ResStringPoolRef[] getStringIndexArray() { return stringIndexArray; } public ResStringPoolRef[] getStyleIndexArray() { return styleIndexArray; } public String[] getStringPool() { return stringPool; } public List&lt;ResStringPoolSpan&gt;[] getStylePool() { return stylePool; }} Resource Ids Chunk解析如下，根据 Chunk 头部，解析出 id 数量，然后逐个解析。 12345678910111213// AXmlParser.javaprivate void parse(ObjectInput objectInput) throws IOException { // ... ResChunkHeader header = objectInput.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_XML_RESOURCE_MAP_TYPE: parseResourceIds(objectInput); break; ... }} 12345678910111213141516171819// AXmlParser.javaprivate void parseResourceIds(ObjectInput objectInput) throws IOException { ResChunkHeader header = objectInput.read(ResChunkHeader.class, mIndex); // 解析 xml 文件中出现的资源 ID。 final int size = header.size; final int count = (size - header.headerSize) / Integer.BYTES; int index = mIndex + header.headerSize; for (int i = 0; i &lt; count; i++) { // 转化为 16 进制输出。 System.out.println(&quot;resId: &quot; + Formatter.toHex(Formatter.fromInt( objectInput.readInt(index), true ))); index += i * Integer.BYTES; } mIndex += header.size;} XML Content Chunk解析来是解析 XML 内容，每种 XML Chunk 都包含有相同的头部结构 struct ResXMLTree_node，它包含一个 XML Chunk 块的基本信息和行号，所以需要首先解析它。 Start Namespace Chunk直接解析即可： 12345678910111213// AXmlParser.javaprivate void parse(ObjectInput objectInput) throws IOException { // ... ResChunkHeader header = objectInput.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_XML_START_NAMESPACE_TYPE: parseStartNamespace(objectInput); break; ... }} 1234567891011121314151617181920// AXmlPArser.javaprivate void parseStartNamespace(ObjectInput objectInput) throws IOException { ResXMLTreeNode node = objectInput.read(ResXMLTreeNode.class, mIndex); // 跳过已解析过的头部字节。 int namespaceExtIndex = mIndex + node.header.headerSize; // 解析注释。 System.out.println(&quot;node comment: &quot; + (node.comment.index != -1 ? stringPool[node.comment.index] : &quot;&quot;)); final ResXMLTreeNamespaceExt namespaceExt = objectInput.read(ResXMLTreeNamespaceExt.class, namespaceExtIndex); // 解析命名空间名字。 String namespace = stringPool[namespaceExt.prefix.index]; System.out.println(&quot;namepsace name: &quot; + namespace); // 解析命名空间 uri。 String namespaceUri = stringPool[namespaceExt.uri.index]; System.out.println(&quot;namepsace uri: &quot; + namespaceUri); mIndex += node.header.size;} Start Element Chunk直接上代码： 12345678910111213// AXmlParser.javaprivate void parse(ObjectInput objectInput) throws IOException { // ... ResChunkHeader header = objectInput.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_XML_START_ELEMENT_TYPE: parseStartElement(objectInput); break; ... }} 12345678910111213141516171819202122232425262728293031323334353637383940// AXmlParser.javaprivate void parseStartElement(ObjectInput objectInput) throws IOException { ResXMLTreeNode node = objectInput.read(ResXMLTreeNode.class, mIndex); System.out.println(&quot;node comment: &quot; + (node.comment.index != -1 ? stringPool[node.comment.index] : &quot;&quot;)); int index = mIndex + node.header.headerSize; ResXMLTreeAttrExt attrExt = objectInput.read(ResXMLTreeAttrExt.class, index); // 解析元素命名空间 uri。 String ns = attrExt.ns.index != -1 ? stringPool[attrExt.ns.index] : null; System.out.println(&quot;element ns: &quot; + ns); // 解析元素名字。 final String elementName = stringPool[attrExt.name.index]; System.out.println(&quot;element name: &quot; + elementName); // 跳过头部字节。 index += ObjectInput.sizeOf(ResXMLTreeAttrExt.class); // 解析元素属性。 for (int i = 0; i &lt; attrExt.attributeCount; i++) { ResXMLTreeAttribute attr = objectInput.read(ResXMLTreeAttribute.class, index); // 解析属性命名空间 uri。 final String namespace = attr.ns.index != -1 ? stringPool[attr.ns.index] : null; System.out.println(&quot;attr ns: &quot; + namespace); // 解析属性名字。 final String attrName = stringPool[attr.name.index]; System.out.println(&quot;attr name: &quot; + attrName); // 解析输属性文本或数值。 final String attrText = attr.rawValue.index != -1 ? stringPool[attr.rawValue.index] : null; System.out.println(&quot;attr text: &quot; + attrText); final String attrValue = attr.typeValue.dataStr(); System.out.println(&quot;attr value: &quot; + attr.typeValue); index += ObjectInput.sizeOf(ResXMLTreeAttribute.class); } mIndex += node.header.size;} 上面的属性数值可能为任何资源类型，其中 Res_Value 结构会包含资源类型，这里根据它的 dataType 简单解析了对应类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// ResValue.javapublic String dataStr() { switch (dataType) { case TYPE_NULL: return &quot;null&quot;; case TYPE_REFERENCE: return &quot;@&quot; + Formatter.toHex(Formatter.fromInt(data, true)); case TYPE_ATTRIBUTE: return &quot;@:id/&quot; + Formatter.toHex(Formatter.fromInt(data, true)); case TYPE_STRING: return &quot;stringPool[&quot; + data + ']'; case TYPE_FLOAT: return String.valueOf(data); case TYPE_DIMENSION: int complex = data &amp; (COMPLEX_UNIT_MASK &lt;&lt; COMPLEX_UNIT_SHIFT); switch (complex) { case COMPLEX_UNIT_PX: return data + &quot;px&quot;; case COMPLEX_UNIT_DIP: return data + &quot;dip&quot;; case COMPLEX_UNIT_SP: return data + &quot;sp&quot;; case COMPLEX_UNIT_PT: return data + &quot;pt&quot;; case COMPLEX_UNIT_IN: return data + &quot;in&quot;; case COMPLEX_UNIT_MM: return data + &quot;mm&quot;; default: return data + &quot;(dimension)&quot;; } case TYPE_FRACTION: return data + &quot;(fraction)&quot;; case TYPE_DYNAMIC_REFERENCE: return data + &quot;(dynamic_reference)&quot;; // case TYPE_FIRST_INT: return &quot;TYPE_FIRST_INT&quot;; case TYPE_INT_DEC: return String.valueOf(data); case TYPE_INT_HEX: return Formatter.toHex(Formatter.fromInt(data, true)); case TYPE_INT_BOOLEAN: return data == 0 ? &quot;false&quot; : &quot;true&quot;; // case TYPE_FIRST_COLOR_INT: return &quot;TYPE_FIRST_COLOR_INT&quot;; case TYPE_INT_COLOR_ARGB8: return data + &quot;(argb8)&quot;; case TYPE_INT_COLOR_RGB8: return data + &quot;(rgb8)&quot;; case TYPE_INT_COLOR_ARGB4: return data + &quot;(argb4)&quot;; case TYPE_INT_COLOR_RGB4: return data + &quot;(rgb4)&quot;; // case TYPE_LAST_COLOR_INT: return &quot;TYPE_LAST_COLOR_INT&quot;; // case TYPE_LAST_INT: return &quot;TYPE_LAST_INT&quot;; default: return Formatter.toHex(Formatter.fromInt(data, true)); }} CData Chunk12345678910111213// AXmlParser.javaprivate void parse(ObjectInput objectInput) throws IOException { // ... ResChunkHeader header = objectInput.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_XML_CDATA_TYPE: parseCData(objectInput); break; ... }} 1234567891011121314// AXmlParser.javaprivate void parseCData(ObjectInput objectInput) throws IOException { ResXMLTreeNode node = objectInput.read(ResXMLTreeNode.class, mIndex); System.out.println(&quot;node comment: &quot; + (node.comment.index != -1 ? stringPool[node.comment.index] : &quot;&quot;)); int index = mIndex + node.header.headerSize; ResXMLTreeCdataExt cdataExt = objectInput.read(ResXMLTreeCdataExt.class, index); // 解析标签内部内容。 final String cdata = stringPool[cdataExt.data.index]; System.out.println(&quot;cdata:&quot; + cdata); mIndex += node.header.size;} End Element Chunk12345678910111213// AXmlParser.javaprivate void parse(ObjectInput objectInput) throws IOException { // ... ResChunkHeader header = objectInput.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_XML_END_ELEMENT_TYPE: parseEndElement(objectInput); break; ... }} 12345678910111213141516171819// AXmlParser.javaprivate void parseEndElement(ObjectInput objectInput) throws IOException { ResXMLTreeNode node = objectInput.read(ResXMLTreeNode.class, mIndex); System.out.println(&quot;node comment: &quot; + (node.comment.index != -1 ? stringPool[node.comment.index] : &quot;&quot;)); int index = mIndex + node.header.headerSize; ResXMLTreeEndElementExt endElementExt = objectInput.read(ResXMLTreeEndElementExt.class, index); // 解析结束元素命名空间 Uri。 final String ns = endElementExt.ns.index != -1 ? stringPool[endElementExt.ns.index] : &quot;&quot;; System.out.println(&quot;element end ns: &quot; + ns); // 解析结束元素名字。 final String elementName = stringPool[endElementExt.name.index]; System.out.println(&quot;element end name: &quot; + elementName); mIndex += node.header.size;} End Namespace Chunk12345678910111213// AXmlParser.javaprivate void parse(ObjectInput objectInput) throws IOException { // ... ResChunkHeader header = objectInput.read(ResChunkHeader.class, mIndex); switch (header.type) { case ResourceTypes.RES_XML_END_NAMESPACE_TYPE: parseEndNamespace(objectInput); break; ... }} 123456789101112131415161718// AXmlParser.javaprivate void parseEndNamespace(ObjectInput objectInput) throws IOException { ResXMLTreeNode node = objectInput.read(ResXMLTreeNode.class, mIndex); System.out.println(&quot;node comment: &quot; + (node.comment.index != -1 ? stringPool[node.comment.index] : &quot;&quot;)); int index = mIndex + node.header.headerSize; ResXMLTreeNamespaceExt namespaceExt = objectInput.read(ResXMLTreeNamespaceExt.class, index); // 解析结束命名空间名字。 String namespace = stringPool[namespaceExt.prefix.index]; System.out.println(&quot;namepsace end name: &quot; + namespace); // 解析结束命名空间 uri。 String namespaceUri = stringPool[namespaceExt.uri.index]; System.out.println(&quot;namepsace end uri: &quot; + namespaceUri); mIndex += node.header.size;} XML 文档输出上面的解析只是将数值打印出来，看起来，并不直观，所以现在需求是将二进制的 XML 转化为一个可读且格式标准的 XML 文档。 这里首先定义了一个 AXmlEditor 负责将解析的数值输出为一个标准 XML 文档。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * Android XML 编辑工具。 */class AXmlEditor { private static final String ACTION_OPEN = &quot;open&quot;; private static final String ACTION_DATA = &quot;data&quot;; private static final String ACTION_CLOSE = &quot;close&quot;; private final StringBuilder xmlBuilder; private String tab = &quot;&quot;; private List&lt;String[]&gt; namespaceUris = new ArrayList&lt;&gt;(); private String lastAction; AXmlEditor() { xmlBuilder = new StringBuilder(); addHeader(); } private void addHeader() { xmlBuilder.append(&quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;utf-8\\&quot;?&gt;&quot;).append('\\n'); } /** 输入一个元素的开始 */ void openElement(String elementName) { // 上次是 open 操作，证明本次打开了子标签。 if (ACTION_OPEN.equals(lastAction)) { xmlBuilder.append(&quot;&gt;\\n&quot;); } xmlBuilder.append(tab).append('&lt;').append(elementName); // 最外层的标签添加命名空间。 if (!namespaceUris.isEmpty()) { for (String[] nu : namespaceUris) { xmlBuilder.append(' ') .append(&quot;xmlns:&quot;).append(nu[0]).append(&quot;=\\&quot;&quot;).append(nu[1]).append(&quot;\\&quot;&quot;); } namespaceUris.clear(); } // 每打开一个新元素就增加 tab。 tab = tab + &quot; &quot;; lastAction = ACTION_OPEN; } /** 输入一个命名空间的开始 */ void addNamespace(String namespace, String uri) { namespaceUris.add(new String[]{namespace, uri}); } /** 输入一个元素的属性 */ void addAttribute(String name, String value) { xmlBuilder.append(' ') .append(name).append(&quot;=\\&quot;&quot;).append(value).append(&quot;\\&quot;&quot;); } /** 输入一个元素的标签内容 */ void addData(String data) { xmlBuilder.append('&gt;').append(data); lastAction = ACTION_DATA; } /** 输入一个元素的结束 */ void closeElement(String elementName) { // 每关闭一个元素就减少 tab。 tab = tab.substring(2); StringBuilder t = new StringBuilder(); // 上次是 open 操作，证明不含有子标签。 if (ACTION_OPEN.equals(lastAction)) { t.append(&quot;&gt;&quot;); } else if (ACTION_CLOSE.equals(lastAction)) { t.append(tab); } t.append(&quot;&lt;/&quot;).append(elementName).append(&quot;&gt;\\n&quot;); // 空标签化简。 if (t.toString().contains(&quot;&gt;&lt;&quot;)) { t.delete(0, t.length()).append(&quot; /&gt;\\n&quot;); } xmlBuilder.append(t); lastAction = ACTION_CLOSE; } /** 输出 xml 文档 */ String print() { return xmlBuilder.toString(); }} 通过使用上面的解析器即可打印出如下形式的 XML 文档，除了相关资源需要对应的 arsc 文件才能解析出来，输出的文档和标准文档一致。 实例 AM.xml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:http://schemas.android.com/apk/res/android=&quot;android&quot; versionCode=&quot;2017082900&quot; versionName=&quot;1.2.455&quot; package=&quot;com.zuoxia.iconpack&quot; platformBuildVersionCode=&quot;25&quot; platformBuildVersionName=&quot;7.1.1&quot;&gt; &lt;uses-sdk minSdkVersion=&quot;16&quot; targetSdkVersion=&quot;25&quot; /&gt; &lt;uses-permission name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission name=&quot;android.permission.SET_WALLPAPER&quot; /&gt; &lt;uses-permission name=&quot;android.permission.SET_WALLPAPER_HINTS&quot; /&gt; &lt;uses-permission name=&quot;android.permission.WAKE_LOCK&quot; /&gt; &lt;uses-permission name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; &lt;uses-permission name=&quot;android.permission.VIBRATE&quot; /&gt; &lt;supports-screens anyDensity=&quot;true&quot; smallScreens=&quot;true&quot; normalScreens=&quot;true&quot; largeScreens=&quot;true&quot; resizeable=&quot;true&quot; xlargeScreens=&quot;true&quot; /&gt; &lt;uses-permission name=&quot;com.google.android.c2dm.permission.RECEIVE&quot; /&gt; &lt;permission name=&quot;com.zuoxia.iconpack.permission.C2D_MESSAGE&quot; protectionLevel=&quot;0x00000002&quot; /&gt; &lt;uses-permission name=&quot;com.zuoxia.iconpack.permission.C2D_MESSAGE&quot; /&gt; &lt;application theme=&quot;@0x7f0b0059&quot; label=&quot;@0x7f0800f2&quot; icon=&quot;@0x7f030000&quot; allowBackup=&quot;true&quot; largeHeap=&quot;true&quot; supportsRtl=&quot;true&quot;&gt; &lt;uses-library name=&quot;com.sec.android.app.multiwindow&quot; required=&quot;false&quot; /&gt; &lt;meta-data name=&quot;com.sec.android.support.multiwindow&quot; value=&quot;true&quot; /&gt; &lt;meta-data name=&quot;com.sec.android.multiwindow.DEFAULT_SIZE_W&quot; value=&quot;632.0dip&quot; /&gt; &lt;meta-data name=&quot;com.sec.android.multiwindow.DEFAULT_SIZE_H&quot; value=&quot;598.0dip&quot; /&gt; &lt;meta-data name=&quot;com.sec.android.multiwindow.MINIMUM_SIZE_W&quot; value=&quot;632.0dip&quot; /&gt; &lt;meta-data name=&quot;com.sec.android.multiwindow.MINIMUM_SIZE_H&quot; value=&quot;598.0dip&quot; /&gt; &lt;meta-data name=&quot;com.lge.support.SPLIT_WINDOW&quot; value=&quot;true&quot; /&gt; &lt;activity theme=&quot;@0x7f0b00d1&quot; label=&quot;@0x7f0800f2&quot; name=&quot;com.zuoxia.iconpack.HomeActivity&quot; noHistory=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;category name=&quot;android.intent.category.MULTIWINDOW_LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data name=&quot;android.app.shortcuts&quot; resource=&quot;@0x7f070008&quot; /&gt; &lt;/activity&gt; &lt;service name=&quot;com.zuoxia.iconpack.FirebaseService&quot;&gt; &lt;intent-filter&gt; &lt;action name=&quot;com.google.firebase.MESSAGING_EVENT&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;meta-data name=&quot;com.google.firebase.messaging.default_notification_icon&quot; resource=&quot;@0x7f02014d&quot; /&gt; &lt;meta-data name=&quot;com.google.firebase.messaging.default_notification_color&quot; resource=&quot;@0x7f0e0063&quot; /&gt; &lt;activity label=&quot;@0x7f0800f2&quot; name=&quot;jahirfiquitiva.iconshowcase.activities.ShowcaseActivity&quot;&gt; &lt;intent-filter&gt; &lt;action name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action name=&quot;android.intent.action.SET_WALLPAPER&quot; /&gt; &lt;category name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action name=&quot;android.intent.action.GET_CONTENT&quot; /&gt; &lt;category name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category name=&quot;android.intent.category.OPENABLE&quot; /&gt; &lt;data mimeType=&quot;image/*&quot; /&gt; &lt;/intent-filter&gt; ... &lt;intent-filter&gt; &lt;action name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;action name=&quot;com.lge.launcher2.THEME&quot; /&gt; &lt;category name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity theme=&quot;@0x7f0b0059&quot; label=&quot;@0x7f0800c6&quot; name=&quot;jahirfiquitiva.iconshowcase.activities.AltWallpaperViewerActivity&quot; /&gt; &lt;service label=&quot;@0x7f0800f9&quot; icon=&quot;@0x7f020149&quot; name=&quot;jahirfiquitiva.iconshowcase.services.MuzeiArtSourceService&quot; description=&quot;@0x7f0800f8&quot;&gt; &lt;intent-filter&gt; &lt;action name=&quot;com.google.android.apps.muzei.api.MuzeiArtSource&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data name=&quot;color&quot; value=&quot;@0x7f0e01be&quot; /&gt; &lt;meta-data name=&quot;settingsActivity&quot; value=&quot;jahirfiquitiva.iconshowcase.activities.MuzeiSettings&quot; /&gt; &lt;/service&gt; &lt;activity theme=&quot;@0x7f0b00d1&quot; label=&quot;@0x7f080080&quot; name=&quot;jahirfiquitiva.iconshowcase.activities.MuzeiSettings&quot; exported=&quot;true&quot; /&gt; &lt;receiver label=&quot;@0x7f080064&quot; icon=&quot;@0x7f020064&quot; name=&quot;jahirfiquitiva.iconshowcase.widgets.IconRestorerWidget&quot;&gt; &lt;intent-filter&gt; &lt;action name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data name=&quot;android.appwidget.provider&quot; resource=&quot;@0x7f070005&quot; /&gt; &lt;/receiver&gt; &lt;activity theme=&quot;@0x7f0b0108&quot; label=&quot;@0x7f0800f2&quot; name=&quot;jahirfiquitiva.iconshowcase.activities.LauncherIconRestorerActivity&quot; noHistory=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;receiver label=&quot;@0x7f080035&quot; name=&quot;jahirfiquitiva.iconshowcase.widgets.ClockWidget&quot;&gt; &lt;intent-filter&gt; &lt;action name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data name=&quot;android.appwidget.oldName&quot; value=&quot;com.android.deskclock.AnalogAppWidgetProvider&quot; /&gt; &lt;meta-data name=&quot;android.appwidget.provider&quot; resource=&quot;@0x7f070003&quot; /&gt; &lt;/receiver&gt; &lt;meta-data name=&quot;jahirfiquitiva.iconshowcase.utilities.GlideConfiguration&quot; value=&quot;GlideModule&quot; /&gt; &lt;service name=&quot;com.google.firebase.messaging.FirebaseMessagingService&quot; exported=&quot;true&quot;&gt; &lt;intent-filter priority=&quot;-500&quot;&gt; &lt;action name=&quot;com.google.firebase.MESSAGING_EVENT&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;receiver name=&quot;com.google.firebase.iid.FirebaseInstanceIdReceiver&quot; permission=&quot;com.google.android.c2dm.permission.SEND&quot; exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action name=&quot;com.google.android.c2dm.intent.RECEIVE&quot; /&gt; &lt;action name=&quot;com.google.android.c2dm.intent.REGISTRATION&quot; /&gt; &lt;category name=&quot;com.zuoxia.iconpack&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver name=&quot;com.google.firebase.iid.FirebaseInstanceIdInternalReceiver&quot; exported=&quot;false&quot; /&gt; &lt;service name=&quot;com.google.firebase.iid.FirebaseInstanceIdService&quot; exported=&quot;true&quot;&gt; &lt;intent-filter priority=&quot;-500&quot;&gt; &lt;action name=&quot;com.google.firebase.INSTANCE_ID_EVENT&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;provider name=&quot;com.google.firebase.provider.FirebaseInitProvider&quot; exported=&quot;false&quot; authorities=&quot;com.zuoxia.iconpack.firebaseinitprovider&quot; initOrder=&quot;100&quot; /&gt; &lt;meta-data name=&quot;com.google.android.gms.version&quot; value=&quot;@0x7f0d000e&quot; /&gt; &lt;/application&gt;&lt;/manifest&gt; 实例 layout.xml： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:http://schemas.android.com/apk/res/android=&quot;android&quot; xmlns:http://schemas.android.com/apk/res-auto=&quot;app&quot; layout_gravity=&quot;0x00000050&quot; id=&quot;@0x7f09002b&quot; background=&quot;@0x0106000d&quot; layout_width=&quot;-1&quot; layout_height=&quot;-2&quot;&gt; &lt;LinearLayout orientation=&quot;0&quot; id=&quot;@0x7f09002a&quot; background=&quot;@0x7f08044a&quot; paddingTop=&quot;@0x7f07006f&quot; paddingBottom=&quot;@0x7f07006f&quot; layout_width=&quot;-1&quot; layout_height=&quot;-2&quot; baselineAligned=&quot;false&quot;&gt; &lt;RelativeLayout id=&quot;@0x7f0900a1&quot; background=&quot;@:id/0x7f040199&quot; clipChildren=&quot;false&quot; layout_width=&quot;1dip&quot; layout_height=&quot;-2&quot; layout_weight=&quot;1065353216&quot;&gt; &lt;ImageView id=&quot;@0x7f0900a0&quot; padding=&quot;@0x7f07006f&quot; focusable=&quot;false&quot; clickable=&quot;false&quot; clipChildren=&quot;false&quot; layout_width=&quot;-2&quot; layout_height=&quot;-2&quot; layout_marginTop=&quot;@0x7f07006f&quot; layout_marginBottom=&quot;@0x7f07006f&quot; layout_centerInParent=&quot;true&quot; contentDescription=&quot;@0x7f100093&quot; srcCompat=&quot;@0x7f0804ee&quot; /&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout id=&quot;@0x7f090065&quot; background=&quot;@:id/0x7f040199&quot; clipChildren=&quot;false&quot; layout_width=&quot;1dip&quot; layout_height=&quot;-2&quot; layout_weight=&quot;1065353216&quot;&gt; &lt;ImageView id=&quot;@0x7f090064&quot; padding=&quot;@0x7f07006f&quot; focusable=&quot;false&quot; clickable=&quot;false&quot; layout_width=&quot;-2&quot; layout_height=&quot;-2&quot; layout_marginTop=&quot;@0x7f07006f&quot; layout_marginBottom=&quot;@0x7f07006f&quot; layout_centerInParent=&quot;true&quot; contentDescription=&quot;@0x7f100073&quot; srcCompat=&quot;@0x7f0804e3&quot; /&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout id=&quot;@0x7f090024&quot; background=&quot;@:id/0x7f040199&quot; clipChildren=&quot;false&quot; layout_width=&quot;1dip&quot; layout_height=&quot;-2&quot; layout_weight=&quot;1065353216&quot;&gt; &lt;ImageView id=&quot;@0x7f090023&quot; padding=&quot;@0x7f07006f&quot; focusable=&quot;false&quot; clickable=&quot;false&quot; layout_width=&quot;-2&quot; layout_height=&quot;-2&quot; layout_marginTop=&quot;@0x7f07006f&quot; layout_marginBottom=&quot;@0x7f07006f&quot; layout_centerInParent=&quot;true&quot; contentDescription=&quot;@0x7f100038&quot; srcCompat=&quot;@0x7f0804d4&quot; /&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout id=&quot;@0x7f09007a&quot; background=&quot;@:id/0x7f040199&quot; clipChildren=&quot;false&quot; layout_width=&quot;1dip&quot; layout_height=&quot;-2&quot; layout_weight=&quot;1065353216&quot;&gt; &lt;ImageView id=&quot;@0x7f090079&quot; padding=&quot;@0x7f07006f&quot; focusable=&quot;false&quot; clickable=&quot;false&quot; clipChildren=&quot;false&quot; layout_width=&quot;-2&quot; layout_height=&quot;-2&quot; layout_marginTop=&quot;@0x7f07006f&quot; layout_marginBottom=&quot;@0x7f07006f&quot; layout_centerInParent=&quot;true&quot; contentDescription=&quot;@0x7f100080&quot; /&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 源码AXmlParser 可直接打印标准格式的文档。 参考 Android应用程序资源的编译和打包过程分析","link":"/2020/05/04/android-%E4%BA%8C%E8%BF%9B%E5%88%B6-xml-%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"},{"title":"Android NDK 指南","text":"前言编写此文档的用意： 作为搭建基础 NDK 工程的教程； 作为入门 NDK 工程的参考手册。 NDK 工程构建可采用三种方式进行 NDK 工程的构建： 基于 Make 的 ndk-build，这是传统的 ndk-build 构建方式，使用 Makefile 方式进行构建，简洁高效； CMake 是新型的构建方式，CMake 具有跨平台的特性，通过 CMake 生成 Makefile 后再进行构建，CMake 的配置文件可读性更高； 其他编译系统，通过引入其他编译系统可对编译过程进行定制，例如引入 obfuscator-llvm 对源码进行混淆和压缩，增强源代码安全性。 下面是每种构建方式的基础示例，使用 Android Studio 4.0 和 NDK 21 进行如下构建。 Android.mk基于 Android.mk 的产物为 libfoo.so 的 NDK 基本工程搭建。 在 Android 工程的 src/main 下建立 jni 目录（Android.mk 工程的默认文件目录为 jni，也可指定其他目录进行构建，使用命令 ndk-build -C 目录），工程结构如下： 包含两个 .mk 文件用来描述 NDK 工程，和两个基本的 C++ 语言源文件，结构如下： 123456789src/main | +-- java +-- jni | +-- Android.mk +-- Application.mk +-- libfoo.h +-- libfoo.cpp 在 Android Studio 的当前 Module 配置中指明 Android.mk 文件路径: 12345678910// app-build.gradleandroid { ... externalNativeBuild { ndkBuild { path 'src/main/jni/Android.mk' } }} 编写 Android.mk 文件用于向 NDK 构建系统描述工程的 C/C++ 源文件以及共享库的属性。 123456789101112# Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)# 指定共享库名字，产出物为 libfoo.soLOCAL_MODULE := foo# 指定源代码文件，多个源代码文件使用空格分隔，换行在行尾使用 \\LOCAL_SRC_FILES := libfoo.cppinclude $(BUILD_SHARED_LIBRARY) 添加 Application.mk 用于描述 NDK 工程概要设置。 12345# Application.mk# 指定生成特定 ABI 的代码APP_ABI := armeabi-v7a arm64-v8aAPP_OPTIM := debug 在 java 目录创建 Java 类，用于声明 JNI 方法，提供给其他类调用。 12345678910// class io.l0neman.mkexample.NativeHandlerpublic class NativeHandler { static { // 加载 libfoo.so 库 System.loadLibrary(&quot;foo&quot;); } public static native String getHello();} 源代码： 123456789101112131415// libfoo.h#ifndef NDKTPROJECT_LIBFOO_H#define NDKTPROJECT_LIBFOO_H#include &lt;jni.h&gt;extern &quot;C&quot; {// 注册指定 Java 层的 JNI 方法JNIEXPORT jstring JNICALLJava_io_l0neman_mkexample_NativeHandler_getHello(JNIEnv *env, jclass clazz);}#endif //NDKTPROJECT_LIBFOO_H 123456// libfoo.cpp#include &quot;libfoo.h&quot;jstring Java_io_l0neman_mkexample_NativeHandler_getHello(JNIEnv *env, jclass clazz) { return env-&gt;NewStringUTF(&quot;Hello-jni&quot;);} 这样的话就完成了一个基本的 NDK 工程搭建，编译后调用代码即可得到 java 字符串 &quot;Hello-jni&quot;。 123// MainActivity.javaString hello = NativeHandler.getHello(); 提示 Android.mk 和 Application.mk 中可使用的系统变量请参考下文。 Android.mk 只是 Makefile 的片段，对于 Makefile 本身的熟悉有助于深入理解和编写 Android.mk，可参考 Makfile 指南 CMake使用 CMake 和 Android.mk 在 Android Studio 中的构建步骤类似，如下： 基于 CMake 的产出物为 libfoo.so 的 NDK 基本工程搭建。 在 Android 工程的 src/main 下建立 cpp 目录，工程结构如下： 包含一个 CMakeLists.txt 文件来描述 NDK 工程，和两个基本的 C++ 语言文件。 12345678src/main | +-- java jni | +-- CMakeLists.txt +-- libfoo.h +-- libfoo.cpp 在 Android Studio 的当前 Module 配置中指明 CMakeLists.txt 文件路径: 12345678910// app/build.gradleandroid { ... externalNativeBuild { cmake { path 'src/main/cpp/CMakeLists.txt' } }} 编写 CMakeLists.txt 文件用于向 NDK 构建系统描述工程的 C/C++ 源文件以及共享库的属性。 123456789101112# CMakeLists.txtcmake_minimum_required(VERSION 3.4.3)add_library( # 共享库名字，生产物为 libfoo.so foo # 编译为共享库 .so SHARED # 源代码文件，多个文件使用空格分隔或换行 main.cpp) 此时将 Android.mk 工程中的 Java 源文件 NativeHandler.java 复制过来，将 libfoo.cpp 和 libfoo.h 内容填入中即可直接编译测试。 独立工具链有时编译 NDK 工程有一些特殊需求，例如对代码进行混淆，加入第三方编译器 obfuscator-llvm 对 NDK 工程进行编译。这时就需要搭建第三方工具链的编译环境，将它加入 NDK 的一般构建过程中。 下面是一个引入 obfuscator-llvm 编译器编译代码的示例。 obfuscator-llvm 构建环境：android-ndk-r14b，目前已知此版本可支持 obfuscator-llvm 的编译配置 ndk r14b 下载地址：https://developer.android.google.cn/ndk/downloads/older_releases 首先下载编译器，指定最新版本的 obfuscator-llvm 分支，将仓库克隆至本地 1git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git 编译出编译器的可执行文件 过程如下，以下命令 Windows DOS 和 Linux Shell 中可通用： 进入编译器仓库目录中 cd obfuscator； 创建临时文件目录 mkdir build； 进入临时文件目录 cd build； 使用 CMake 生成 Makefile 或者 Vs 解决方案： 如果没有按照 CMake，可去 CMake 官网下载安装。 1cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ../ CMake 将会自动检测电脑上的编译器环境，如果是 Linux，生成 Makefile，如果 Windows 上安装了 Visual Studio，将生成解决方案文件。 编译编译器源代码： Linux 上执行： 1make -j4 Windows 平台建议使用 Visual Studio 进行编译，直接打开 build 中的 LLVM.sln，然后生成解决方案（Build Solution）。 编译过程需要持续 30 分钟或更长时间，取决于电脑配置 CPU 性能。 编译过程中有可能出现错误，需要自己解决出现的不同情况，编译完成后将生成所需的 bin 和 lib 目录（Release 中）。 配置 NDK 环境 设原始 NDK 工具链根目录为 android-ndk-r14b。 进入 android-ndk-r14b/toolchains 目录中，复制已存在的 llvm 目录到 ollvm-4.0，Linux 使用 cp llvm ollvm-4.0，Windows 复制文件出现 llvm-副本 后重命名为 ollvm-4.0。 Windows 平台将上面编译出来的 bin 和 lib 放入 ollvm-4.0/prebuilt/windows-x86_64 中，Linux 平台放入 ollvm-4.0/prebuilt/linux-x86_64 中，macOS 为 ollvm-4.0/prebuilt/darwin-x86_64。 进入 android-ndk-r14b/build/core/toolchains 中，在当前目录复制出如下目录： 1234arm-linux-androideabi-clang -&gt; arm-linux-androideabi-clang-ollvm4.0aarch64-linux-android-clang -&gt; aarch64-linux-android-clang-ollvm4.0x86-clang -&gt; x86-clang-ollvm4.0x86_64-clang -&gt; x86_64-clang-ollvm4.0 修改复制后的两个目录中的 setup.mk 文件： 1234android-ndk-r14b/build/core/toolchains/arm-linux-androideabi-clang-ollvm4.0/setup.mkandroid-ndk-r14b/build/core/toolchains/aarch64-linux-android-clang-ollvm4.0/setup.mkandroid-ndk-r14b/build/core/toolchains/arm-linux-androideabi-clang-ollvm4.0/setup.mkandroid-ndk-r14b/build/core/toolchains/x86_64-clang-ollvm4.0/setup.mk 将每个 setup.mk 中的如下内容： 1LLVM_TOOLCHAIN_PREBUILT_ROOT := $(call get-toolchain-root,llvm) 替换为： 12OLLVM_NAME := ollvm-4.0LLVM_TOOLCHAIN_PREBUILT_ROOT := $(call get-toolchain-root,$(OLLVM_NAME)) 此时使用 ndk-build 将可以识别编译器。复制 4 个目录的原因是为了支持编译出每种 ABI，（armeabi、armeabi-v7a、arm64-v8a，x86、x86_64）。 编译代码测试 进入 NDK 工程中，修改 Application.mk 和 Android.mk 如下： 12345# Application.mkAPP_ABI := armeabi-v7a arm64-v8a# 主要是此句指定编译器NDK_TOOLCHAIN_VERSION := clang-ollvm4.0 123456789101112131415# Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := libfoo.cpp# 添加 obfuscator-llvm 支持的各种参数，伪控制流、控制流展开、指令替换LOCAL_CFLAGS += -mllvm -bcf -mllvm -bcf_loop=3 \\ -mllvm -fla -mllvm -split \\ -mllvm -sub -mllvm -sub_loop=3include $(BUILD_SHARED_LIBRARY) 在包含源代码的 jni 目录下执行配置好的 NDK r14b 中的 ndk-build 编译即可。 验证结果 编译后，在 libs 中将出现 ABI 目录，使用 IDA Pro 打开 libfoo.so，左侧 Functions windos 中找一个简单函数（例如 JNI_OnLoad）打开，发现程序逻辑流程已被混淆的面目全非。 左下角的 Graph overview 可以直观的看到整个函数的逻辑流程，非常复杂，无法直接了解到原始逻辑。 构建技巧独立构建通常 NDK 构建过程需要依赖于 Android Studio 进行清理，构建等工作。 有时需要脱离 Android Studio，例如在无界面的服务器上独立构建，那么可以直接使用 ndk-build 命令行进行构建。 首先确认 NDK 的环境变量（将 NDK 工具链的根路径加入系统 PATH 变量）。然后直接在 jni 目录下打开终端（Windows 为 cmd），输入 ndk-build clean，将自动清理产生的 obj 文件和 libs 文件。 然后执行 ndk-build 即可构建出所需要的 so 文件，例如 libs/arm64-v8a/libfoo.so。 如果不想在 jni 目录中构建，可使用 -C 选项指定路径构建 ndk-build -C jni_new。 其他参数可参考官方文档：https://developer.android.google.cn/ndk/guides/ndk-build 提示 对于普通 Android Studio 中的工程，也可以使用这种方法构建。 首先把 gradle 中 Android.mk 路径配置去除。在默认的依赖配置里面可以看到，libs 目录已被加入依赖，就是说如果 libs 目录中有 so 文件，那么会被自动加入 apk 中。 12345// app/build.gradledependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) ...} 那么经过 ndk-build 构建后，可以直接运行 apk 工程，新的 libfoo.so 将被加入 apk 的 libs 目录中。 此时 Android Studio 构建和清理均不会影响 libs 中的 .so 文件，Java 代码和 NDK 开发代码可分别独立构建。 快速部署对于一个主要由 native 代码构成的应用来说，修改 native 代码的动作较为频繁，如果每次都 clean 然后重新 build，再依赖于 Android studio 的运行安装会可能会比较麻烦。有时也需要依赖于其他 IDE 来构建 NDK 工程（例如使用 Visual Studio），那么可以采用如下方法： 首次构建 NDK 工程后安装运行到手机上，然后后面每次构建出 so，使用 adb 命令直接将 so 文件 push 到应用的沙盒目录下，重新启动应用进程即可使用新版的 so 文件。 1adb push libfoo.so /data/data/io.l0neman.mkexample/lib/ 注意 so 文件的架构应与当前应用采用的 ABI 对应。 不过这样做的前提是设备拥有 root 权限，也可直接使用官方的 Android 模拟器，选择下载带有 GoogleApis 的模拟器 ROM，输入如下命令即可获取 root 权限： 12adb rootadb remount 之后 adb 将以 root 用户的身份运行。 Android.mk 变量参考变量命名规范NDK 构建系统保留了如下变量名称，在定义自己的变量时尽量避免这些规则： 以 LOCAL_ 开头的名称，例如 LOCAL_MODULE； 以 PRIVATE_、NDK_ 或 APP 开头的名称，构建系统内部使用了这些变量名； 小写名称，例如 my-dir，构建系统内部使用了这些变量名。 最好以 MY_ 附加在自己的变量开头。 NDK 定义的 include 变量 CLEAR_VARS 此变量指向一个用于清理变量的脚本，当包含它时，会清理几乎所有的 LOCAL_XXX 变量，不包含 LOCAL_PATH 变量，一般在描述新模块之前包含。 1include $(CLEAR_VARS) BUILD_EXECUTABLE 指明构建的产出物是一个可执行文件（无文件后缀名），需要在源代码中包含一个 main 函数。通常构建可执行文件用来测试或用于其他调试工具。 12345// foo.cppint main(int argv, char **args) { printf(&quot;Hello World!\\n&quot;); return 0;} 1include $(BUILD_EXECUTABLE) BUILD_SHARED_LIBRARY 指明构建的产出物是一个共享库（文件后缀为 .so），它会随着应用代码打包至 apk 中。 1include $(BUILD_SHARED_LIBRARY) BUILD_STATIC_LIBRARY 指明构建的产出物是一个静态库（文件后缀为 .a），它不会被打包至 apk 中，只是为了被其他 native 模块引用。 PREBUILT_SHARED_LIBRARY 用于描述预编译共享库的构建，此时 LOCAL_SRC_FILES 变量指向预编译库的路径。 12LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.soinclude $(PREBUILT_SHARED_LIBRARY) PREBUILT_STATIC_LIBRARY 用于描述预编译静态库的构建，此时 LOCAL_SRC_FILES 变量指向预编译库的路径。 12LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.ainclude $(PREBUILT_STATIC_LIBRARY) 目标信息变量构建系统会根据 APP_ABI 变量（在 Application.mk 中定义）指定的每个 ABI 分别解析一次 Android.mk，如下变量将在构建系统每次解析时被重新定义值。 TARGET_ARCH 对应 CPU 系列，为 arm、arm64、x86、x86_64。 TARGET_PLATFORM 指向 Android API 级别号，例如 Android 5.1 对应 22。可以这样使用： 123ifeq ($(TARGET_PLATFORM),android-22) # ... do something ...endif TARGET_ARCH_ABI 对应每种 CPU 对应架构的 ABI。 CPU and architecture Setting ARMv7 armeabi-v7a ARMv8 AArch64 arm64-v8a i6686 x86 x86-64 x86_64 检查 ABI： 123ifeq ($(TARGET_ARCH_ABI),arm64-v8a) # ... do something ...endif TARGET_ABI 目标 Android API 级别与 ABI 的串联值。检查在 Android API 级别 22 上运行的 64 位 ARM 设备： 123ifeq ($(TARGET_ABI),android-22-arm64-v8a) # ... do something ...endif 模块描述变量下面的变量用于向构建系统描述如可构建一个模块，每个模块都应遵守如下流程： 使用 CLEAR_VARS 变量清理与上一个模块相关的变量； 为用于描述模块的变量赋值； 包含 BUILD_XXX 变量以适当的构建脚本用于该模块的构建。 LOCAL_PATH 用于指定当前文件的路径，必须在 Android.mk 文件开头定义此变量。 CLEAR_VARS 指向的脚本不会清除此变量。 12# my-dir 是一个宏函数，返回当前 Android.mk 文件路径LOCAL_PATH := $(call my-dir) LOCAL_MODULE 用于向构建系统描述模块名称，对于 .so 和 .a 文件，系统会自动给名称添加 lib 前缀和文件扩展名。 12# 产出 libfoo.so 或 libfoo.aLOCAL_MODULE := foo LOCAL_MODULE_FILENAME 向构建系统描述模块的自定义名称，覆盖 LOCAL_MODULE 的名称。 123LOCAL_MODULE := foo# 产出 libnewfoo.so，但无法改变扩展名LOCAL_MODULE_FILENAME := libnewfoo LOCAL_SRC_FILES 向构建系统描述生成模块时所用的源文件列表，务必使用 Unix 样式的正斜杠 (/) 来描述路径，且避免使用绝对路径。 LOCAL_CPP_EXTENSION 为 C++ 源文件指定除 .cpp 外的扩展名。 1LOCAL_CPP_EXTENSION := .cxx 或指定多个： 1LOCAL_CPP_EXTENSION := .cxx .cpp .cc LOCAL_CPP_FEATURES 向构建系统指明代码所依赖于的特定 C++ 功能。避免使用 LOCAL_CPPFLAGS 声明，它会导致编译器将所有指定的标记用于所有模块。 12# 使用运行时信息LOCAL_CPP_FEATURES := rtti 12# 使用 C++ 异常LOCAL_CPP_FEATURES := exceptions 指定多个： 1LOCAL_CPP_FEATURES := rtti features LOCAL_C_INCLUDES 指定路径列表，以便在编译时添加到 include 搜索路径。搜索路径同时影响 ndk-gdb 调试路径。 1LOCAL_C_INCLUDES := sources/foo 通过 LOCAL_CFLAGS 或 LOCAL_CPPFLAGS 设置任何对应的包含标记前定义此变量。 LOCAL_CFLAGS 构建 C 和 C++ 源文件时构建系统要传递的编译器标记，LOCAL_CPPFLAGS 可仅为 C++ 源文件指定标记。 相关：GCC 编译器选项参考 https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html#C_002b_002b-Dialect-Options 12# 指定额外 include 路径，推荐用 LOCAL_C_INCLUDESLOCAL_CFLAGS += -I&lt;path&gt;, LOCAL_CPPFLAGS 只构建 C++ 源文件传递的一组编译器标记，放在 LOCAL_CFLAGS 变量定义的后面。 LOCAL_STATIC_LIBRARIES 存储当前模块依赖的静态库模块列表 如果当前模块是共享库或可执行文件，此变量强制这些库链接到生成的二进制文件； 如果当前模块是静态库，此变量指出依赖于当前模块的其他模块也会依赖于其列出的库。 LOCAL_SHARED_LIBRARIES 此变量列出此模块在运行时依赖的共享库模块。用于将相应的连链接信息嵌入到生成的文件中。 LOCAL_WHOLE_STATIC_LIBRARIES LOCAL_STATIC_LIBRARIES 的变体形式，表示链接器应将相关的库模块视为完整归档（链接所有符号，而不只是用到的），可参考 ld 链接器的 --whole-archive 选项。 LOCAL_LDLIBS 列出在构建共享库或可执行文件时使用的额外链接器标记，使用 -l 前缀来指明连接到特定系统库（一般用于链接 NDK 提供的公开系统库，例如 liblog）。 12# 链接 /system/lib/libz.so 模块LOCAL_LDLIBS := -lz LOCAL_LDFLAGS 列出构建系统在构建共享库或可执行文件时使用的其他链接器标记。 12# 在 ARM/X86 上使用 ld.bfd 链接器LOCAL_LDFLAGS += -fuse-ld=bfd 定义静态库时，构建系统会忽略此变量，ndk-build 会打印警告。 LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下，构建系统在尝试构建共享库时遇到未定义的引用，将会抛出“未定义的符号”错误，指定此变量为 true，将停用此检查（可能会导致运行时加载）。 定义静态库时，构建系统会忽略此变量，ndk-build 会打印警告。 LOCAL_ARM_MODE 默认情况下，构建系统会以 thumb 模式生成 ARM 目标二进制文件，其中每条指令都是 16 位宽，并与 thumb/ 目录中的 STL 库链接。将此变量定义为 arm 会强制构建系统以 32 位 arm 模式生成模块的对象文件。 1LOCAL_ARM_MODE := arm 或者对源文件名附加 .arm 后缀，指示构建系统仅以 arm 模式构建特定的源文件。 12# 以 ARM 模式编译 bar.c，但根据 LOCAL_ARM_MODE 的值构建 foo.cLOCAL_SRC_FILES := foo.c bar.c.arm 也可以在 Application.mk 文件中将 APP_OPTIM 设置为 debug，强制构建系统生成 ARM 二进制文件。指定 debug 会强制构建 ARM，因为工具链调试程序无法正确处理 Thumb 代码。 LOCAL_ARM_NEON 此变量仅在以 armeabi-v7a ABI 为目标时才有意义。它允许在 C 和 C++ 源文件中使用 ARM Advanced SIMD (NEON) 编译器固有特性，以及在 Assembly 文件中使用 NEON 指令 并非所有基于 ARMv7 的 CPU 都支持 NEON 扩展指令集。因此，必须执行运行时检测，以便在运行时安全地使用此代码。 12# 以 Thumb 和 NEON 支持编译 foo.c，以 Thumb 支持编译 bar.c，并以 ARM 和 NEON 支持编译 zoo.cLOCAL_SRC_FILES = foo.c.neon bar.c zoo.c.arm.neon 同时使用这两个后缀时，.arm 必须在 .neon 前面。 LOCAL_DISABLE_FORMAT_STRING_CHECKS 默认情况下，构建系统会在编译代码时保护格式字符串。这样的话，如果 printf 样式的函数中使用了非常量格式的字符串，就会强制引发编译器错误。 可通过将此变量的值设置为 true 将其停用，不建议停用。 LOCAL_EXPORT_CFLAGS 记录一组 C/C++ 编译器标记，这些标记将被添加到使用通过 LOCAL_STATIC_LIBRARIES 或 LOCAL_SHARED_LIBRARIES 变量所描述模块的其他模块的 LOCAL_CFLAGS 定义中。 如下，foo 模块被 bar 模块依赖，那么标记 -DFOO=1 将在 bar 模块构建时和 -DBAR=2 一起传递至编译器。 123456789101112include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := foo/foo.cLOCAL_EXPORT_CFLAGS := -DFOO=1include $(BUILD_STATIC_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := barLOCAL_SRC_FILES := bar.cLOCAL_CFLAGS := -DBAR=2LOCAL_STATIC_LIBRARIES := fooinclude $(BUILD_SHARED_LIBRARY) 构建系统单独编译 foo 模块时，不会将 -DFoo 标记传递至编译器。 如果有其他模块例如 zoo 依赖于 bar，那么标记将被传递。 LOCAL_EXPORT_CPPFLAGS 与 LOCAL_EXPORT_CFLAGS 相同，但仅适用于 C++ 标记。 LOCAL_EXPORT_C_INCLUDES 与 LOCAL_EXPORT_CFLAGS 相同，但适用于 C include 路径。 LOCAL_EXPORT_LDFLAGS 与 LOCAL_EXPORT_CFLAGS 相同，但适用于链接器标记。 LOCAL_EXPORT_LDLIBS 此变量与 LOCAL_EXPORT_CFLAGS 相同，用于指示构建系统将特定系统库的名称传递到编译器。请在您指定的每个库名称前附加 -l 构建系统会将导入的链接器标记附加到模块的 LOCAL_LDLIBS 变量值上。其原因在于 Unix 链接器的工作方式 对于静态库会很有用： 1234567891011include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := foo/foo.cLOCAL_EXPORT_LDLIBS := -lloginclude $(BUILD_STATIC_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := barLOCAL_SRC_FILES := bar.cLOCAL_STATIC_LIBRARIES := fooinclude $(BUILD_SHARED_LIBRARY) 那么构建系统在构建 libbar.so 时，将在链接器命令的末尾指定 -llog。告知链接器，由于 libbar.so 依赖于 foo，所以它也依赖于系统日志记录库。 LOCAL_SHORT_COMMANDS 当模块有很多源文件和/或依赖的静态或共享库时，请将此变量设置为 true，这样会强制构建系统将 @ 语法用于包含中间对象文件或链接库的归档。 此功能在 Windows 上可能很有用，在 Windows 上，命令行最多只接受 8191 个字符，这对于复杂的项目来说可能太少。它还会影响个别源文件的编译，而且将几乎所有编译器标记都放在列表文件内。 此功能会减慢构建速度。 LOCAL_THIN_ARCHIVE 构建静态库时，请设置为 true。这样会生成一个瘦归档，即一个库文件，其中不含对象文件，而只包含它通常包含的实际对象的文件路径。 在非静态库模块或预构建的静态库模块中，将会忽略此变量。 LOCAL_FILTER_ASM 请将此变量定义为一个 shell 命令，供构建系统用于过滤根据您为 LOCAL_SRC_FILES 指定的文件提取或生成的汇编文件。定义此变量会导致发生以下情况： 构建系统从任何 C 或 C++ 源文件生成临时汇编文件，而不是将它们编译到对象文件中； 构建系统在任何临时汇编文件以及 LOCAL_SRC_FILES 中所列任何汇编文件的 LOCAL_FILTER_ASM 中执行 shell 命令，因此会生成另一个临时汇编文件； 构建系统将这些过滤的汇编文件编译到对象文件中。 12345LOCAL_SRC_FILES := foo.c bar.SLOCAL_FILTER_ASM :=foo.c --1--&gt; $OBJS_DIR/foo.S.original --2--&gt; $OBJS_DIR/foo.S --3--&gt; $OBJS_DIR/foo.obar.S “1”对应于编译器，“2”对应于过滤器，“3”对应于汇编程序。过滤器必须是一个独立的 shell 命令，它接受输入文件名作为第一个参数，接受输出文件名作为第二个参数。例如： 12myasmfilter $OBJS_DIR/foo.S.original $OBJS_DIR/foo.Smyasmfilter bar.S $OBJS_DIR/bar.S NDK 提供的函数宏NDK 提供了一些 GNU Make 的函数宏，使用 $(call &lt;function&gt;) 调用求值，返回相应文本信息。 my-dir 返回最后包括的 makefile 的路径，通常是当前 Android.mk 的目录。 由于 GNU Make 的工作方式，这个宏实际返回的是构建系统解析构建脚本时包含的最后一个 makefile 的路径。因此，包括其他文件后就不应调用 my-dir，可以提前把返回值保存起来，避免受影响。 1234567891011MY_LOCAL_PATH := $(call my-dir)LOCAL_PATH := $(MY_LOCAL_PATH)# ... declare one moduleinclude $(LOCAL_PATH)/foo/`Android.mk`LOCAL_PATH := $(MY_LOCAL_PATH)# ... declare another module all-subdir-makefiles 返回位于当前 my-dir 路径所有子目录中的 Android.mk 文件列表 利用此函数，您可以为构建系统提供深度嵌套的源目录层次结构。默认情况下，NDK 只在 Android.mk 文件所在的目录中查找文件。 this-makefile 返回当前 makefile（构建系统从中调用函数）的路径。 parent-makefile 返回包含树中父 makefile 的路径（包含当前 makefile 的 makefile 的路径）。 grand-parent-makefile 返回包含树中祖父 makefile 的路径（包含当前父 makefile 的 makefile 的路径）。 import-module 此函数用于按模块名称来查找和包含模块的 Android.mk 文件： 1$(call import-module,&lt;name&gt;) 构建系统在 NDK_MODULE_PATH 环境变量所引用的目录列表中查找具有 &lt;name&gt; 标记的模块，并且自动包括其 Android.mk 文件 Application.mk 变量参考Application.mk 指定 NDK 工程的项目级设置。 许多参数具有模块等效项，例如，APP_CFLAGS 对应于 LOCAL_CFLAGS，基于特定模块的选项优于项目级的选项。 对于标记来说，如果两者都使用，那么特定于模块的标记将后出现在命令行中，因此它们会替换项目级设置。 APP_ABI 默认情况下，NDK 构建系统会为所有有效的 ABI 生成代码。可以使用 APP_ABI 设置为特定 ABI 生成代码。 Instruction set Value 32-bit ARMv7 APP_ABI := armeabi-v7a 64-bit ARMv8 (AArch64) APP_ABI := arm64-v8a x86 APP_ABI := X86 x86-64 APP_ABI := x86_64 All supported ABIs (default) APP_ABI：= all 可指定多个值： 1APP_ABI := armeabi-v7a arm64-v8a x86 Gradle 中的 externalNativeBuild 设置会忽略 APP_ABI。需要在 splits 块内部使用 abiFilters 块或 abi 块。 APP_ASFLAGS 要传递给项目中每个汇编源文件（.s 和 .S 文件）的编译器的标记。 ASFLAGS 与 ASMFLAGS 不同。后者专用于 YASM 源文件。 APP_BUILD_SCRIPT 如需从其他位置加载 Android.mk 文件，将 APP_BUILD_SCRIPT 设置为 Android.mk 文件的绝对路径。 Gradle 中的 externalNativeBuild 块将根据 externalNativeBuild.ndkBuild.path 变量自动设置此路径。 APP_CFLAGS 为项目中的所有 C/C++ 编译传递的标记。 APP_CLANG_TIDY 为项目中的所有模块启用 clang-tidy，将此标记设置为 True。默认为停用状态。 APP_CLANG_TIDY_FLAGS 要为项目中的所有 clang-tidy 执行传递的标记。 APP_CONLYFLAGS 要为项目中的所有 C 编译传递的标记。这些标记不会用于 C++ 代码。 APP_CPPFLAGS 要为项目中的所有 C++ 编译传递的标记。这些标记不会用于 C 代码。 APP_CXXFLAGS APP_CPPFLAGS 应优先于 APP_CXXFLAGS。 与 APP_CPPFLAGS 相同，但在编译命令中将出现在 APP_CPPFLAGS 之后。例如： 12APP_CPPFLAGS := -DFOOAPP_CXXFLAGS := -DBAR 以上配置将导致编译命令类似于 clang++ -DFOO -DBAR，而不是 clang++ -DBAR -DFOO。 APP_DEBUG 构建可调试的应用，将此标记设置为 True。 APP_LDFLAGS 关联可执行文件和共享库时要传递的标记。 这些标记对静态库没有影响。不会关联静态库。 APP_MANIFEST AndroidManifest.xml 文件的绝对路径。 默认情况下将使用 $(APP_PROJECT_PATH)/AndroidManifest.xml)（如果存在）。 使用 externalNativeBuild 时，Gradle 不会设置此值。 APP_MODULES 要构建的模块的显式列表。此列表的元素是模块在 Android.mk 文件的 LOCAL_MODULE 中显示的名称。 默认情况下，ndk-build 将构建所有共享库、可执行文件及其依赖项。仅当项目使用静态库、项目仅包含静态库或者在 APP_MODULES 中指定了静态库时，才会构建静态库。 不会构建导入的模块（在使用 $(call import-module) 导入的构建脚本中定义的模块），除非要在 APP_MODULES 中构建或列出的模块依赖导入的模块。 APP_OPTIM 定义为 release 或 debug。默认情况下，将构建 relase 模式的二进制文件。 release 模式会启用优化，并可能生成无法与调试程序一起使用的二进制文件。debug 模式会停用优化，以便可以使用调试程序。 应用清单的 &lt;application&gt; 标记中声明 android:debuggable 将导致此变量默认为 debug，而不是 release。将 APP_OPTIM 设置为 release 可替换此默认值。 使用 externalNativeBuild 进行构建时，Android Studio 将根据您的构建风格适当地设置此标记。 APP_PLATFORM 声明构建此应用所面向的 Android API 级别，并对应于应用的 minSdkVersion。 如果未指定，ndk-build 将以 NDK 支持的最低 API 级别为目标。最新 NDK 支持的最低 API 级别总是足够低，支持几乎所有有效设备。 将 APP_PLATFORM 设置为高于应用的 minSdkVersion 可能会生成一个无法在旧设备上运行的应用。在大多数情况下，库将无法加载，因为它们引用了在旧设备上不可用的符号。 使用 Gradle 和 externalNativeBuild 时，不应直接设置此参数。而应在模块级别 build.gradle 文件的 defaultConfig 或 productFlavors 块中设置 minSdkVersion 属性。这样就能确保只有在运行足够高 Android 版本的设备上安装的应用才能使用您的库。 NDK 不包含 Android 每个 API 级别的库，省略了不包含新的原生 API 的版本以节省 NDK 中的空间。ndk-build 按以下优先级降序使用 API： 匹配 APP_PLATFORM 的平台版本。 低于 APP_PLATFORM 的下一个可用 API 级别。例如，APP_PLATFORM 为 android-20 时，将使用 android-19，因为 android-20 中没有新的原生 API; NDK 支持的最低 API 级别。 APP_PROJECT_PATH 项目根目录的绝对路径。 APP_SHORT_COMMANDS LOCAL_SHORT_COMMANDS 的项目级等效项。 APP_STL 用于此应用的 C++ 标准库。 默认情况下使用 system STL。其他选项包括 c++_shared、c++_static 和 none。 APP_STRIP_MODE 要为此应用中的模块传递给 strip 的参数。默认为 --strip-unneeded。若要避免剥离模块中的所有二进制文件，请将其设置为 none。 APP_THIN_ARCHIVE 为项目中的所有静态库使用瘦归档，将此变量设置为 True。 APP_WRAP_SH 要包含在此应用中的 wrap.sh 文件的路径。 每个 ABI 都存在此变量的变体，ABI 通用变体也是如此： 12345APP_WRAP_SHAPP_WRAP_SH_armeabi-v7aAPP_WRAP_SH_arm64-v8aAPP_WRAP_SH_x86APP_WRAP_SH_x86_64 APP_WRAP_SH_&lt;abi&gt; 可能无法与 APP_WRAP_SH 结合使用。如果有任何 ABI 使用特定于 ABI 的 wrap.sh，所有 ABI 都必须使用该 wrap.sh。 NDK APINDK 开发几乎必须要使用到 NDK 提供的原生 API，最常用的就是 liblog，用来在 logcat 中打印日志，下面分别使用 Android.mk 和 CMake 引入日志库。 引入其他库方法一致，可用 NDK 库列表可参考官方文档：https://developer.android.google.cn/ndk/guides/stable_apis Android.mk非常简单，只需要在 Android.mk 文件中使用 LOCAL_LDLIBS 变量使用 -l 前缀描述需要连接的库即可： 123456789101112131415# Android.mkLOCAL_PATH := $(call my-dir)$(warning $(TARGET_PLATFORM))include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := libfoo.cpp# 添加日志库，需要添加其他库可直接使用空格分隔LOCAL_LDLIBS := -lloginclude $(BUILD_SHARED_LIBRARY) 此时在源代码中即可使用 android/log.h 引入日志打印方法了。 12345678910111213141516// libfoo.cpp#include &lt;android/log.h&gt;#include &quot;main.h&quot;#include &lt;android/log.h&gt;static const char *TAG = &quot;NDK&quot;;extern &quot;C&quot; {jstring Java_io_l0neman_mkexample_NativeHandler_getHello(JNIEnv *env, jclass clazz) { __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;log test.&quot;); return env-&gt;NewStringUTF(&quot;Hello-jni&quot;);}}; CMakeCMake 描述如下，首先使用 find_library 描述 NDK 库，再用 target_link_libraries 指定链接库： 12345678910111213141516171819202122# CMakeLists.txtcmake_minimum_required(VERSION 3.4.3)add_library( foo SHARED main.cpp)find_library( # 使用变量描述系统库 log-lib # 系统库名字 log)# 指定将前面描述的 log-lib 库链接到目标 foo 中target_link_libraries( foo ${log-lib}) 如果需要添加多个库，新增 find_library 块，添加另一个库的描述后，在 target_link_libraries 加入即可： 1234567891011121314# CMakeLists.txt...find_library( zip-lib z)target_link_libraries( foo ${log-lib} ${zip-lib}) 引入预编译库有时需要引入提前编译好或者第三方提供的 so 共享库，或是引入现成的 .a 静态库，那么根据情况进行如下配置。 引入动态库 首先在独立的 NDK 工程编译出一个共享库 libbar.so（创建 libbar Module），作为第三方库提供给其他 Module 使用。 工程目录结构： 123456jni | +-- Android.mk +-- Application.mk +-- libbar.h +-- libbar.cpp 测试代码： 1234567891011// libbar.h#ifndef NDKTPROJECT_LIBBAR_H#define NDKTPROJECT_LIBBAR_Hextern &quot;C&quot; {int bar_add(int a, int b);};#endif //NDKTPROJECT_LIBBAR_H 123456// libbar.cpp#include &quot;libbar.h&quot;int bar_add(int a, int b) { return a + b;} 12345678910# libbar/src/main/jni/Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := barLOCAL_SRC_FILES := libbar.cppinclude $(BUILD_SHARED_LIBRARY) 1234# libbar/src/main/jni/Application.mkAPP_ABI := armeabi-v7a arm64-v8a x86 x86_64APP_OPTIM := debug 使用命令行进入 jni 目录下，然后执行 ndk-build 编译出 4 种架构的 libbar.so 文件，在和 jni 同级的 libs 目录下。 1234567891011121314jnilibs | +-- armeabi-v7a | +-- libbar.so | +-- arm64-v8a | +-- libbar.so | +-- x86 | +-- libbar.so | +-- x86_64 +-- libbar.so 将每种架构目录复制到需要使用此库的 NDK 工程中（libfoo.so Module），在工程中新建 include 目录，将 libbar 的头文件复制过来，为了提供调用的接口。 工程目录结构： 123456789101112131415161718192021jni | +-- armeabi-v7a | +-- libbar.so | +-- arm64-v8a | +-- libbar.so | +-- x86 | +-- libbar.so | +-- x86_64 | +-- libbar.so | +-- include | +-- libbar.h | +-- Android.mk +-- Application.mk +-- libfoo.h +-- libfoo.cpp 编写 libfoo.so Module 的 Android.mk 文件，$(TARGET_ARCH_ABI) 为 NDK 编译时每种架构的名字。 1234567891011121314151617LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)# 描述预编译库动态库的名称LOCAL_MODULE := libbar-pre# 描述预编译动态库路径LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.so# 描述预编译动态库引入的头文件LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/includeinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := main.cpp# 描述要使用的共享库名称LOCAL_SHARED_LIBRARIES := libbar-preinclude $(BUILD_SHARED_LIBRARY) 此时当工程编译时，对应的 libbar.so 将会自动被加入到 apk 包中。 代码调用 123456789101112131415// libfoo.h#ifndef NDKTPROJECT_LIBFOO_H#define NDKTPROJECT_LIBFOO_H#include &lt;jni.h&gt;extern &quot;C&quot; {JNIEXPORT void JNICALLJava_io_l0neman_mkexample_NativeHandler_test(JNIEnv *env, jclass clazz);};#endif //NDKTPROJECT_LIBFOO_H 123456789// libfoo.cpp#include &quot;libbar.h&quot;#include &quot;libfoo.h&quot;void Java_io_l0neman_mkexample_NativeHandler_test(JNIEnv *env, jclass clazz) { int a = bar_add(1, 4); printf(&quot;%d\\n&quot;, a);} Java 层调用测试 1234567891011// class io.l0neman.mkexample.NativeHandlerpublic class NativeHandler { static { // 加载 libfoo.so 时，libbar 会被自动加载。 System.loadLibrary(&quot;foo&quot;); } public static native void test();} 12// MainActivity.javaNativeHandler.test(); 引入静态库 首先编译出 .a 后缀的静态库 libbar.a。 工程结构和上面引入动态库中的 libbar 工程一致，只需要将 Android.mk 文件中引入的 BUILD_SHARED_LIBRARY 变量修改为 BUILD_STATIC_LIBRARY 即可指定编译出静态库。 1234567891011# libbar/src/main/Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := barLOCAL_SRC_FILES := libbar.cpp# 指定编译出静态库include $(BUILD_STATIC_LIBRARY) 使用 ndk-build 编译后，不会产生和 jni 同级的 libs 目录，每种架构的 libbar.a 文件将出现在和 jni 同级的 obj 目录中。 目录结构如下： 1234567891011121314jniobj | +-- armeabi-v7a | +-- libbar.a | +-- arm64-v8a | +-- libbar.a | +-- x86 | +-- libbar.a | +-- x86_64 +-- libbar.a 在 libfoo.so 工程中引入静态库，步骤和引入动态库大同小异，把 obj 中每种架构的目录复制到需要使用此库的 NDK 工程中（libfoo.so），在工程中新建 include 目录，将 libbar 的头文件复制过来，为了提供调用的接口。 工程目录结构： 123456789101112131415161718192021jni | +-- armeabi-v7a | +-- libbar.a | +-- arm64-v8a | +-- libbar.a | +-- x86 | +-- libbar.a | +-- x86_64 | +-- libbar.a | +-- include | +-- libbar.h | +-- Android.mk +-- Application.mk +-- libfoo.h +-- libfoo.cpp 编写 libfoo.so 的 Android.mk 文件，$(TARGET_ARCH_ABI) 为 NDK 编译时每种架构的名字。 1234567891011121314151617LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)# 描述预编译静态库的名字LOCAL_MODULE := libbar-pre# 描述预编译静态库的位置LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.a# 描述预编译静态库引入的头文件LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/includeinclude $(PREBUILT_STATIC_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := main.cpp# 描述要使用的静态库名称LOCAL_STATIC_LIBRARIES := libbar-preinclude $(BUILD_SHARED_LIBRARY) 此时当工程编译时，对应的 libbar.a 将会自动编译到 libfoo.so 中，成为它的一部分。 最后引用头文件正常调用编译即可，参考引用动态库中的步骤 4。 CMake上面的两个示例均为 Android.mk 构建示例，使用 CMake 构建简要描述如下： 引入动态库 首先将前面 libbar.so 复制到 CMake 项目的 jniLibs 中，项目结构如下： 12345678910111213141516171819202122232425main | +-- cpp | | | +-- include | | | | | +-- libbar.h | | | +-- libfoo.cpp | +-- libfoo.h | +-- CMakeLists.txt | +-- jniLibs | +-- armeabi-v7a | +-- libbar.so | +-- arm64-v8a | +-- libbar.so | +-- x86 | +-- libbar.so | +-- x86_64 +-- libbar.so 将预编译库放在 jniLibs 下面是为了在编译时打包到 apk 中。 其中 libfoo.cpp 和 libfoo.h 与上述 Android.mk 中源码一致，重点关注 CMakeLists.txt： 12345678910111213141516171819202122232425262728cmake_minimum_required(VERSION 3.4.3)# 设置当前路径变量set(CURRENT_DIR ${CMAKE_SOURCE_DIR})add_library( foo SHARED main.cpp)# 描述预编译动态库 bar-libadd_library( bar-lib SHARED IMPORTED)# 设置预编译库 bar-lib 位置属性set_target_properties( bar-lib PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libbar.so)# 为上面预编译库指定头文件路径include_directories(include/)target_link_libraries( foo bar-lib) 编译测试即可。 引入静态库 将前面 libbar.a 复制到 CMake 项目的 cpp 中，项目结构如下： 123456789101112131415161718192021cpp | +-- include | | | +-- libbar.h | +-- libfoo.cpp +-- libfoo.h +-- CMakeLists.txt | +-- armeabi-v7a | +-- libbar.a | +-- arm64-v8a | +-- libbar.a | +-- x86 | +-- libbar.a | +-- x86_64 +-- libbar.a 由于静态库 .a 直接编译到目标文件 libfoo 中，所以不用放在 jniLibs 打包至 apk 中。 CMakeLists.txt： 12345678910111213141516171819202122232425262728cmake_minimum_required(VERSION 3.4.3)# 设置当前路径变量set(CURRENT_DIR ${CMAKE_SOURCE_DIR})add_library( foo SHARED main.cpp)# 描述预编译库静态库 bar-libadd_library( bar-lib STATIC IMPORTED)# 设置预编译库 bar-lib 位置属性set_target_properties( bar-lib PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/${ANDROID_ABI}/libbar.a)# 为上面预编译库指定头文件路径include_directories(include/)target_link_libraries( foo bar-lib) 编译测试即可。 参考https://developer.android.google.cn/ndk/guides/build","link":"/2020/07/14/android-ndk-%E6%8C%87%E5%8D%97/"},{"title":"Android init 进程启动分析","text":"前言Android 系统启动后，内核会创建 0 号内核进程 idle 进程，然后 idle 进程通过调用 kernel_thread 函数，以 kernel_init 函数作为参数，通过回调 kernel_init 函数执行可执行文件 /init 创建 Android 系统中的第一个用户级别的进程 init 进程，init 进程的 pid = 1，它是所有用户空间进程的始祖，init 进程会通过 fork 分裂出 servicemanager（Binder 服务管理服务）、zygote（Android 系统中第一个 Java 进程）以及 surfaceflinger（图形服务）等系统核心服务进程，理解 init 进程的启动过程以及所做的工作将为理解整个 Android 系统运行机制打下基础。 123// kernel 3.18 - init/main.ckernel_thread(kernel_init, NULL, CLONE_FS); 概述init 进程主要做了如下工作： 挂载 / 节点上的重要目录； 初始化内核 log（/dev/kmsg）； 加载系统属性，提供属性设置服务，根据属性值变化做出响应（触发 .rc 文件中命令或启停止服务）； 解析并执行 init.rc 文件，根据其内容描述启动相应服务，初始化相应设备节点； 负责子进程的善后工作，清理子进程，防止其成为僵尸进程，或者根据配置重启进程。 参考相关资料，对 Android 6.0.1 系统中 init 进程启动关键流程进行分析。 init 进程入口/init 可执行文件的对应代码在 /system/core/init/init.cpp 中，入口为 main 函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151// init.cppint main(int argc, char**argv) { // 用于执行其他守护进程，这里不用分析 if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) { return ueventd_main(argc, argv); } if (!strcmp(basename(argv[0]), &quot;watchdogd&quot;)) { return watchdogd_main(argc, argv); } // 设置默认的文件创建权限为 777 umask(0); // 设置 PATH 环境变量为 /sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin add_environment(&quot;PATH&quot;, _PATH_DEFPATH); // 第一阶段还处于内核空间，第二阶段处于 init 空间 bool is_first_stage = (argc == 1) || (strcmp(argv[1], &quot;--second-stage&quot;) != 0); // 设置存在于 initramdisk 中的 / 目录中的相关文件，其他内容则由 rc 文件进行设置 if (is_first_stage) { mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;); mkdir(&quot;/dev/pts&quot;, 0755); mkdir(&quot;/dev/socket&quot;, 0755); mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL); mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL); mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL); } // 必须在 / 以外的地方为 kmsg 和 null 创建设备节点，否则之后无法重新挂载 / 为只读， // 现在 tmpfs 已挂载在 /dev 上，可以跟外部世界沟通了 open_devnull_stdio(); // 初始化内核 log klog_init(); klog_set_level(KLOG_NOTICE_LEVEL); NOTICE(&quot;init%s started!\\n&quot;, is_first_stage ? &quot;&quot; : &quot; second stage&quot;); if (!is_first_stage) { // 指示后台固件加载程序的 booting 流程 close(open(&quot;/dev/.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); // 为属性服务创建内存空间 property_init(); process_kernel_dt(); process_kernel_cmdline(); // 从内核空间导出属性到内部，由 init 和其它属性使用 export_kernel_boot_props(); } // 初始化 SELinux，如果处于内核空间，则加载 SELinux 策略 selinux_initialize(is_first_stage); // 现在 SELinux 策略已经加载，如果此时处于内核空间，重新执行 init 以切换到 init 空间 if (is_first_stage) { if (restorecon(&quot;/init&quot;) == -1) { ERROR(&quot;restorecon failed: %s\\n&quot;, strerror(errno)); security_failure(); } char*path = argv[0]; char*args[] ={ path, const_cast &lt; char*&gt;(&quot;--second-stage&quot;), nullptr } ; if (execv(path, args) == -1) { ERROR(&quot;execv(\\&quot;%s\\&quot;) failed: %s\\n&quot;, path, strerror(errno)); security_failure(); } } // 这些目录必须在初始策略加载之前创建，因此需要将其安全上下文恢复到适当的值 INFO(&quot;Running restorecon...\\n&quot;); restorecon(&quot;/dev&quot;); restorecon(&quot;/dev/socket&quot;); restorecon(&quot;/dev/__properties__&quot;); restorecon_recursive(&quot;/sys&quot;); // 创建用于 epoll IO 多路复用机制的文件描述符 epoll_fd = epoll_create1(EPOLL_CLOEXEC); if (epoll_fd == -1) { ERROR(&quot;epoll_create1 failed: %s\\n&quot;, strerror(errno)); exit(1); } // 初始化子进程退出的信号处理函数，并调用 epoll_ctl 注册信号可读时触发的回调函数 signal_handler_init(); // 加载默认属性文件 /default.prop property_load_boot_defaults(); // 启动属性监听服务，调用 epoll_ctl 注册属性可读时触发的回调函数 start_property_service(); // 解析 /init.rc 文件 init_parse_config_file(&quot;/init.rc&quot;); // 执行从 /init.rc 文件中解析出的 early-init 流程 action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail); // 等待冷启动操作的队列完成 queue_builtin_action(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;); queue_builtin_action(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;); // 初始化实体组合键 queue_builtin_action(keychord_init_action, &quot;keychord_init&quot;); // 初始化控制台，在屏幕底部显示“Android” queue_builtin_action(console_init_action, &quot;console_init&quot;); // 触发 init.rc 文件中的 init 流程 action_for_each_trigger(&quot;init&quot;, action_add_queue_tail); queue_builtin_action(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;); // 充电模式下不挂载文件系统和启动核心服务 char bootmode[ PROP_VALUE_MAX]; if (property_get(&quot;ro.bootmode&quot;, bootmode) &gt; 0 &amp;&amp; strcmp(bootmode, &quot;charger&quot;) == 0) { // 执行 init.rc 文件中触发器为 on charger 触发器流程 action_for_each_trigger(&quot;charger&quot;, action_add_queue_tail); } else { action_for_each_trigger(&quot;late-init&quot;, action_add_queue_tail); } // 针对所有属性的触发器 queue_builtin_action(queue_property_triggers_action, &quot;queue_property_triggers&quot;); while (true) { if (!waiting_for_exec) { execute_one_command(); // 重启进程 restart_processes(); } int timeout = -1; if (process_needs_restart) { timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; } if (!action_queue_empty() || cur_action) { timeout = 0; } bootchart_sample( &amp; timeout); epoll_event ev; // 等待 epoll_fd 上的事件发生 int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp; ev, 1, timeout)); if (nr == -1) { ERROR(&quot;epoll_wait failed: %s\\n&quot;, strerror(errno)); } else if (nr == 1) { ((void( *)())ev.data.ptr)(); } } return 0;} init 首先处于内核空间，即 is_first_stage = true，在挂载几个关键设备节点和初始化 SELinux 之后，使用 exec 重新执行 init 进入 second stage，从而降低进程权限级别，从内核空间降低至 init 级别。 整个 init 流程所做的工作基本已经列举出来了，下面针对各个函数细节进行解析。 内核日志在 Android 系统提供的 log 系统未初始化前，使用内核的 log 系统进行日志输出。 123456789// init.cppint main(int argc, char** argv) { // ... klog_init(); // KLOG_NOTICE_LEVEL = 5 klog_set_level(KLOG_NOTICE_LEVEL); // ...} 1234567// klog.h#define KLOG_ERROR_LEVEL 3#define KLOG_WARNING_LEVEL 4#define KLOG_NOTICE_LEVEL 5#define KLOG_INFO_LEVEL 6#define KLOG_DEBUG_LEVEL 7 1234567891011121314151617181920212223242526272829303132// klog.c// 设置日志级别void klog_set_level(int level) { klog_level = level;}void klog_init(void) { if (klog_fd &gt;= 0) return; /* Already initialized */ // 打开 /dev/kmsg 设备节点 // 内核日志可通过 cat /dev/kmsg 获取 klog_fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC); if (klog_fd &gt;= 0) { return; } static const char* name = &quot;/dev/__kmsg__&quot;; if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 11) == 0) { klog_fd = open(name, O_WRONLY | O_CLOEXEC); unlink(name); }}void klog_writev(int level, const struct iovec* iov, int iov_count) { // 日志级别小于 klog_level 则输入内核日志中 if (level &gt; klog_level) return; if (klog_fd &lt; 0) klog_init(); if (klog_fd &lt; 0) return; TEMP_FAILURE_RETRY(writev(klog_fd, iov, iov_count));}// ... TEMP_FAILURE_RETRY 宏TEMP_FAILURE_RETRY 是系统代码中常用的宏，用于在调用函数失败时进行不断重新调用，然后获得返回值： 123456789#ifndef TEMP_FAILURE_RETRY#define TEMP_FAILURE_RETRY(exp) ({ \\ typeof (exp) _rc; \\ do { \\ _rc = (exp); \\ } while (_rc == -1 &amp;&amp; errno == EINTR); \\ _rc; \\})#endif 信号处理single_handler_init 用于处理子进程退出后的工作，通过捕捉 SIGCHLD 信号，根据 .rc 文件中的配置对子进程进行清理或者重启操作。 1234567// init.cppint main(int argc, char** argv) { // ... signal_handler_init(); // ...} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// signal_handler.cppstatic int signal_write_fd = -1;static int signal_read_fd = -1;static bool wait_for_one_process() { int status; // 挂起当前进程，等待子进程退出，返回 0 表示子进程未结束 pid_t pid = TEMP_FAILURE_RETRY(waitpid(-1, &amp;status, WNOHANG)); if (pid == 0) { return false; } else if (pid == -1) { ERROR(&quot;waitpid failed: %s\\n&quot;, strerror(errno)); return false; } // 查询相应系统服务 service* svc = service_find_by_pid(pid); std::string name; if (svc) { name = android::base::StringPrintf(&quot;Service '%s' (pid %d)&quot;, svc-&gt;name, pid); } else { name = android::base::StringPrintf(&quot;Untracked pid %d&quot;, pid); } NOTICE(&quot;%s %s\\n&quot;, name.c_str(), DescribeStatus(status).c_str()); if (!svc) { return true; } // 如果标志为 SVC_ONESHOT（启动后不管）或 SVC_RESTART（重启），那么杀死进程 if (!(svc-&gt;flags &amp; SVC_ONESHOT) || (svc-&gt;flags &amp; SVC_RESTART)) { NOTICE(&quot;Service '%s' (pid %d) killing any children in process group\\n&quot;, svc-&gt;name, pid); kill(-pid, SIGKILL); } // 移除 src 服务中所有创建过的 socket for (socketinfo* si = svc-&gt;sockets; si; si = si-&gt;next) { char tmp[128]; snprintf(tmp, sizeof(tmp), ANDROID_SOCKET_DIR&quot;/%s&quot;, si-&gt;name); unlink(tmp); } // 从服务列表移除 svc if (svc-&gt;flags &amp; SVC_EXEC) { INFO(&quot;SVC_EXEC pid %d finished...\\n&quot;, svc-&gt;pid); waiting_for_exec = false; list_remove(&amp;svc-&gt;slist); free(svc-&gt;name); free(svc); return true; } svc-&gt;pid = 0; svc-&gt;flags &amp;= (~SVC_RUNNING); // oneshot 类型的服务将被标记为 disabled 状态，然后退出 // except when manually restarted. if ((svc-&gt;flags &amp; SVC_ONESHOT) &amp;&amp; !(svc-&gt;flags &amp; SVC_RESTART)) { svc-&gt;flags |= SVC_DISABLED; } // disabled 和 reset 状态的进程不再自动重启 if (svc-&gt;flags &amp; (SVC_DISABLED | SVC_RESET)) { svc-&gt;NotifyStateChange(&quot;stopped&quot;); return true; } time_t now = gettime(); if ((svc-&gt;flags &amp; SVC_CRITICAL) &amp;&amp; !(svc-&gt;flags &amp; SVC_RESTART)) { if (svc-&gt;time_crashed + CRITICAL_CRASH_WINDOW &gt;= now) { if (++svc-&gt;nr_crashed &gt; CRITICAL_CRASH_THRESHOLD) { ERROR(&quot;critical process '%s' exited %d times in %d minutes; &quot; &quot;rebooting into recovery mode\\n&quot;, svc-&gt;name, CRITICAL_CRASH_THRESHOLD, CRITICAL_CRASH_WINDOW / 60); // 服务在 4 分钟内重启超过 4 次，则重启设备至 recovery 模式 android_reboot(ANDROID_RB_RESTART2, 0, &quot;recovery&quot;); return true; } } else { svc-&gt;time_crashed = now; svc-&gt;nr_crashed = 1; } } svc-&gt;flags &amp;= (~SVC_RESTART); svc-&gt;flags |= SVC_RESTARTING; // 执行 srv 服务中的 onrestart 命令 struct listnode* node; list_for_each(node, &amp;svc-&gt;onrestart.commands) { command* cmd = node_to_item(node, struct command, clist); cmd-&gt;func(cmd-&gt;nargs, cmd-&gt;args); } svc-&gt;NotifyStateChange(&quot;restarting&quot;); return true;}static void reap_any_outstanding_children() { while (wait_for_one_process()) { }}void register_epoll_handler(int fd, void (*fn)()) { epoll_event ev; // EPOLLIN 表示 fd 可读时触发 ev.events = EPOLLIN; // fn 为处理 fd 的调函数 ev.data.ptr = reinterpret_cast&lt;void*&gt;(fn); if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;ev) == -1) { ERROR(&quot;epoll_ctl failed: %s\\n&quot;, strerror(errno)); }}static void handle_signal() { char buf[32]; read(signal_read_fd, buf, sizeof(buf)); reap_any_outstanding_children();}static void SIGCHLD_handler(int) { if (TEMP_FAILURE_RETRY(write(signal_write_fd, &quot;1&quot;, 1)) == -1) { ERROR(&quot;write(signal_write_fd) failed: %s\\n&quot;, strerror(errno)); }}void signal_handler_init() { // 创建用于 SIGCHLD 信号的匿名 socket 读写通道 int s[2]; if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, s) == -1) { ERROR(&quot;socketpair failed: %s\\n&quot;, strerror(errno)); exit(1); } signal_write_fd = s[0]; signal_read_fd = s[1]; // 捕捉到 SIGCHLD 信号将写入 signal_write_fd 中 struct sigaction act; memset(&amp;act, 0, sizeof(act)); // 信号处理函数 act.sa_handler = SIGCHLD_handler; // SA_NOCLDSTOP 使父进程在子进程暂停或继续运行时不会收到 SIGCHLD 信号, // 那么在子进程退出时收到 act.sa_flags = SA_NOCLDSTOP; sigaction(SIGCHLD, &amp;act, 0); // 处理所有的子进程退出 reap_any_outstanding_children(); // 注册 signal_read_fd 可读时的回调为 handle_signal register_epoll_handler(signal_read_fd, handle_signal);} 当子进程退出时，内核将发出 SIGCHLD 信号，对于子进程的处理函数 singal_handler_init 流程概括如下： 首先建立一对 socket 匿名读写通道，从而持有一对读写文件描述符； 将子进程退出时的 SIGCHLD 信号回调函数（SIGCHLD_handler）绑定到 socket 写端，当有信号到来时，向写端写入“1”； 调用一次 reap_any_outstanding_children 处理目前子进程的退出情况； 使用 epoll_ctl IO 监听设置函数将 socket 读端的可读时机绑定到回调函数，当读端可被读取时（说明 socket 写端写入了数据），表明有子进程退出，此时调用回调函数（handle_signal）； handle_signal 处理子进程退出，使用 wait_for_one_process 等待子进程退出后，通过进程 pid 查询其所承载的服务，根据服务对应的标记，针对性的对进程进行清理或者重启处理。 时序图使用时序图描述上述流程： 属性服务12345678910111213141516// init.cppint main(int argc, const **args){ // ... if (!is_first_stage) { // ... property_init(); } // ... property_load_boot_defaults(); start_property_service(); // ...} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209// property_service.cppstatic workspace pa_workspace;void property_init() { // 防止重复初始化 if (property_area_initialized) { return; } property_area_initialized = true; // 使用 mmap 创建一块共享内存区域，用于写入属性 // 共享内存首地址保存至变量 __system_property_area__ 中 if (__system_property_area_init()) { return; } pa_workspace.size = 0; pa_workspace.fd = open(PROP_FILENAME, O_RDONLY | O_NOFOLLOW | O_CLOEXEC); if (pa_workspace.fd == -1) { ERROR(&quot;Failed to open %s: %s\\n&quot;, PROP_FILENAME, strerror(errno)); return; }}//...// 加载默认属性文件void property_load_boot_defaults() {2// PROP_PATH_RAMDISK_DEFAULT = &quot;/default.prop&quot; load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT, NULL);}static void load_properties_from_file(const char* filename, const char* filter) { Timer t; std::string data; if (read_file(filename, &amp;data)) { data.push_back('\\n'); load_properties(&amp;data[0], filter); } NOTICE(&quot;(Loading properties from %s took %.2fs.)\\n&quot;, filename, t.duration());}void start_property_service() { // PROP_SERVICE_NAME = &quot;property_service&quot; property_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0666, 0, 0, NULL); if (property_set_fd == -1) { ERROR(&quot;start_property_service socket creation failed: %s\\n&quot;, strerror(errno)); exit(1); } listen(property_set_fd, 8); register_epoll_handler(property_set_fd, handle_property_set_fd);}static void handle_property_set_fd(){ prop_msg msg; int s; int r; struct ucred cr; struct sockaddr_un addr; socklen_t addr_size = sizeof(addr); socklen_t cr_size = sizeof(cr); char * source_ctx = NULL; struct pollfd ufds[1]; // 阻塞超时时间 const int timeout_ms = 2 * 1000; int nr; // 监听属性服务 socket 描述符 if ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; 0) { return; } if (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; 0) { close(s); ERROR(&quot;Unable to receive socket options\\n&quot;); return; } ufds[0].fd = s; ufds[0].events = POLLIN; ufds[0].revents = 0; nr = TEMP_FAILURE_RETRY(poll(ufds, 1, timeout_ms)); if (nr == 0) { ERROR(&quot;sys_prop: timeout waiting for uid=%d to send property message.\\n&quot;, cr.uid); close(s); return; } else if (nr &lt; 0) { ERROR(&quot;sys_prop: error waiting for uid=%d to send property message: %s\\n&quot;, cr.uid, strerror(errno)); close(s); return; } // 收到属性设置命令 r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, sizeof(msg), MSG_DONTWAIT)); if(r != sizeof(prop_msg)) { ERROR(&quot;sys_prop: mis-match msg size received: %d expected: %zu: %s\\n&quot;, r, sizeof(prop_msg), strerror(errno)); close(s); return; } switch(msg.cmd) { // setprop 命令 case PROP_MSG_SETPROP: msg.name[PROP_NAME_MAX-1] = 0; msg.value[PROP_VALUE_MAX-1] = 0; // 判断属性名是否合法，只允许数字 + '.', '-', '@', ':' 或 '_' 符号 if (!is_legal_property_name(msg.name, strlen(msg.name))) { ERROR(&quot;sys_prop: illegal property name. Got: \\&quot;%s\\&quot;\\n&quot;, msg.name); close(s); return; } getpeercon(s, &amp;source_ctx); if(memcmp(msg.name,&quot;ctl.&quot;,4) == 0) { // 对 ctl.xxx 类似的控制属性进行响应，例如使用 shell 执行 setprop ctl.stop zygote 将停止 zygote 进程 close(s); if (check_control_mac_perms(msg.value, source_ctx)) { handle_control_message((char*) msg.name + 4, (char*) msg.value); } else { ERROR(&quot;sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\\n&quot;, msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid); } } else { // 检查是否有权限设置属性 if (check_perms(msg.name, source_ctx)) { // 设置属性 property_set((char*) msg.name, (char*) msg.value); } else { ERROR(&quot;sys_prop: permission denied uid:%d name:%s\\n&quot;, cr.uid, msg.name); } close(s); } freecon(source_ctx); break; default: close(s); break; }}static int property_set_impl(const char* name, const char* value) { size_t namelen = strlen(name); size_t valuelen = strlen(value); if (!is_legal_property_name(name, namelen)) return -1; if (valuelen &gt;= PROP_VALUE_MAX) return -1; if (strcmp(&quot;selinux.reload_policy&quot;, name) == 0 &amp;&amp; strcmp(&quot;1&quot;, value) == 0) {2 if (selinux_reload_policy() != 0) { ERROR(&quot;Failed to reload policy\\n&quot;);2 } } else if (strcmp(&quot;selinux.restorecon_recursive&quot;, name) == 0 &amp;&amp; valuelen &gt; 0) { if (restorecon_recursive(value) != 0) { ERROR(&quot;Failed to restorecon_recursive %s\\n&quot;, value); } } prop_info* pi = (prop_info*) __system_property_find(name); if(pi != 0) { // ro.x 属性一旦设定就无法更改 if(!strncmp(name, &quot;ro.&quot;, 3)) return -1; // 更新属性，写入为属性创建的共享内存区域 __system_property_update(pi, value, valuelen); } else { int rc = __system_property_add(name, namelen, value, valuelen); if (rc &lt; 0) { return rc; } } // 如果名字前缀为 &quot;net.&quot; 则视为 DNS 属性 if (strncmp(&quot;net.&quot;, name, strlen(&quot;net.&quot;)) == 0) { if (strcmp(&quot;net.change&quot;, name) == 0) { return 0; } // &quot;net.change&quot; 是一个特殊的属性，用于跟踪 &quot;net.x&quot; 属性的更新， // 它的值包含最后一次设置的 &quot;net.*&quot; 属性 property_set(&quot;net.change&quot;, name); } else if (persistent_properties_loaded &amp;&amp; strncmp(&quot;persist.&quot;, name, strlen(&quot;persist.&quot;)) == 0) { // 不要将属性写入磁盘，直到读取了所有的默认属性，防止被默认属性覆盖 write_persistent_property(name, value); } // 通知属性被更改，将可能触发 init.rc 中的 property 触发器 property_changed(name, value); return 0;}int property_set(const char* name, const char* value) { int rc = property_set_impl(name, value); if (rc == -1) { ERROR(&quot;property_set(\\&quot;%s\\&quot;, \\&quot;%s\\&quot;) failed\\n&quot;, name, value); } return rc;} 概括属性服务初始化流程如下： property_init 为属性的设置和获取创建共享内存区域； property_load_boot_defaults 加载默认属性文件 /default.prop； start_property_service 启动属性设置服务，创建名为 property_service 的 socket 服务端，当接收到属性设置请求时，检查权限设置属性，阻止设置 ro.* 的属性，当设置 ctl.* 属性时作出相应处理，通知属性变更，触发 init.rc 中依赖的 property 触发器。 setprop 命令（实现代码在 external/toybox/toys/android/setprop.c），将会通过 socket 发送设置属性的请求。 除了上述属性初始化过程中加载的 /default.prop 属性文件，init 通过解析 init.rc 文件执行其中的 load_all_props 步骤（高系统版本为 load_system_props）还会从以下位置依次加载属性文件： 文件 描述 /default.prop 初始设置，此文件属于 initramfs，所以不存在于设备的闪存分区上 /system/build.prop 编译 Android 系统时产生的设置 /system/default.prop 通常为厂商添加的设置 /data/local.prop 编译时使用了 ALLOW_LOCAL_PROP_OVERRIDE 选项，且 ro.debuggable 属性被设置为 1 时，就会加载这个文件。那么开发者可以通过在 /data 分区 push 一个文件的方式，修改之前的设置 /data/proper/persist. 重启后不会丢失的属性，这些属性的前缀为 persist /factory/factory.prop 较新版本的 Android 不再支持了 init.rc 文件解析并根据 init.rc 文件内容启动相应的守护进程是 init 进程的核心工作，servicemanager 和 zygote 等服务均是 init 进程通过解析 init.rc 文件的创建的。 123456789101112// init.cppint main(int argc, char **argv){ // ... init_parse_config_file(&quot;/init.rc&quot;); action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail); // ... action_for_each_trigger(&quot;init&quot;, action_add_queue_tail); // ... return 0;} init_parse_config_file 首先解析 init.rc 文件，.rc 文件是用 .rc 文件的特定语法编写的，从 .rc 文件中可以解析出多个阶段的执行流程，例如 early-init，init 等，每个阶段有不同的意义。 init.rc 文件中还导入了许多子 .rc 文件，均是按照 .rc 文件语法编写。 .rc 文件语法.rc 文件的语法由 trigger 语句块和 service 语句块构成： trigger 语句块中的命令，会在满足触发条件时被触发执行；service 语句描述需要启动的守护进程。 trigger 语句块的格式是，使用 on 开头，后面跟一个参数，这个参数可以是各个启动阶段的名称（例如 early-init）或者一个 property 关键字，property 后面是冒号 +“属性名=属性值”的格式，这种情况下，触发条件为相应属性的属性值变更为指定的值； service 语句块的后面跟着服务名称和命令行。 语句块中执行指定动作（action）或命令（command），执行时，init 会分别把属性 init.action 或 init.command 的值设为当前正在执行的动作的名称或当前正在执行命令的名称。 service 语句块下面可以赋予多种选项（option），用来指示服务进程的运行规则，以及进程死亡后的重启规则。 init 启动阶段下面是 .rc 文件中的典型阶段（按启动顺序排列），根据设备不同，不同厂商可能对其进行定制： 启动阶段 内容 early-init 初始化的第一个阶段，用于设置 SELinux 和 OOM init 创建文件系统，mount 点以及写内核变量 late-init 初始化晚期，挂载文件系统，启动核心系统服务 early-fs 文件系统半准备被 mount 前需要完成的工作 fs 专门用于加载各个分区 post-fs 在各个文件系统（/data 分区除外）mount 完毕之后需要执行的命令 post-fs-data 解密 /data 分区（如果需要），并 mount 之 early-boot 在属性服务（property service）初始化之后，启动剩余内容之前的作业 boot 正常启动命令 charger 当手机处于充电模式时，需要执行的命令 init 支持的 command列举 .rc 文件中支持的大部分命令，一部分和 shell 命令具有相同作用： 命令 说明 bootchart_init 启用启动时的信任链验证 chdir directory 等价于 cd 命令（调用 chdir） chmod octal_perms file 修改文件的指定权限（以 8 进制表示） chown user group file 等价于 chown user:group file 命令 croot directory 等价于 Linux 的 chroot 命令（调用 chroot(2)） class_reset service_class 停止与 service_class 相关的所有服务 class_[start|stop] class 启动或者停止 class 参数指定的 service_class 的所有服务 copy src_file dst_file 类似 cp(1) 命令 exec command 执行命令 enable service 启动一个已被 disable 的服务 export varible value 在全局环境中，设置环境变量 varible 的值，影响所有进程 insmod module.ko 加载一个内核模块 load_all_props 加载所有位置属性 load_persist_props 加载 /data/propert 目录中的各个文件中的属性 loglevel level 设置内核的日志级别 mkdir directory 创建一个目录（调用 mkdir(2)） [re]start service_name 启动/重启服务名与参数 service_name 一致的语句块中的服务 rm[dir] filename 删除一个文件或一个目录（调用 unlink(2)/dmdir(2)） restorecon[_recursive] path 用 path 参数指定文件重新加载 SELinux 上下文 setcon SEcontext 设置 SELinux 的上下文，init 上下文为 u:r:init:s0 setenforce[0|1] 强制启用或关闭 SELinux setprop key value 设置指定的系统属性 stop service_name 停止服务名与参数 service_name 一致的语句块中的服务 symlink target src 创建一个符号连接 ln-s，即调用 symlink(2) trgger trigger_name 激活一个 trigger 语句块（会使 init 重新运行该语句块） wait file timeout 等待文件 file 创建完毕，等待超时为 timeout 秒 write file value 把 value 写到文件 file 中去，等价于 echo value &gt; file init 支持的 option枚举出 init 支持的各个 option 关键字： 选项 说明 capability 支持 Linux 的 capability(7) class 把服务加入服务组（service group），`可用 class[start console 把服务定义为一个 console 服务，stdin/stdout/stderr 会被 link 到 /dev/console 上 critial 把服务定义为一个关键服务，一旦崩溃，会自动重启，超过一定次数，系统将重启至 recovery 模式 disable 表示服务不需要启动但，之后还可以手动重启 group 指定服务以指定的 gid 启动，init 会调用 setgid(2) 来完成这个操作 ioprio 指定服务的 I/O 优先级，init 会调用 ioprio_set 来完成这个任务 keycodes 指定触发服务的组合键（key chord） oneshot 告诉 init 启动该服务，然后就不管它了（忽略掉 SIGCHLD 信号） onrestart 枚举该服务重启时要执行的命令，通常用来重启其他依赖服务（dependent service） seclabel 指定应用在该服务上 SELinux 标签（label） setenv 在服务被 fork() 出来并 exec() 之前，设置环境变量，只有该服务可看到 socket 打开一个 socket，让该服务继承这个 socket user 指定该服务以 uid 身份运行，init 将调用 setuid(2) 完成这个任务 writepid 把子进程的 pid 写入指定文件中，用于设置 cgroups 资源控制 关键服务启动查看一下 servicemanager、surfacefliger 和 zygote 服务在 init.rc 文件中的启动配置 12345678910111213141516171819202122# init.rc# ...service servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart healthd onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart restart drm# ...service surfaceflinger /system/bin/surfaceflinger class core user system group graphics drmrpc onrestart restart zygote# ... zygote 服务的启动在单独的 .rc 文件中，这个 rc 文件在 init.rc 的开头被导入： 123456789# init.rcimport /init.environ.rcimport /init.usb.rcimport /init.${ro.hardware}.rcimport /init.${ro.zygote}.rcimport /init.trace.rc# ... ${ro.zygote} 表示 32 位和 64 位 zygote，这里看一下 32 位 zygote 启动描述： 12345678910111213141516# init.zygote32.rcservice zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond writepid /dev/cpuset/foreground/tasks 所有的 service 里面只有 servicemanager、zygote、surfaceflinger 这 3 个服务有 onrestart 关键字来触发其他 service 启动过程。 可以看到它们之间的依赖关系： zygote 重启将会触发 audioserver、cameraserver、media 以及相关子进程（包括 system_server 进程）重启； system_server 重启将会触发 zygote 重启； surfaceflinger 重启将会触发 zygote 重启； servicemanager 重启将会触发 zygote、healthd、media、surfaceflinger、drm 重启。 class 表示依赖的服务组，看到 servicemanager 和 surfaceflinger 属于 core，而 zygote 属于 main。 在 init.rc 文件中查找这些服务组的启动时机： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# init.rc# ...on early-init# ...on init# ...on late-init trigger early-fs trigger fs trigger post-fs trigger post-fs-data trigger load_all_props_action trigger firmware_mounts_complete trigger early-boot trigger boot# ...on boot # ... class_start coreon nonencrypted class_start main class_start late_starton property:vold.decrypt=trigger_encryption start surfaceflinger start encrypton property:vold.decrypt=trigger_reset_main class_reset mainon property:vold.decrypt=trigger_post_fs_data trigger post-fs-dataon property:vold.decrypt=trigger_restart_min_framework class_start mainon property:vold.decrypt=trigger_restart_framework class_start main class_start late_starton property:vold.decrypt=trigger_shutdown_framework class_reset late_start class_reset main# ... 看到 core 服务组，在 boot 阶段被启动，优先与 main 服务组，boot 由 late-init 阶段触发；main 服务组在 vold.decrypt 属性被改变的多处时机被触发，这些属性将在 vold 服务启动时的相关流程被触发。 下面是 vold 服务的启动内容： 123456789# init.rcservice vold /system/bin/vold \\ --blkid_context=u:r:blkid:s0 --blkid_untrusted_context=u:r:blkid_untrusted:s0 \\ --fsck_context=u:r:fsck:s0 --fsck_untrusted_context=u:r:fsck_untrusted:s0 class core socket vold stream 0660 root mount socket cryptd stream 0660 root mount ioprio be 2 vold 是用于管理和控制 Android 外部存储介质的服务进程，它的实现代码在 system/vold/cryptfs.c 中。 zygote以 zygote 服务为出发点，分析启动一个服务的具体代码。 前面 init.cpp 中，调用 init_parse_config_file(&quot;/init.rc&quot;) 解析 init.rc 文件，内部会辗转调用到 parse_service 函数，它用来解析 service 信息，会创建一个 service 的结构体，保存服务进程的信息，同时创建了一个 socket，保存在结构体成员 socketinfo *sockets 中，同时 onrestart 相关的信息存放在成员 action onrestart 中，action 也是一个结构体，存放相关执行动作： 1234567891011121314151617181920212223// init.hstruct service { void NotifyStateChange(const char* new_state); struct listnode slist; char *name; const char *classname; unsigned flags; pid_t pid; // ... uid_t uid; gid_t gid; struct socketinfo *sockets; struct svcenvinfo *envvars; struct action onrestart; // ...}; 触发启动服务的代码由 do_class_start 函数负责，它的实现在 /system/core/init/builtins.cpp 中： 123456789101112131415static void service_start_if_not_disabled(struct service *svc){ if (!(svc-&gt;flags &amp; SVC_DISABLED)) { // 启动服务 service_start(svc, NULL); } else { svc-&gt;flags |= SVC_DISABLED_START; }}int do_class_start(int nargs, char **args){ service_for_each_class(args[1], service_start_if_not_disabled); return 0;} service_start 函数中会首先使用 fork 创建子进程，然后在子进程中调用 execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV) 执行 zygote 的可执行程序 /system/bin/app_process，从而进入 zygote 的流程中。 zygote 的实现代码在 /frameworks/base/cmds/app_process/app_main.cpp 中。 至于其他服务的启动，以此类推。 总结到这里就分析完了 init 进程的整个流程，这对于了解之后的系统服务的启动流程奠定了基础。 附录相关概念的解释 IO 多路复用阻塞 I/O（Blocking IO）： 例如用户进程使用 recvfrom 系统调用，kernel 开始准备数据，对于 Network IO，很多数据一开始没有到达，需要等待，此时用户进程将被阻塞，当 kernel 等到数据准备好的时候，将数据从内核空间拷贝到用户空间，返回结果，此时用户进程解除 block 状态。 IO 多路复用（IO multiplexing）： 和阻塞 IO 类似，在发出时会被阻塞，但可以等待多个数据报就绪（datagram ready），即可以处理多个链接。例如 select，它相当于一个代理，用户进程调用后会被阻塞，此时 select 在内核空间会监听多个 datagram（如 socket 连接），如果启动一个数据就绪了就返回。 僵尸进程僵尸进程是指当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程的资源，此时子进程将成为一个僵尸进程。如果父进程先退出，则子进程被 init 进程接管，子进程退出后 init 会回收其占用的相关资源。 系统会为僵尸进程保存一定的信息，包括 pid 和运行时间等，系统所能使用的进程号是有限的，如果产生大量的僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 僵尸进程的避免： 父进程通过 wait 和 waitpid 等函数等待子进程结束，这会导致父进程挂起； 如果父进程很忙，那么可以用 signal 函数为 SIGCHLD 安装 handler，因为子进程结束后， 父进程会收到该信号，可以在 handler 中调用 wait 回收； 如果父进程不关心子进程什么时候结束，那么可以用 signal（SIGCHLD，SIG_IGN） 通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号； 还有一些技巧，就是 fork 两次，父进程 fork 一个子进程，然后继续工作，子进程 fork 一个孙进程后退出，那么孙进程被 init 接管，孙进程结束后，init 会回收。不过子进程的回收 还要自己做。 参考 http://gityuan.com/2016/02/05/android-init/ https://blog.csdn.net/ljx0305/article/details/4065058 https://www.jianshu.com/p/6a6845464770 《最强 Android 书：架构大剖析》","link":"/2020/08/17/android-init-%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/"},{"title":"Android zygote 进程启动分析","text":"前言zygote 进程是 Android 系统中第一个拥有 Java 运行环境的进程，它由用户空间 1 号进程 init 进程通过解析 init.rc 文件创建，从 init 进程 fork 而来。从 zygote（受精卵）这个富含生物意义的名字可以知道，它是一个孵化器。Android 系统中所有运行在 Java 虚拟机中的系统服务以及应用均由 zygote 进程孵化而来。 理解 zygote 进程的启动过程以及所做的工作，将为理解 Java 层系统服务以及所有应用的进程启动流程打下基础。 概述zygote 通过克隆（fork）的方式创建子进程，fork 出来的子进程将继承父进程的所有资源，基于这个特性，zygote 进程在启动过程将创建 Java ART 虚拟机，预加载一个 Java 进程需要的所有系统资源，之后子进程被创建后，就可以直接使用这些资源运行了。 自 Android 5.0 系统开始，zygote 不再是一个进程，而是两个进程，一个是 32 位 zygote，负责孵化 32 位进程（为了兼容使用了 armeabi 和 armeabi-v7a 等 32 位架构的本地动态库的应用），另一个是 64 位 zygote 进程，负责孵化 64 位应用进程（可加载 arm64-v8a 等 64 位架构本地库）。 zygote 进程主要做了如下工作： 创建虚拟机，加载系统 Java 类以及注册系统类所依赖的 JNI 方法； 预加载应用程序进程所需的 drawable 和 color 资源，准备 WebView 和 OpenGL； 创建 socket 服务端，以便接收和处理创建应用进程的请求； 启动 system_server 服务进程，用于承载整个 framework 层运行的系统服务； 待命以随即处理到来的任务请求。 参考相关资料，对 Android 6.0.1 系统中 zygote 进程启动关键流程进行分析。 zygote 进程启动zygote 进程由 init 解析 init.rc 文件启动，首先看一下启动 zygote 的 rc 文件内容： 32 位 zygote 启动内容在 init.zygote32.rc 文件中，64 位 zygote 启动内容在 init.zygote64.rc 中： 提示：自 Android 9.0 系统开始，两个 zygote 启动配置放在一个文件中：init.zygote64_32.rc。 12345678910# init.zygote32.rcservice zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasks 12345678910# init.zygote64.rcservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasks 两者的唯一区别只在于可执行文件的不同，/system/bin/app_process 和 /system/bin/app_process64。 zygote 将在如下情况下重启： servicemanager 进程死亡（启动配置中包含 onrestart restart zygote）； surfaceflinger 进程死亡（启动配置中包含 onrestart restart zygote）； Zygote 死亡（启动配置中为非 oneshot）； system_server 进程死亡； zygote 进程入口zygote 可执行文件 app_process 的实现代码在 frameworks/base/cmds/app_process/app_main.cpp 中，入口为 main 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// app_main.cpp// ...#if defined(__LP64__)// 如果为 64 位进程，则进程名为 &quot;zygote64&quot;，否则为 &quot;zygote&quot;static const char ABI_LIST_PROPERTY[] = &quot;ro.product.cpu.abilist64&quot;;static const char ZYGOTE_NICE_NAME[] = &quot;zygote64&quot;;#elsestatic const char ABI_LIST_PROPERTY[] = &quot;ro.product.cpu.abilist32&quot;;static const char ZYGOTE_NICE_NAME[] = &quot;zygote&quot;;#endifint main(int argc, char* const argv[]){ if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) &lt; 0) { // 旧版内核不识别 PR_SET_NO_NEW_PRIVS，将返回 EINVAL，避免在旧版内核上死掉 if (errno != EINVAL) { LOG_ALWAYS_FATAL(&quot;PR_SET_NO_NEW_PRIVS failed: %s&quot;, strerror(errno)); return 12; } } // argv[0] = &quot;/system/bin/app_process&quot; AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // 跳过 argv[0] 参数 argc--; argv++; // 直到遇到 '-' 或第一个非 '-' 的参数为止的所有内容都将提供给虚拟机作为 options。 // // --zygote： 启动到 zygote 模式 // --start-system-server：启动 system server // --application： 以应用程序模式启动 (独立启动, 非 zygote) // --nice-name： 给进程起一个好名字 // // 对于非 zygote 启动，这些参数后面将是主类名，所有其余的参数都传递给此类的 main 方法； // 对于 zygote 启动，所有剩余的参数都传递给 zygote 的 main 方法。 int i; for (i = 0; i &lt; argc; i++) { if (argv[i][0] != '-') { break; } if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) { ++i; break; } runtime.addOption(strdup(argv[i])); } bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; ++i; while (i &lt; argc) { const char* arg = argv[i++]; if (strcmp(arg, &quot;--zygote&quot;) == 0) { zygote = true; niceName = ZYGOTE_NICE_NAME; } else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) { startSystemServer = true; } else if (strcmp(arg, &quot;--application&quot;) == 0) { application = true; } else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) { niceName.setTo(arg + 12); } else if (strncmp(arg, &quot;--&quot;, 2) != 0) { className.setTo(arg); break; } else { --i; break; } } Vector&lt;String8&gt; args; if (!className.isEmpty()) { // 没有处于 zygote 模式 args.add(application ? String8(&quot;application&quot;) : String8(&quot;tool&quot;)); runtime.setClassNameAndArgs(className, argc - i, argv + i); } else { // className 为空，处于 zygote 模式 // 创建 /data/dalvik-cache/ 目录 maybeCreateDalvikCache(); if (startSystemServer) { args.add(String8(&quot;start-system-server&quot;)); } char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) { LOG_ALWAYS_FATAL(&quot;app_process: Unable to determine ABI list from property %s.&quot;, ABI_LIST_PROPERTY); return 11; } String8 abiFlag(&quot;--abi-list=&quot;); abiFlag.append(prop); // 获取支持的 abi 列表 args.add(abiFlag); // 在 zygote 模式下，将所有剩余参数传递给 zygote 的 main() 方法。 for (; i &lt; argc; ++i) { args.add(String8(argv[i])); } } if (!niceName.isEmpty()) { // 设置进程名字 runtime.setArgv0(niceName.string()); set_process_name(niceName.string()); } if (zygote) { runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote); } else if (className) { runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote); } else { fprintf(stderr, &quot;Error: no class name or --zygote supplied.\\n&quot;); app_usage(); LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;); return 10; }} AppRuntime.main 函数做了如下工作： 创建了 AppRuntime 对象，传入虚拟机所需的选项； 解析 init.rc 文件的 zygote 启动参数； 调用 AppRuntime.start 函数，根据启动 zygote 还是命令行（className），进入 ZygoteInit 或者 RuntimeInit 参数分支。 提示：app_process 可使用命令行调用，启动一个 Java 类，并调用 main 方法，此时有 className 参数，处于非 zygote 模式。 格式： 1app_process [可选参数] 命令所在路径 启动的类名 [可选参数] 示例： 1app_process -Djava.class.path=Hello.dex /data/local/ com.example.Hello AppRuntim.start下面进入 AppRuntime 的 start 函数中，以 ZygoteInit 参数分支为路径进行分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// AndroidRuntime.cppvoid AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote){ ALOGD(&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n&quot;, className != NULL ? className : &quot;(unknown)&quot;, getuid()); static const String8 startSystemServer(&quot;start-system-server&quot;); for (size_t i = 0; i &lt; options.size(); ++i) { if (options[i] == startSystemServer) { const int LOG_BOOT_PROGRESS_START = 3000; LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START, ns2ms(systemTime(SYSTEM_TIME_MONOTONIC))); } } const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;); if (rootDir == NULL) { rootDir = &quot;/system&quot;; if (!hasDir(&quot;/system&quot;)) { LOG_FATAL(&quot;No root directory specified, and /android does not exist.&quot;); return; } setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1); } JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; // 创建虚拟机 if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) { return; } onVmCreated(env); // 注册系统类 JNI 方法 if (startReg(env) &lt; 0) { ALOGE(&quot;Unable to register all android natives\\n&quot;); return; } jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;); assert(stringClass != NULL); // Java: strArray = new String[options.size() + 1]; strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); // Java: strArray[0] = &quot;com.android.internal.os.ZygoteInit&quot;; env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); // 将相关参数收集至 options 中，下面会传递给 ZygoteInit // --start-system-server, --abi-list=arm64-v8a ... for (size_t i = 0; i &lt; options.size(); ++i) { jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); } // 转换为 JNI 格式类名：com/android/internal/os/ZygoteInit char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) { ALOGE(&quot;JavaVM unable to locate class '%s'\\n&quot;, slashClassName); } else { jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); if (startMeth == NULL) { ALOGE(&quot;JavaVM unable to find main() in '%s'\\n&quot;, className); } else { // 调用 ZygoteInit.main(); env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); } } free(slashClassName); ALOGD(&quot;Shutting down VM\\n&quot;); // 关闭 Java 虚拟机 if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW(&quot;Warning: unable to detach main thread\\n&quot;); if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW(&quot;Warning: VM did not shut down cleanly\\n&quot;);} 上面的代码也比较清晰，工作如下： startVm 函数创建 ART 虚拟机； startReg 函数注册系统 JNI 方法； 收集 options 参数，调用并传递给 ZygoteInit.main()。 下面针对每个方法具体分析。 AppRuntime.startVm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// AndroidRuntime.cppint AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote){ JavaVMInitArgs initArgs; // ... bool checkJni = false; property_get(&quot;dalvik.vm.checkjni&quot;, propBuf, &quot;&quot;); if (strcmp(propBuf, &quot;true&quot;) == 0) { checkJni = true; } else if (strcmp(propBuf, &quot;false&quot;) != 0) { property_get(&quot;ro.kernel.android.checkjni&quot;, propBuf, &quot;&quot;); if (propBuf[0] == '1') { checkJni = true; } } ALOGD(&quot;CheckJNI is %s\\n&quot;, checkJni ? &quot;ON&quot; : &quot;OFF&quot;); if (checkJni) { /* 扩展的 JNI 检查 */ addOption(&quot;-Xcheck:jni&quot;); /* 启用 -Xcheck:jni，它提供了 JNI 函数调用跟踪 */ //addOption(&quot;-verbose:jni&quot;); } parseRuntimeOption(&quot;dalvik.vm.zygote.max-boot-retry&quot;, cachePruneBuf, &quot;-Xzygote-max-boot-retry=&quot;); // ... property_get(&quot;dalvik.vm.execution-mode&quot;, propBuf, &quot;&quot;); if (strcmp(propBuf, &quot;int:portable&quot;) == 0) { executionMode = kEMIntPortable; } else if (strcmp(propBuf, &quot;int:fast&quot;) == 0) { executionMode = kEMIntFast; } else if (strcmp(propBuf, &quot;int:jit&quot;) == 0) { executionMode = kEMJitCompiler; } // ... // 默认的起始和最大堆大小，通常根据具体厂商硬件进行合适的配置 parseRuntimeOption(&quot;dalvik.vm.heapstartsize&quot;, heapstartsizeOptsBuf, &quot;-Xms&quot;, &quot;4m&quot;); parseRuntimeOption(&quot;dalvik.vm.heapsize&quot;, heapsizeOptsBuf, &quot;-Xmx&quot;, &quot;16m&quot;); parseRuntimeOption(&quot;dalvik.vm.heapgrowthlimit&quot;, heapgrowthlimitOptsBuf, &quot;-XX:HeapGrowthLimit=&quot;); parseRuntimeOption(&quot;dalvik.vm.heapminfree&quot;, heapminfreeOptsBuf, &quot;-XX:HeapMinFree=&quot;); parseRuntimeOption(&quot;dalvik.vm.heapmaxfree&quot;, heapmaxfreeOptsBuf, &quot;-XX:HeapMaxFree=&quot;); parseRuntimeOption(&quot;dalvik.vm.heaptargetutilization&quot;, heaptargetutilizationOptsBuf, &quot;-XX:HeapTargetUtilization=&quot;); // ... // 确保有可预加载的类文件，preloaded-classes 中存放了所有需要被预加载的系统 Java 类 if (!hasFile(&quot;/system/etc/preloaded-classes&quot;)) { ALOGE(&quot;Missing preloaded-classes file, /system/etc/preloaded-classes not found: %s\\n&quot;, strerror(errno)); return -1; } // ... 省略数百行 addOption 相关语句 // 解析 fingerprint 信息并提供给运行时，ANR dump 信息将包含 fingerprint 信息且能够解析 parseRuntimeOption(&quot;ro.build.fingerprint&quot;, fingerprintBuf, &quot;-Xfingerprint:&quot;); initArgs.version = JNI_VERSION_1_4; initArgs.options = mOptions.editArray(); initArgs.nOptions = mOptions.size(); initArgs.ignoreUnrecognized = JNI_FALSE; // 初始化虚拟机。JavaVM* 是基于进程的，而 JNIEnv* 是基于线程的， // 如果调用成功，表示虚拟机已就绪，可以开始 JNI 调用了。 if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) { ALOGE(&quot;JNI_CreateJavaVM failed\\n&quot;); return -1; } return 0;} 上述代码主要是为虚拟机初始化添加运行选项，最后调用 JNI_CreateJavaVM 创建虚拟机，下面就进入了虚拟机流程了，需要理解虚拟机时再探究其源码。 下面回到上面 AppRuntime.start 函数，看 startReg 的实现。 AppRuntime.startReg123456789101112131415161718192021222324// AndroidRuntime.cpp#define NELEM(x) (sizeof(x)/sizeof(*(x))) /*static*/ int AndroidRuntime::startReg(JNIEnv* env){ // 设置 Thread 创建函数，用于支持 Android Native 层线程封装 androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); ALOGV(&quot;--- registering native functions ---\\n&quot;); env-&gt;PushLocalFrame(200); // 注册 JNI 方法 if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) { env-&gt;PopLocalFrame(NULL); return -1; } env-&gt;PopLocalFrame(NULL); //createJavaThread(&quot;fubar&quot;, quickTest, (void*) &quot;hello&quot;); return 0;} 1234567891011121314151617181920212223242526272829303132// AndroidRuntim.cpp#define REG_JNI(name) { name, #name }struct RegJNIRec { int (*mProc)(JNIEnv*); const char* mName;};static const RegJNIRec gRegJNI[] = { REG_JNI(register_com_android_internal_os_RuntimeInit), REG_JNI(register_android_os_SystemClock), REG_JNI(register_android_util_EventLog), REG_JNI(register_android_util_Log), REG_JNI(register_android_content_AssetManager), REG_JNI(register_android_content_StringBlock), // ... 省略数百行 REG_JNI(register_android_animation_PropertyValuesHolder), REG_JNI(register_com_android_internal_content_NativeLibraryHelper), REG_JNI(register_com_android_internal_net_NetworkStatsFactory),};static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env){ for (size_t i = 0; i &lt; count; i++) { if (array[i].mProc(env) &lt; 0) {#ifndef NDEBUG ALOGD(&quot;----------!!! %s failed to load\\n&quot;, array[i].mName);#endif return -1; } } return 0; startReg 函数主要是注册系统类的 JNI 方法，使用 register_jni_procs 进行循环调用注册方法，每个 mProc 都指向 gRegJNI 数组里存放的结构体中的 mProc 函数指针，例如 register_com_android_internal_os_RuntimeInit，查看一下实现： 1234567891011121314static JNINativeMethod gMethods[] = { { &quot;nativeFinishInit&quot;, &quot;()V&quot;, (void*) com_android_internal_os_RuntimeInit_nativeFinishInit }, { &quot;nativeZygoteInit&quot;, &quot;()V&quot;, (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit }, { &quot;nativeSetExitWithoutCleanup&quot;, &quot;(Z)V&quot;, (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup },};int register_com_android_internal_os_RuntimeInit(JNIEnv* env){ return jniRegisterNativeMethods(env, &quot;com/android/internal/os/RuntimeInit&quot;, gMethods, NELEM(gMethods));} startReg 之后下面就是通过 env-&gt;CallStaticVoidMethod 启动 Zygoteinit.main 进入 Java 层了。 ZygoteInit.main1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// ZygoteInit.javapublic static void main(String argv[]) { try { RuntimeInit.enableDdms(); SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = &quot;zygote&quot;; String abiList = null; for (int i = 1; i &lt; argv.length; i++) { if (&quot;start-system-server&quot;.equals(argv[i])) { startSystemServer = true; } else if (argv[i].startsWith(ABI_LIST_ARG)) { abiList = argv[i].substring(ABI_LIST_ARG.length()); } else if (argv[i].startsWith(SOCKET_NAME_ARG)) { socketName = argv[i].substring(SOCKET_NAME_ARG.length()); } else { throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]); } } if (abiList == null) { throw new RuntimeException(&quot;No ABI list supplied.&quot;); } // 注册 socket 服务端 registerZygoteSocket(socketName); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); // 预加载资源 preload(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); SamplingProfilerIntegration.writeZygoteSnapshot(); // 在启动后执行初始 gc gcAndFinalize(); Trace.setTracingEnabled(false); if (startSystemServer) { // 启动 system_server startSystemServer(abiList, socketName); } Log.i(TAG, &quot;Accepting command socket connections&quot;); // 启动 socket 循环 runSelectLoop(abiList); closeServerSocket(); } catch (MethodAndArgsCaller caller) { caller.run(); } catch (RuntimeException ex) { Log.e(TAG, &quot;Zygote died with exception&quot;, ex); closeServerSocket(); throw ex; }} 上述代码做了如下工作： 使用 registerZygoteSocket 注册 socket 服务端，为能够接收创建子进程的请求提供支持； 使用 preload() 预加载应用进程所需资源； 启动 system_server 服务进程； 启动 socket 循环，等待外部请求，随时响应处理。 下面进入函数具体分析。 ZygoteInit.registerZygoteSocket12345678910111213141516171819202122232425262728// ZygoteInit.javaprivate static final String ANDROID_SOCKET_PREFIX = &quot;ANDROID_SOCKET_&quot;;// ...private static void registerZygoteSocket(String socketName) { if (sServerSocket == null) { int fileDesc; final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try { String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); } catch (RuntimeException ex) { throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex); } try { FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); // 创建了本地 socket 服务端 sServerSocket = new LocalServerSocket(fd); } catch (IOException ex) { throw new RuntimeException( &quot;Error binding to local socket '&quot; + fileDesc + &quot;'&quot;, ex); } }} 主要是要创建了本地服务端 socket 对象，命名为 ANDROID_SOCKET_zygote。 ZygoteInit.preload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// ZygoteInit.javastatic void preload() { Log.d(TAG, &quot;begin preload&quot;); // 预加载 /system/etc/preloaded-classes 文件中的系统类 preloadClasses(); // 预加载 drawable 和 color 资源 preloadResources(); // 预加载 OpenGL preloadOpenGL(); // 预加载共享库 preloadSharedLibraries(); // 预加载文本资源 preloadTextResources(); // WebView 相关初始化 WebViewFactory.prepareWebViewInZygote(); Log.d(TAG, &quot;end preload&quot;);}private static void preloadSharedLibraries() { Log.i(TAG, &quot;Preloading shared libraries...&quot;); System.loadLibrary(&quot;android&quot;); System.loadLibrary(&quot;compiler_rt&quot;); System.loadLibrary(&quot;jnigraphics&quot;);}private static void preloadOpenGL() { if (!SystemProperties.getBoolean(PROPERTY_DISABLE_OPENGL_PRELOADING, false)) { EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY); }}private static void preloadTextResources() { Hyphenator.init();}private static void preloadClasses() { final VMRuntime runtime = VMRuntime.getRuntime(); InputStream is; try { is = new FileInputStream(PRELOADED_CLASSES); } catch (FileNotFoundException e) { Log.e(TAG, &quot;Couldn't find &quot; + PRELOADED_CLASSES + &quot;.&quot;); return; } // ... try { BufferedReader br = new BufferedReader(new InputStreamReader(is), 256); int count = 0; String line; while ((line = br.readLine()) != null) { line = line.trim(); if (line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;)) { continue; } try {2// 预加载类 Class.forName(line, true, null); count++; } catch (ClassNotFoundException e) { Log.w(TAG, &quot;Class not found for preloading: &quot; + line); } catch (UnsatisfiedLinkError e) { Log.w(TAG, &quot;Problem preloading &quot; + line + &quot;: &quot; + e); } catch (Throwable t) { // ... throw new RuntimeException(t); } } Log.i(TAG, &quot;...preloaded &quot; + count + &quot; classes in &quot; + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;); } catch (IOException e) { Log.e(TAG, &quot;Error reading &quot; + PRELOADED_CLASSES + &quot;.&quot;, e); } finally { IoUtils.closeQuietly(is); runtime.setTargetHeapUtilization(defaultUtilization); // 使用已加载类填充 DexCaches runtime.preloadDexCaches(); // ... }}private static void preloadResources() { final VMRuntime runtime = VMRuntime.getRuntime(); try { mResources = Resources.getSystem(); mResources.startPreloading(); if (PRELOAD_RESOURCES) { Log.i(TAG, &quot;Preloading resources...&quot;); long startTime = SystemClock.uptimeMillis(); TypedArray ar = mResources.obtainTypedArray( com.android.internal.R.array.preloaded_drawables); int N = preloadDrawables(runtime, ar); ar.recycle(); Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot; + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;); startTime = SystemClock.uptimeMillis(); ar = mResources.obtainTypedArray( com.android.internal.R.array.preloaded_color_state_lists); N = preloadColorStateLists(runtime, ar); ar.recycle(); Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot; + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;); } mResources.finishPreloading(); } catch (RuntimeException e) { Log.w(TAG, &quot;Failure preloading resources&quot;, e); }}private static int preloadColorStateLists(VMRuntime runtime, TypedArray ar) { int N = ar.length(); for (int i=0; i&lt;N; i++) { int id = ar.getResourceId(i, 0); if (id != 0) { if (mResources.getColorStateList(id, null) == null) { throw new IllegalArgumentException( &quot;Unable to find preloaded color resource #0x&quot; + Integer.toHexString(id) + &quot; (&quot; + ar.getString(i) + &quot;)&quot;); } } } return N;}private static int preloadDrawables(VMRuntime runtime, TypedArray ar) { int N = ar.length(); for (int i=0; i&lt;N; i++) { int id = ar.getResourceId(i, 0); if (id != 0) { if (mResources.getDrawable(id, null) == null) { throw new IllegalArgumentException( &quot;Unable to find preloaded drawable resource #0x&quot; + Integer.toHexString(id) + &quot; (&quot; + ar.getString(i) + &quot;)&quot;); } } } return N;} 上面几乎把加载资源的所有代码都列了出来。 预加载这些资源的目的是为了将资源提前放置在内存中，当创建子进程的时候，可以直接使用这些资源，而不必每次都重新加载一遍。 ZygoteInit.startSystemServer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// ZygoteInit.javaprivate static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException { long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG ); String args[] = { &quot;--setuid=1000&quot;, &quot;--setgid=1000&quot;, &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;, &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities, &quot;--nice-name=system_server&quot;, &quot;--runtime-args&quot;, &quot;com.android.server.SystemServer&quot;, }; ZygoteConnection.Arguments parsedArgs = null; int pid; try { parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); // fork 出 system_server 进程并使用相关参数设置进程信息 pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); } catch (IllegalArgumentException ex) { throw new RuntimeException(ex); } if (pid == 0) { // 进入子进程 if (hasSecondZygote(abiList)) { // 等待另一个架构的 zygote 进程启动 waitForSecondaryZygote(socketName); } // 处理 system_server 剩余工作 handleSystemServerProcess(parsedArgs); } return true;} 上面的代码使用 Zygote.forkSystemServer fork 出了子进程，然后将相关参数设置给子进程，例如其中的 uid=1000 和 gid=1000，下面就进入 handleSystemServerProcess 方法，开始 system_server 的工作。 ZygoteInit.runSelectLoop12345678910111213141516171819202122232425262728293031323334353637383940414243private static void runSelectLoop(String abiList) throws MethodAndArgsCaller { ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) { StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) { pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; } try { // 监听 socket 连接，阻塞并等待描述符上的可读事件发生 Os.poll(pollFds, -1); } catch (ErrnoException ex) { throw new RuntimeException(&quot;poll failed&quot;, ex); } for (int i = pollFds.length - 1; i &gt;= 0; --i) { if ((pollFds[i].revents &amp; POLLIN) == 0) { continue; } if (i == 0) { // i = 0 表明还未添加收到的 socket 请求对象（sServerSocket.accept()） // 创建连接对象：new ZygoteConnection(sServerSocket.accept(), abiList); ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); // 添加到 fds 列表中待处理（下次循环将进行 Os.poll 等待描述符可读） fds.add(newPeer.getFileDesciptor()); } else { // i &gt; 0 表示 socket 请求经过 Os.poll 表示已经可读，那么对请求进行处理 boolean done = peers.get(i).runOnce(); if (done) { // 处理完则移除 peers.remove(i); fds.remove(i); } } } }} runSelectLoop 进入了无限循环，等待并对服务端 socket 接收到的请求进行处理，使用 runOnce 进行请求处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586boolean runOnce() throws ZygoteInit.MethodAndArgsCaller { String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try { // 解析 socket 客户端发送的命令列表 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); } catch (IOException ex) { Log.w(TAG, &quot;IOException on command socket &quot; + ex.getMessage()); closeSocket(); return true; } if (args == null) { closeSocket(); return true; } // ... int pid = -1; FileDescriptor childPipeFd = null; FileDescriptor serverPipeFd = null; try { // 创建参数封装对象 parsedArgs = new Arguments(args); if (parsedArgs.abiListQuery) { return handleAbiListQuery(); } // ... int [] fdsToClose = { -1, -1 }; FileDescriptor fd = mSocket.getFileDescriptor(); if (fd != null) { fdsToClose[0] = fd.getInt$(); } fd = ZygoteInit.getServerSocketFileDescriptor(); if (fd != null) { fdsToClose[1] = fd.getInt$(); } fd = null; // 创建子进程 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); } catch (ErrnoException ex) { logAndPrintError(newStderr, &quot;Exception creating pipe&quot;, ex); } catch (IllegalArgumentException ex) { logAndPrintError(newStderr, &quot;Invalid zygote arguments&quot;, ex); } catch (ZygoteSecurityException ex) { logAndPrintError(newStderr, &quot;Zygote security policy prevents request: &quot;, ex); } try { if (pid == 0) { // 进入子进程 IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; // 处理子进程逻辑 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); return true; } else { IoUtils.closeQuietly(childPipeFd); childPipeFd = null; // 父进程剩余工作 return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); } } finally { IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); }} handleChildProc 处理子进程： 1234567891011121314151617181920212223242526272829303132333435363738394041private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller { closeSocket(); // 关闭复制出来的服务端 socket ZygoteInit.closeServerSocket(); if (descriptors != null) { try { Os.dup2(descriptors[0], STDIN_FILENO); Os.dup2(descriptors[1], STDOUT_FILENO); Os.dup2(descriptors[2], STDERR_FILENO); for (FileDescriptor fd: descriptors) { IoUtils.closeQuietly(fd); } newStderr = System.err; } catch (ErrnoException ex) { Log.e(TAG, &quot;Error reopening stdio&quot;, ex); } } if (parsedArgs.niceName != null) { // 设置进程名字 Process.setArgV0(parsedArgs.niceName); } Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); if (parsedArgs.invokeWith != null) { WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); } else { // 会辗转调用到 ActivityThread.main 进入应用程序主流程 // 内部会抛出一个 ZygoteInit.MethodAndArgsCaller 异常（为了清空调用栈）， // 从而返回到上面 ZygoteInit 的 main 方法的 catch 语句块中执行 RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); }} 当子进程 fork 出来后，处理子进程，关闭 socket 资源，之后进入应用程序进程主流程。 整体流程图使用流程图表示 zygote 整个工作过程： 参考 http://gityuan.com/2016/02/13/android-zygote/","link":"/2020/08/24/android-zygote-%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/"},{"title":"ThemeFramework 主题切换框架实现","text":"前言自己做了一个主题切换框架，在这里毛遂自荐一下，小伙伴们看看有没有用，欢迎批评指正。 项目地址：https://github.com/l0neman/ThemeFramework 下面是项目的 README.md 自述文件。 ThemeFrameworkAndroid 即时主题切换框架 核心是基于属性（attrs.xml 中配置）可根据所属主题（themes.xml 中配置）的不同，获得每种主题下的对应资源。 使用形式是在布局中配置对应的主题属性，然后一行代码一键切换主题。 PS： 欢迎小伙伴们提出建议和贡献代码。 主要特点 低侵入性，不提供强制使用的控件 只提供主题属性以供布局中配置，可通过正则表达式搜索然后批量移除，不移除也不会对程序逻辑造成任何影响。 高扩展性，易于支持新的 View 只需提供自定义主题属性和将属性资源设置给 View 的逻辑，以框架开发者和框架使用者的角度对支持的 View 类型进行扩展均非常方便。 要求： 必须使用 androidx 提供的 AppCompatActivity 和 Fragment（几乎是 Android 开发必选项），因为它们都是 LifecycleOwner 的实现类，框架可以方便的监听组件的生命周期，便于在组件销毁时自动释放资源，避免使用者手动处理资源。 待优化： 提供的主题属性 Android Studio 不会自动提示，目前主题属性的命名是在对应 View 的原始属性之前添加 tf_ 前缀，所以较易书写； 主题属性在 Android Framework 提供的原生控件标签中会报红，因为 Android Studio 认为主题属性并非控件本身属性，虽然不影响编译，但是会令人不舒服。例如： 12345678&lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/selectableItemBackground&quot; android:textColor=&quot;?attr/appTextColor&quot; app:tf_background=&quot;selectableItemBackground&quot; app:tf_textColor=&quot;appTextColor&quot; /&gt; &lt;!-- 最后两行 IDE 会显示红色 --&gt; 建议解决办法： 使用相应的 androidx.appcompat.widget.AppCompatXXX 组件替代，就不会报红了，因为 Android Studio 认为 androidx Android Studio 允许使用未知属性。目前几乎所有的控件都有对应的 androidx 兼容性组件，除了 ListView、ProgressBar 零星组件； 1234567&lt;androidx.appcompat.widget.AppCompatButton android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/selectableItemBackground&quot; android:textColor=&quot;?attr/appTextColor&quot; app:tf_background=&quot;selectableItemBackground&quot; app:tf_textColor=&quot;appTextColor&quot; /&gt; 或者加入 tools:ignore=&quot;MissingPrefix&quot; 属性即可去除警告。 12345678&lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/selectableItemBackground&quot; android:textColor=&quot;?attr/appTextColor&quot; app:tf_background=&quot;selectableItemBackground&quot; app:tf_textColor=&quot;appTextColor&quot; tools:ignore=&quot;MissingPrefix&quot; /&gt; 快速开始 定义应用主题和主题属性 首先确定你的应用支持几种主题，例如支持白天主题和夜间主题，那么需要准备这两种主题所需的主题资源，通常是 color 和 drawable 资源。 例如，提供字体颜色和设置图标两个主题资源，那么首先在 attrs.xml 中自定义主题资源属性： 123456&lt;!-- attrs.xml --&gt;&lt;!-- 字体颜色，color 类型 --&gt;&lt;attr name=&quot;appTextColor&quot; format=&quot;color&quot; /&gt;&lt;!-- 设置图标，drawable 类型 --&gt;&lt;attr name=&quot;ic_settings&quot; format=&quot;reference&quot; /&gt; 然后在 themes.xml 定义每种主题，以及主题包含的主题资源属性对应的具体资源： 1234567891011121314151617&lt;!-- themes.xml --&gt;&lt;!-- 父主题 --&gt;&lt;style name=&quot;BaseTheme.Light&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;&lt;/style&gt;&lt;style name=&quot;BaseTheme.Dark&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;&lt;/style&gt;&lt;!-- 夜间主题，白色文本和图标 --&gt;&lt;style name=&quot;AppTheme.Black&quot; parent=&quot;BaseTheme.Dark&quot;&gt; &lt;item name=&quot;appTextColor&quot;&gt;#FFFFFF&lt;/item&gt; &lt;item name=&quot;ic_settings&quot;&gt;@drawable/ic_baseline_settings_white_24&lt;/item&gt;&lt;/style&gt;&lt;!-- 白天主题，黑色文本和图标 --&gt;&lt;style name=&quot;AppTheme.White&quot; parent=&quot;BaseTheme.Light&quot;&gt; &lt;item name=&quot;appTextColor&quot;&gt;#000000&lt;/item&gt; &lt;item name=&quot;ic_settings&quot;&gt;@drawable/ic_baseline_settings_black_24&lt;/item&gt;&lt;/style&gt; 主题资源准备完毕，下面可以进行主题切换了。 框架初始化 首先在应用的 Application 类的 onCreate 方法中初始化框架。 通常当应用的用户本次切换主题后，下次打开应用需要保证应用处于用户最后一次切换的主题，初始化就是为了设置用户最后一次的主题，同时保证每个 Activity 创建时都使用了当前的主题。 1234567public class MyApp extends Application { @Override public void onCreate() { super.onCreate(); // R.style.AppTheme 为应用首次启动默认的主题 ThemeFramework.getInstance().setup(this, R.style.AppTheme); }} 配置主题属性 下面以 TextView 和 ImageView 为例，实现不同主题下的文字颜色和图标。 在应用的 Activity 的布局中进行如下配置： 123456789101112&lt;androidx.appcompat.widget.AppCompatTextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;?attr/appTextColor&quot; app:tf_textColor=&quot;appTextColor&quot; /&gt;&lt;androidx.appcompat.widget.AppCompatImageView android:id=&quot;@+id/iv_icon&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; android:src=&quot;?attr/ic_settings&quot; app:tf_src=&quot;ic_settings&quot; /&gt; 首先配置 TextView 和 ImageView 的原始 android:textColor 和 android:src 属性，这样的话，Activity 启动后就能根据当前应用主题直接展示对应资源在 View 上的效果。但是还不能进行即时切换，这种方式只能在应用重启 Activity 后进行切换。 对于不需要即时切换主题的 Activity，配置原始属性就已经满足需求了。框架会在 Activity 的 setContentView 之前调用 setTheme，那么 Activity 的布局加载时就会自动加载对应主题的资源了。 如果需要即时切换主题，那么配置 ThemeFramework 提供的主题属性 app:tf_textColor 和 app:tf_src，把它们的值指定为对应的资源属性的名字，注意不能加 ?attr/ 前缀，而是直接指定属性名字，配置后，在切换主题时将会及时刷新 View 显示。 在 Activity 中绑定 在需要进行即时切换主题的 Activity 中对布局进行绑定，不需要即时切换的 Activity 则跳过此步骤。 1234567891011public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); View root = findViewById(R.id.root); // root 为 R.layout.activity_main 布局的根 View // 绑定的意思是框架会收集布局中的主题属性，将属性和对应的 View 联系起来 ThemeFramework.getInstance().bind(this, root, R.layout.activity_main); }} 切换主题 最后在合适的时机进行主题切换即可： 1ThemeFramework.getInstance().switchTheme(R.style.AppTheme_Black); 常用方法Fragmet如果 Fragment 中的布局需要实时切换主题，那么需要在 onCreateView 中进行绑定： 12345678910public class MyFragment extends Fragment { @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View root = View.inflate(getContext(), R.layout.fragment_my, null); ThemeFramework.getInstance().bind(this, root, R.layout.fragment_my); return root; }} Dialog对于 Dialog，支持布局的实时主题切换，在创建 Content View 时进行绑定： 1234567891011public class MyDialogHelper { ... private final AlertDialog mDialog; public MyDialogHelper(AppCompatActivity activity) { View contentView = View.inflate(context, R.layout.dialog_my, null); ThemeFramework.getInstance().bindView(activity, contentView, R.layout.dialog_my); mDialog = new AlertDialog.Builder(context).setView(contentView).create(); ... }} ListView 和 RecyclerView对于 ListView 和 RecyclerView 这种带有复用机制的控件，需要支持实时切换主题，则在 Adapter 中创建每个 Item View 时进行绑定： ListView 12345678910111213141516171819202122private final class MyListViewAdapter extends BaseAdapter { ... @Override public View getView(int position, View convertView, ViewGroup parent) { // ItemViewHolder 是自定义的 ViewHolder，为了缓存 Item View ItemViewHolder viewHolder; if (convertView != null) viewHolder = (ItemViewHolder) convertView.getTag(); else { // 创建新的 Item View，在此时进行绑定 View item = LayoutInflater.from(context).inflate(R.layout.item_test, parent, false); // 第一个参数为所在 Activity 或 Fragment ThemeFramework.getInstance().bindView(MyActivityOrFragment.this, item, R.layout.item_test); viewHolder = new ItemViewHolder(item); convertView = viewHolder.mItemView; convertView.setTag(viewHolder); } return viewHolder.mItemView; }} RecyclerView RecyclerView 在 Adapter 中的 onCreateViewHolder 进行绑定即可： 12345678910private final class MyRecyclerViewAdapter extends RecyclerView.Adapter&lt;ItemViewHolder&gt; { ... @NonNull @Override public ItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View item = LayoutInflater.from(context).inflate(R.layout.item_test, parent, false); // 第一个参数为所在 Activity 或 Fragment ThemeFramework.getInstance().bindView(MyActivityOrFragment.this, item, R.layout.item_test); return new ItemViewHolder(item); }} 动态添加 View对于动态添加到 Activity 或 Fragment 中的 View，分两种情况，一种是从布局文件加载，另一种是直接代码创建。 从布局加载 View 添加到 Activity 或 Fragment 后，使用 bindView 通知框架，加载的布局中的 View 支持主题属性： 1234View testView = View.inflate(context, R.layout.test_view, null);contentView.addView(testView);// 第一个参数为所在 Activity 或 FragmentThemeFramework.getInstance().bindView(MyActivityOrFragment.this, testView, R.layout.test_view); 从代码创建 从代码创建单个 View 时，由于不能在布局中配置属性，所以需要手动添加主题属性和对应的属性值。 View 添加到 Activity 或 Fragment 后，使用 addView 通知框架： 1234567891011TextView textView = new TextView(this);// contentView 可以是 Activity 或 Fragment 中的任意 ViewcontentView.addView(textView);// 创建对应 View 类型的主题属性适配器，然后动态添加属性ThemeAttributeAdapter&lt;? super TextView&gt; adapter = ThemeAttributeAdapterManager.getFactory(TextView.class).create();// 手动加入主题属性和对应值adapter.setAttribute(R.styleable.Attributes_Layout_tf_textColor, R.attr.appTextColor);adapter.setAttribute(R.styleable.Attributes_Layout_tf_background, R.attr.appBackgroundColor);// 第一个参数为所在 Activity 或 FragmentThemeFramework.getInstance().addView(MyActivityOrFragment.this, textView, adapter); 主题切换事件监听注册对主题切换事件的监听器： 123456ThemeChangeListener listener = new ThemeChangeListener() { @Override public void onThemeChanged(int theme) { // theme 为主题值，例如 R.style.AppTheme_White }};ThemeFramework.getInstance().registerThemeChangedListener(listener); 在合适的时机取消注册，避免框架持有监听器对象导致内存泄露： 1ThemeFramework.getInstance().unregisterThemeChangedListener(listener); 单个 View 主题设置监听对于单个 View 的主题切换事件监听，首先获取 View 对应的主题属性适配器，然后给主题适配器的添加 View 设置事件的监听。 这个 View 必须配置了主题属性，且处于绑定（调用 bind）后的 Activity 和 Fragment 中，因为绑定后框架会通过解析布局主题属性来给这个 View 创建对应的主题属性适配器，否则回调的主题属性适配器对象为 null。 如果 View 不想要配置任何主题属性，需要添加一个 app:tf_force=&quot;true&quot; 属性，那么框架会为这个 View 创建主题属性适配器。 123456789101112131415// 第一个参数为所在 Activity 或 Fragment，root 为根布局 View（bind 中的参数）ThemeFramework.getInstance().getAttributeAdapter(MyActivityOrFragment.this, root, toolbar, new ThemeFramework.ThemeAttributeAdapterCallback&lt;Toolbar&gt;() { @Override public void onThemeAttributeAdapter(ThemeAttributeAdapter&lt;Toolbar&gt; attributeAdapter) { // onThemeAttributeAdapter 将在 Activity 或 Fragment 的 onCreate 之后被回调 attributeAdapter.setOnSetViewListener(new ThemeAttributeAdapter.OnSetViewListener&lt;Toolbar&gt;() { @Override public void onSetView(Toolbar view, ThemeResources themeResources) { // 当 view 切换主题时此方法将会被回调，themeResource 是一个工具，提供了通过属性获取当前主题对应资源的方法 view.setBackgroundColor(themeResources.getColor(R.attr.appBackgroundColor)); // ... } }); } }); 扩展支持的 View 类型对于已支持的 View 和对应的主题属性，参考下表 View 类型支持情况。如果需要支持更多 View 和主题属性，需要对框架支持的 View 类型进行扩展。 支持一个新类型 View 非常简单，只需提供对应的主题属性以及主题属性作用到 View 上的逻辑，即提供一个主题属性适配器类。 以 TextView 为例，假如框架目前没有支持 TextView 类型，现在想要支持这个 View 类型，且提供一个 tf_textColor 属性来设置主题字体颜色，那么首先配置对应的主题属性，在 attrs.xml 中进行： 12345678910&lt;!-- attrs.xml --&gt;&lt;!-- TextView --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;Theme&quot;&gt; &lt;!-- 类型必须指定为 string，为了接收提供资源的属性名字 --&gt; &lt;attr name=&quot;tf_textColor&quot; format=&quot;string&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 然后创建 TextView 的主题属性适配器类： 1234567891011121314151617public class TextViewThemeAttributeAdapter extends ThemeAttributeAdapter&lt;TextView&gt; { @NonNull @Override public Collection&lt;Integer&gt; themeAttributes() { // 提供主题属性，可提供多个，这里只提供一个 return Collections.singletonList(R.styleable.Theme_tf_textColor); } @Override public boolean setView(TextView view, int themeAttribute, int attributeValue) { // 切换主题时，会将布局中的主题属性和资源属性值回调，在这里设置 View 即可 if (themeAttribute == R.styleable.Theme_tf_textColor) { view.setTextColor(getThemeResources().getColor(attributeValue)); // 返回 true 表示设置成功 return true; } return false; }} 这样就完成了新的 View 类型的主题支持，下面将主题属性适配器注册到框架即可。 所有的 View 类型与主题属性适配器的映射由 ThemeAttributeAdapterManager 统一管理，在这里进行注册。 从框架使用者角度进行扩展 提供需要支持 View 的类型以及对应的主题属性适配器对象的创建工厂即可： 123456ThemeAttributeAdapterManager.registerThemeAttribute(TextView.class, new ThemeAttributeAdapterManager.ThemeAttributeAdapterFactory&lt;TextView&gt;() { @NonNull @Override public ThemeAttributeAdapter&lt;TextView&gt; create() { return new TextViewThemeAttributeAdapter(); }}); 通常提供的主题属性适配器类创建对象调用默认构造器即可，可使用默认工厂： 12ThemeAttributeAdapterManager.registerThemeAttribute(TextView.class, new ThemeAttributeAdapterManager.DefaultThemeAttributeAdapterFactory&lt;&gt;(TextViewThemeAttributeAdapter.class)); 从框架开发者角度进行扩展 直接修改 ThemeAttributeAdapterManager 源代码，在静态块中进行注册： 1234567// ThemeAttributeAdapterManager.javastatic { ... VIEW_THEME_ATTRIBUTE_MAP.put(TextView.class, new ThemeAttributeAdapterManager.DefaultThemeAttributeAdapterFactory&lt;&gt;(TextViewThemeAttributeAdapter.class));} 提示： 注册时需要在框架绑定 Activity 或 Fragment 之前，可以在应用程序的 Application 类中进行； 注册与框架已支持的 View 类型相同时，新提供的主题属性适配器将会替换框架内置的主题属性适配器； 扩展规范 上面的示例是直接继承了 ThemeAttributeAdapter 来实现主题属性适配器的，这样的话 View 就只能支持 tf_textColor 一种主题属性，通常的写法是继承 ViewAttributeAdapter，它已经提供了 tf_background 属性的支持，继承它就可以将这个主题属性也继承过来。 同时主题属性适配器也可采用泛型，并非固定实现类型，这样可让子类继承，提高代码复用性。 然后对于主题属性的处理，可使用表驱动写法，避免大量的 if-else 块降低代码可读性，属性不是常量，无法使用 switch-case 做判断。 下面是框架中 ToolbarAttributeAdapter 的主题属性适配器的典型示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// ToolbarAttributeAdapter.java// 使用泛型，便于让子类进行扩展复用public class ToolbarAttributeAdapter&lt;T extends Toolbar&gt; extends ViewAttributeAdapter&lt;T&gt; { // Toolbar 的主题属性适配器的具体类型实现类 public static class Impl extends ToolbarAttributeAdapter&lt;Toolbar&gt; {} private static final Map&lt;Integer, BaseAttributeSetter&lt;Toolbar&gt;&gt; sSetters = new ArrayMap&lt;&gt;(); static { sSetters.put(R.styleable.Attributes_Layout_tf_titleTextColor, new ColorAttributeSetter&lt;Toolbar&gt;() { @Override public boolean onSetView(Toolbar view, int color) { view.setTitleTextColor(color); return true; } }); sSetters.put(R.styleable.Attributes_Layout_tf_subtitleTextColor, new ColorAttributeSetter&lt;Toolbar&gt;() { @Override public boolean onSetView(Toolbar view, int color) { view.setSubtitleTextColor(color); return true; } }); } @NonNull @Override public Collection&lt;Integer&gt; themeAttributes() { // 继承父类的属性，即将父类属性添加到属性列表中 List&lt;Integer&gt; attrs = new LinkedList&lt;&gt;(super.themeAttributes()); attrs.addAll(sSetters.keySet()); return attrs; } @Override public boolean setView(T view, int themeAttribute, int viewAttribute) { if (super.setView(view, themeAttribute, viewAttribute)) // 如果父类处理了属性，则不再处理 return true; // 采用表驱动方式，取出主题属性对应的设置类，对 View 进行设置 BaseAttributeSetter&lt;Toolbar&gt; viewAttributeSetter = sSetters.get(themeAttribute); if (viewAttributeSetter != null) { viewAttributeSetter.setThemeResources(getThemeResources()); return viewAttributeSetter.setView(view, viewAttribute); } // 没有对应属性则不处理，如果有子类，那么子类会处理 return false; }} View 类型支持情况主题属性的资源类型与对应 View 自身属性（主题属性去除 tf_ 前缀）资源类型保持一致 同时下面支持的 View 继承了父类 View 的所有主题属性，例如 Button 支持 TextView 的所有主题属性 View 类型 支持的主题属性 所有 View tf_background TextViewAppCompatTextViewAppCompatCheckedTextViewEditTextAppCompatEditTextButtonAppCompatButton tf_backgroundTinttf_textColortf_textColorHint ImageViewAppCompatImageViewImageButtonAppCompatImageButton tf_src CardView tf_cardBackgroundColor ToggleButtonAppCompatToggleButtonRadioButtonAppCompatRadioButtonCheckBoxAppCompatCheckBox tf_buttontf_buttonTint SwitchSwitchCompat tf_thumbtf_thumbTint Toolbar tf_titleTextColortf_subtitleTextColor ProgressBar tf_progressTinttf_indeterminateTinttf_progressBackgroundTinttf_indeterminateDrawabletf_progressDrawable SpinnerAppCompatSpinner tf_backgroundTinttf_popupBackground SeekBarAppCompatSeekBar tf_thumbtf_thumbTint ListView tf_divider TabLayout tf_tabSelectedTextColortf_tabTextColortf_tabIndicatorColortf_tabRippleColor FloatingActionButton tf_backgroundTint 架构框架代码采用单向依赖的模式，降低了代码的耦合性，每一个模块都可单独取出使用。 框架图： 实现思路和原理一开始想在一个小应用上实现本地主题切换功能，想要使用最简洁的方法实现，不依赖于第三方主题切换框架，同时需要实时切换，不重启 Activity。 （之前也使用过一个主题框架，但是它要求使用框架自己提供的控件，我觉得侵入性太强，就不想用） 主题切换实现那么首先想到了属性值来可以自动替换为对应主题下的资源的方式，例如有如下属性值： 1&lt;attr name=&quot;appTextColor&quot; format=&quot;color&quot; /&gt; 在每个主题下有一个对应的资源值（资源值也可以为 drawable 或其他资源）： 1234567&lt;style name=&quot;AppTheme.Black&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt; &lt;item name=&quot;appTextColor&quot;&gt;#FFFFFF&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;AppTheme.White&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;appTextColor&quot;&gt;#000000&lt;/item&gt;&lt;/style&gt; 在布局中使用这个属性值： 1234&lt;androidx.appcompat.widget.AppCompatTextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;?attr/appTextColor&quot;/&gt; 那么当应用启动后，如果布局所在 Activity 的主题为 AppTheme.Black，这个 TextView 的文本颜色将为 #FFFFFF，如果主题是 AppTheme.White，那么文本颜色为 #000000。这样的话可以实现换主题的功能了，只需重启 Activity，在 setContentView 调用之前使用 setTheme 改变主题即可。 如果在不重启 Activity 的情况下切换主题，那么需要手动将每个需要切换主题的 View 的颜色或图片资源替换掉。 可以使用如下代码获取主题对应的颜色资源值： 12345678// Example: int color = getColor(R.attr.appTextColor);public int getColor(@AttrRes int attrId) { int color; TypedArray array = getTheme().obtainStyledAttributes(new int[]{attrId}); color = array.getColor(0, 0); array.recycle(); return color;} 然后手动根据属性值找到对应的资源，为每个 View 重新设置样式即可实现实时主题切换。 对于一个 Activity 中 View 数量不多的情况下，手动处理起来还是比较容易的，但是数量较多的话，手动替换难免力不从心。 一开始使用了这种手动替换的方式，由于应用较为简单，所以还能支撑。 实时切换主题的场景还有一点需要说明一下，就是主题实时切换的场景，对于一个应用中的 Activity，并不是所有 Activity 都需要进行实时主题切换的，只有处于活动状态的 Activity 才需要切换。 例如，用户启动了一系列 Activity，目前 Activity 返回栈的状态如下： 1A -&gt; B -&gt; C -&gt; D 如果包含主题设置按钮的 Activity 是 D，那么一旦切换主题，A B C D 四个 Activity 都需要实时切换主题，因为用户切换主题后按返回键需要看到主题切换后的效果； 如果包含主题设置按钮的 Activity 是 B，那么用户在 B 时切换主题，只需要对 A B 实时切换即可，C D 不需要，因为切换主题后，它们需要从 B 重新打开创建，此时主题可在 Activity 的 setContentView 之前被设置，那么 Activity 中的布局使用属性值即可自动显示对应主题下的样式。 综上所述，在实现应用的主题切换功能时，可以尽量把包含设置主题功能的 Activity 置于返回栈靠前的位置，那么需要进行实时切换的 Activity 将减少，当包含设置主题选项的 Activity 为应用的首个 Activity 时，只需要处理一个 Activity 的实时切换就可以了。 回到主题切换方案的问题上，由于后面又开发了一个应用，依然需要切换主题功能，总不能还手动给每个 View 设置主题资源，需要解决这个问题。 确定方案为了实现主题实时切换功能，同时避免手动对每一个 View 进行设置，目前最大的问题就是自动化的问题，也就是实现一行代码切换主题。 首先需要收集信息，对于一个需要切换主题的 Activity，它的布局中的哪些 View 需要重新设置资源，需要设置什么样的资源。然后收集之后，只要在需要切换主题时遍历这些 View，给它们重新设置对应资源即可。 既然需要收集信息，那就需要考虑信息是如何提供的，即 View 如何提供自己需要哪些主题资源？ 通过 View 对象保存，View 的 setTag 方法可以存放自定义对象，用来保存主题资源信息，如果布局中有大量 View 需要切换主题，还需要手动编写好多设置主题资源信息的代码，那和手动替换资源还有什么区别，肯定不行； 那么想到使用自定义 View 属性的方式来实现主题资源的配置，每个 View 在布局中声明自己所需的主题资源即可。 通常在实现自定义 View 时需要提供自定义的属性，例如字体颜色： 1&lt;attr name=&quot;themeTextColor&quot; format=&quot;color&quot;&gt;&lt;/attr&gt; 解析时需要依赖于 View 构造器中的 AttributeSet 对象进行解析： 12345678private static final class MyView extends View { public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView); // 使用 typedArray 解析每个属性值 }} 但是这样的话，没办法解析自定义的主题属性，Android Framework 提供的 View 代码都已经固定了，每个 View 只会解析自己对应的那些属性，自定义的属性根本就不会解析，如果想要解析这些主题属性，只能自定义 View 了，那么需要用到哪种 View（例如 TextView、ImageView），就需要定义一个对应的自定义 View，这不就是那些主题框架的思路吗，提供一堆包含主题切换功能的自定义控件给用户使用。这样不行，侵入性太强，而且灵活性太低，必须与系统控件对应，还是不要采用这种方式实现了。 那么怎么才能在不自定义 View 的前提下解析每个 View 的主题属性，首先看能不能获取每个 View 的 AttributeSet 对象，从外部进行解析，AttributeSet 里面不是包含一个 View 在布局中的所有属性吗，是否能获取到，通过查看 Framework 源码，获知一个 Activity 的布局解析工作由 LayoutInflater 负责，这个 AttributeSet 对象是在解析布局的过程中生成的，生成后在创建每个 View 的过程中传入每个 View 的构造器中，View 也没有保存这个对象，它是无法被获取的，那么该怎么办（其实 AttributeSet 对象保存了也没用，它只能在 View 创建时进行解析，它本身并不包含任何 View 属性，属性信息都是即时解析的）。 既然整个布局是由 LayoutInflater 负责解析，每个 View 的 AttributeSet 对象也由它来负责创建，那么直接自己实现一个 LayoutInflater 不就什么都能拿到了，但是这样风险太大，LayoutInflater 不是那么容易实现的，它需要负责布局中每一个 View 的创建工作，从而构建一个布局的视图树，同时还需要考虑到每个 Android 版本的兼容性，个人来实现和维护是很难的，所以此路不通。 最后想到了一个办法，既然想要拿到一个布局里面所有 View 的属性信息，一个布局就是一个 XML 文件而已，按照传统解析 XML 文件的方式不就能得到每个标签所包含的信息了吗，每一个标签就表示一个布局中 View 对象，想到了那就开始验证可行性。 于是参考 LayoutInflater 的源码对布局文件进行解析，在 Android 中，所有的 XML 文件在编译后都是二进制的 XML 格式，并非文本格式，不过 Android 提供了 XmlResourceParser 这个解析器工具，解析方式和 XmlPullParser 一样，可以很方便的解析 XML 文件，AttributeSet 只是解析器的包装，获取很方便： 1AttributeSet attributeSet = Xml.asAttributeSet(parser); 经过对布局的解析，能够做到可以收集布局中任意 View 的主题属性了。其实在解析过程中还需要处理一些细节问题，例如 include 等特殊标签，不过参考 LayoutInflater 的源码，还是较好解决的。 目前方案验证还未完成，还有一个问题，从布局解析出了主题属性，还需要把每个主题属性和具体的 View 联系起来，要不然信息不足，没法完成切换主题。一个 Activity 中的布局包含大量 View，在经过 LayoutInflater 解析后，会以根 View 开始，构建一颗 View 树，那么只需提供树根，也就是根 View，就能遍历一颗完整的 View 树了，通常情况，XML 布局文件里的 View 标签结构和 View 树是一一对应的，那么可以在解析布局文件中的主题属性时依据标签名字对 View 树中的 View 进行匹配即可。 经过匹配逻辑的验证，确认了方案可行性，那就可基于这个方案开发框架了。 （在 View 树和布局中的主题属性匹配的过程中，其实也不是那么顺利，一开始使用精确匹配。一个标签精确匹配 View 树中的一个 View，然而不行，View 树和布局中的标签不一定是一一对应的，例如 TabLayout 标签内部可以放置 TabItem 然而，View 树构建后，TabItem 并不是 TabLayout 的子 View，真正的子 View 是 TabView，不过这种情况极少，后来改进了匹配算法，进行模糊匹配也可解决 V iew 和主题属性的匹配问题，且可以保证精确性，毕竟布局文件中的标签结构和 LayoutInflater 刚刚构建完成后的 View 树都是静态结构，所以一定能完成匹配） 核心实现在经过方案的可行性验证后，就可以去实现了，框架的核心实现比较简单清晰，很容易看懂。 有些实现细节需要说明一下，对于一个 Activity 来说，它的 View 树的结构可能没有那么理想，并不是一定对应一个布局文件中的结构，因为不仅包含 ListView 和 RecyclerView 这种动态回收 View 的控件，还有 Fragment 和 Dialog 等具有独立布局的 UI 组件，还有用户自行动态添加到布局中的任意 View，这些问题都需要考虑，下面是针对每种情况的处理方式： 对于 ListView 和 RecyclerView，它们都具有 Adpater，Adapter 会提供创建 Item 布局 View 的方法，至于复用工作由控件自己来完成，那么创建的 Item 布局 View 数目是固定的，这些 Item View 会在界面上不断复用展示，那么只需要处理这些固定数目的 Item View 的主题切换即可； 对于 Fragment 和 Dialog 它们具有独立布局，那就单独处理它们的布局，将它们独立布局中的主题属性和它们的根 View 进行匹配收集起来即可； 对于用户自行动态添加到布局中的 View，提供方法，让用户主动通知框架，如果 View 从布局加载，那么从不布局收集主题属性，如果 View 是直接通过代码创建的，提供手动添加主题属性的方法。那么这种情况也能够处理。 处理了所有情况后，才可以说完成了实现。 LICENSE12345678910111213Copyright 2021 l0nemanLicensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.","link":"/2021/01/23/themeframework-%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/"},{"title":"Makefile 指南","text":"前言此文档内容是对于博客 跟我一起写Makefile 的归纳整理。 规范了文档格式，重构为参考手册的形式，不适合作为教程，适合作为参考。 Makefile 介绍编写原则 如果这个工程没有编译过，那么所有的 C 文件都需要编译并链接； 如果这个工程的某几个 C 文件被修改，那么只编译被修改的 C 文件，并连接目标程序； 如果这个工程的头文件被改变了，那么需要编译引用了这几个头文件的 C 文件，并连接目标程序。 Makefile 规则1234target ...: prerequisites ... command ... ... target 一个目标文件（Object File），或一个可执行文件，或一个标签（Label） prerequisites 生成该 target 所依赖的文件以或/和 target command 该 target 要执行的命令 Makefile 示例12345678910111213141516171819202122232425edit: main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.omain.o: main.c defs.h cc -c main.ckbd.o: kdb.c defs.h command.h cc -c command.ccommand.o: commnd.c defs.h command.h cc -c command.cdisplay.o: display.c defs.h buffer.h cc -c dislay.cinsert.o: insert.c defs.h buffer.h cc -c insert.cserch.o: search.c defs.h buffer.h cc -c search.cfiles.o: files.c defs.h buffer.h command.h cc -c files.cutils.o: utils.c defs.h cc -c utils.c clean: rm edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o Make 工作方式输入 make 命令后： Make 会在当前目录下寻找名字叫做“Makefile”或“makefile”的文件； 如果找到，继续找到文件中第一个 target（目标文件）； 如果 target 不存在，或者 target 后面依赖的“.o”文件的修改时间比 target 要新，那么，它会执行后面所定义的命令来生成 target 文件； 如果 target 依赖的“.o”文件也不存在，那么 Make 会在当前文件中寻找目标为“.o”文件的依赖性，如果找到则再根据哪个规则生成“.o”文件； 如果 C 文件和 H 文件存在，则 Make 会根据规则生成“.o”文件，从而生成最终的 target 文件。 Make 会层层递进的寻找依赖关系，直到编译出最终的 target，一旦依赖的文件不存在，那么 Make 就会报错。 clean 命令没有被 target 依赖，那么 Make 不会执行后面定义的命令，除非显式的执行： 1make clean Makefile 中的变量12345678910111213141516171819202122232425objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit: $(objects) cc -o $(objects)main.o: main.c defs.h cc -c main.ckbd.o: kdb.c defs.h command.h cc -c command.ccommand.o: commnd.c defs.h command.h cc -c command.cdisplay.o: display.c defs.h buffer.h cc -c dislay.cinsert.o: insert.c defs.h buffer.h cc -c insert.cserch.o: search.c defs.h buffer.h cc -c search.cfiles.o: files.c defs.h buffer.h command.h cc -c files.cutils.o: utils.c defs.h cc -c utils.cclean: rm edit $(objects) Makefile 自动推导Make 可以自动推导文件以及文件依赖后面的命令. 123456789101112131415161718objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit: $(objects) cc -o edit $(objects)main.o: defs.hkbd.o: defs.h command.hcommand.o: defs.h command.hdisplay.o: defs.h buffer.hinsert.o: defs.h buffer.hsearch.o: defs.h buffer.hfiles.o: defs.h buffer.h command.hutils.o: defs.h.PHONY: cleanclean: rm edit $(objects) .PHONY 表示 clean 是一个伪目标文件。 另类风格的 Makefile12345678910111213objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit: $(objects) cc -o edit $(objects) $(objects): defs.h kbd.o command.o files.o: command.h display.o insert.o seatch.o files.o: buffer.h.PHONY: cleanclean: rm edit $(objects) clean 规则12clean: rm edit $(objects) 123.PHONY: cleanclean: -rm edit $(objects) “-”表示也许某些文件会出现问题，忽略继续做后面的事 Makefile 里有什么？ 显式规则，它说明了如何生成一个或者多个目标文件。这是由 Makefile 的书写者明显指出要生成的文件、文件的依赖文件和生成的命令； 隐晦规则，由于 Make 有自动推导功能，所以隐晦规则支持简写 Makefile； 变量定义，在 Makefile 中我们要定义一些列的变量，一般都是字符串，类似 C 语言中的宏； 文件指示，包括 3 部分：在一个 Makefile 中引用另一个 Makefile，类似 C 语言中的“include”；另一个是根据某些情况指定 Makefile 的有效部分，类似 C 语言中的预编译“#if”；最后就是定义一个多行命令； 注释，Makefile 中只有行注释，使用“#”字符进行注释。 Makefile 中命令必须以 [Tab] 开始。 Makfefile 文件名默认情况下，Make 会在当前目录按顺序寻找名为“GNUmakefile”、“makefile”、“Makefile”的文件。 最好使用“Makefile”，更醒目，通用性更强。 可指定 Makefile 文件名： 12make -f Make.mymake -file Make.abc 引用其他的 Makfile使用 include 关键字包含别的 Makefile，类似 C 语言中的 #include，被包含的文件内容会被扩展到当前包含的位置。 1include &lt;filename&gt; 1include foo.make *.mk $(bar) Make 首先寻找 include 指出其他 Makefile，并将它们的内容扩展到当前位置。 Make 首先在当前目录寻找文件，找不到时，Make 还会在如下目录寻找： 如果 Make 执行时，被指定了 -I 或 --include-dir 参数，那么 Make 就会在此参数指定的目录下寻找； 如果目录 &lt;prefix&gt;/include（一般为 /usr/local/bin 或 /usr/include）存在，Make 也会在里面寻找。 1-include &lt;filename&gt; “-”表示，无论 include 过程中出现什么错误，都不要报错，继续执行。 其他版本中有类似的 sinclude 兼容命令。 环境变量 MAKEFILES如果当前环境中定义了 MAKFEFILES 变量，那么 Make 会把它当作类似 include 的动作。 此变量中的值为其他 Makefile 的定义，使用空格隔开。 Make 工作方式 读入所有 Makefile； 读入被 include 的其他 Makefile； 初始化文件中的变量； 推导隐晦规则，并分析所有规则； 为所有的目标文件创建依赖关系链； 根据依赖关系，决定那些目标要重新生成； 执行生成命令。 书写规则规则包含两部分，一个是依赖关系，一个是生成目标的方法。 12foo.o: foo.c defs.h cc -c -g foo.c 规则语法123targets: prerequisites command ... 123targets: prerequisites; command command ... targets 是文件名，以空格分开，可以使用通配符。 command 是命令行，如果不与前面的内容在一行，那么必须以 [Tab] 键开头，如果在一行，可以以分号作为分隔。 prerequisites 也就是目标所依赖的文件。如果其中的某个文件比目标文件新，那么目标文件被认为是“过时的”，需要被重新生成。 如果命令太长，可以使用 \\ 作为换行符。 一般，Make 会以 UNIX 的标准 Shell，也就是 /bin/sh 来执行。 规则中使用通配符Make 支持 3 个通配符，*、? 和 ~。 ~ 表示当前用户的 $HOME 目录。 1objects: $(wildcard *.o) 文件搜寻VAPTH 可指明 Make 在当前目录找不到的情况下，去指定的目录中去寻找文件，多个路径使用 : 分隔。 1VPATH = src:.../headers 或使用 Make 中的 vpath 关键字。 12345678vpath &lt;pattern&gt; &lt;directories&gt;为符合模式 &lt;pattern&gt; 的文件指定搜索目录 &lt;directories&gt;。vapth &lt;pattern&gt;清除符合模式 &lt;pattern&gt; 文件的搜索目录。vpath清除所有以被设置好了的文件搜索目录。 vpath 中的 &lt;pattern&gt; 需要包含 % 字符，% 的意思是匹配零或若干字符。 12vpath %.h ../headers# 表示在 ../headers 目录下搜索所有以 .h 结尾的文件 多行 vpath 关键字，Make 将会按顺序执行搜索。 123vpath %.c foo:barvpath % blish# 表示先在 foo 目录，然后 bar 目录，最后是 blish 目录搜寻 .c 的结尾文件 伪目标伪目标并不是一个文件，只是一个标签。 避免和文件重名，使用 .PHONY 标记显式指定一个“伪目标”。 当伪目标放在第一行时，可作为“默认目标”，利用它实现同时编译出多个可执行文件。 1234567891011all: prog1 prog2 prog3.PHONY: allprog1: prog1.o utils.o cc -o prog1 prog1.o utils.oprog2: prog2.o cc -o prog2 prog2.oprog3: prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o 伪目标也可以成为依赖： 12345678910.PHONY: cleanall cleanobj cleandiffcleanall: cleanobj cleandiff rm programcleanobj: rm *.ocleandiff: rm *.diff 多目标Makefile 支持多个目标，有时多个目标会依赖于同一个文件，并且生成命令类似，可以将其合并起来。 自动化变量 $@ 表示目前规则中所有目标的集合。 12bigoutput littleoutput: text.g generate text.g -$(subst output,,$@) &gt; $@ 等价于 1234bigoutout: text.g gererate text.g -big &gt; bigoutputlittleoutput: text.g generate text.g -little &gt; littleoutput 静态模式静态模式可以更容易的定义多目标的规则，使得规则更加灵活。 123&lt;target ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt; &lt;commands&gt; ... targets 定义了一系列的目标文件，可以有通配符，是目标的集合。 target-pattern 指明了 targets 的模式，也就是目标集模式。 prereq-patterns 是目标的依赖模式，对 target-pattern 再进行一次依赖目标的定义。 123456objects = foo.o bar.oall: $(objects)$(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 上面指明了目标从 $object 中获取，%.o 表明所有以 .o 结尾的目标，后面的 %.c 取模式 %.o 的 % 部分，也就是 foo bar，并添加上 .c 的后缀，表示依赖的目标是 foo.c bar.c。 展开上述规则： 1234foo.o: foo.c $(CC) -c $(CFLAGS) foo.c -o foo.obar.o: bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o 自动生成依赖性使用编译器命令自动生成依赖关系： 1cc -M main.c 会生成： 1main.o: main.c defs.h GNU 建议把每一个源文件的依赖关系保存到一个对应的 .d 文件中。 可以让 Make 自动生成 .d 文件，并包含在 Makefile 中。 12345%.d: %.c @set -e; rm -f $@; \\ $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \\ sed 's,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \\ rm -f $@.$$$$ 意思是，所有的 .d 文件依赖于 .c 文件， rm -f $@ 意思是删除所有的目标，也就是 .d 文件，第二行意思是，为每个依赖文件 $&lt; ，也就是 .c 文件生成依赖文件， $@ 表示模式 %.d 文件，如果有一个 C 文件是 a.c，那么 % 就是 a ， $$$$ 表示一个随机编号，第二行生成的文件可能是“name.d.12345”，第三行使用 sed 命令做了替换。 从而在编译器生成的依赖关系中加入了 .d 文件依赖。即： 1main.o: main.c defs.h 变成了 1main.o main.d: main.c defs.h 书写命令显示命令通常 Make 会把执行的命令在命令执行前打印出来，使用 @ 字符可以不让 Make 显示命令。 1@echo 正在编译 xxx 模块…… Make 执行时，只会显示出 正在编译 xxx 模块……，如果没有 @，那么显示： 12@echo 正在编译 xxx 模块……正在编译 xxx 模块…… 使用 Make 带上 -n 或 --just-print 参数，那么只显示命令，不执行命令。 -s 和 --silent 或 --quiet 是全面禁止命令的显式。 命令执行如果需要在前一个命令执行的基础上执行下一个命令，需要放在一行，以 ; 隔开： 不能分两行执行。 12exec: cd /home/l0neman/; pwd 嵌套执行 Make大工程中，可能会把不同模块或者不同功能的源文件放在不同目录中，每一个目录中可以写一个 Makefile，有利于让 Makefile 变得更简洁，而不是全部都写在一个 Makefile 中。 12subsystem: cd subdir &amp;&amp; $(MAKE) 等价于： 12subsystem: $(MAKE) -C subdir $(MAKE) 是默认变量表示 Make 本身，使我们可以使用 Make 携带参数，上面两个 Makefile 都表示进入 subdir，然后执行 make 命令。 此 Makefile 被称为总控 Makefile，它可以将一些参数带入下一级 Makefile。 如果要传递变量到下一级，使用 export，如果不想，那么使用 unexport。 1export &lt;varible ...&gt;; 1unexport &lt;varible ...&gt;; 如： 12345678export variable = value# 或variable = valueexport variable# 或export variable := value# 或export variable += value 当单独使用 export 占一行时，那么表示传递所有变量。 两个特殊变量一定会传递，SHELL 和 MAKEFLAGS。 -w 或是 --print-directory 会在 Make 的过程中输出目前的工作目录信息： 12make: Entering directory `/home/l0neman/hello'.make: Leaving directory `/home/l0neman/hello' 定义命令包使用 define 开始，endef 结束，可以将一组命令定义为一个变量，成为命令包。 1234define run-yaccyacc $(firstword $^)mv y.tab.c $@endef 123foo.c: foo.y $(run-yacc) 使用变量变量基础使用变量，需要在变量名前加上 $ 符号，最好使用 () 和 {} 被变量括起来，使用真实 $ 变量，需要用 $$ 表示。 12345objects = program.o foo.o utils.oprogram : $(objects) cc -o program $(objects)$(objects) : defs.h 变量和 C 语言的宏一样，会在使用它的位置展开。 123foo = cprog.o: prog.$(foo) $(foo)$(foo) -$(foo) prog.$(foo) 得到： 12prog.o: prog.c cc -c prog.c 变量的变量使用 = 来将变量值赋值给另一个变量 123456foo = $(bar)bar = $(ugh)ugh = Huh?all: echo $(foo) 好处是可以把变量移动到后面定义： 12CFLAGS = $(include_dirs) -Oinclude_dirs = -Ifoo -Ibar 但可能会出现递归定义，Make 会检测到这种定义，从而报错。 1234CFLAGS = $(CFLAGS) -oA = $(B)B = $(A) 可以使用 := 来避免这种情况，:= 不允许使用后面定义的变量。 123x := fooy := $(x) barx := later 一个复杂的变量例子： 123456ifeq (0,${MAKELEVEL})cur-dir := $(shell pwd)whoami := $(shell whoami)host-type := $(shell arch)MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}endif 定义一个空格变量： 12nullstring :=space := $(nullstring) # end of the line nullstring 为一个 Empty 变量，表示什么都没有，那么 space 表示一个空格（在 # 号前面）。 注意，# 号符号前面的空格将会包含在变量中： 12dir := /foo/bar # directory to put the frobs in# 上面路径后面还包含了 4 个空格。 使用 ?=，表示如果变量没有被定义过，那么变量的值就是右边的，否则什么也不做。 1FOO ?= bar 等价于： 123ifeq ($(origin FOO), undefined) FOO = barendif 变量高级用法可以替换变量中共有的部分，格式是 $(var:a=b 或 $(var:a=b)，表示把变量 foo 中所有以 a 字符串结尾的 a 部分替换成 b。 12foo := a.o b.o c.obar := $(foo:.o=.c) 或“静态模式” 12foo := a.o b.o c.obar := $(foo:%.o=%.c) 变量再次当作变量 1234x = yy = za := $($(x))# 那么 a = z 12345x = $(y)y = zz = Helloa := $($(x))# 那么 a = Hello 12345first_second = Helloa = firstb = secondall = $($a_$b)# 那么 all = $(first_second) = Hello 1234a_objects := a.o b.o c.o1_objects := 1.o 2.o 3.osources := $($(a1)_objects:.o=.c) 123456789ifdef do_sort func := sortelse func := stripendifbar := a d b g q cfoo := $($(func) $(bar)) 12345dir = foo$(dir)_sources := $(wildcard $(dir)/*.c)define $(dir)_printlpr $($(dir)_sources)endef 追加变量值使用 += 给变量追加值。 12objects = main.o foo.o bar.o utils.oobjects += another.o 可以解释为： 12objects = main.o foo.o bar.o utils.oobjects := $(objects) another.o 如果变量之前没有定义过，那么 += 会自动变成 =。+= 会继承上次操作的赋值符。如果前一次的是 := ，那么 += 会以 := 作为其赋值符，那么 += 会以 := 作为其赋值符。 override 指示符如果有变量是通过 Make 的命令行设置的，那么 Makefile 对这个变量的赋值将会被忽略。 如果想要设置这类参数，可使用 override 指示符。 123override &lt;variable&gt;; = &lt;value&gt;;override &lt;variable&gt;; := &lt;value&gt;; 在 define 前使用 override 进行多行形式的变量定义： 123override define foobarendef 多行变量使用 define 关键字可以设置带有换行的变量值。 define 指示符后面跟的变量的名字，而重起一行定义变量的值，定义是以 endef 关键字结束。 1234define two-linesecho fooech $(bar)endef 环境变量Make 运行时的系统环境变量在 Make 开始执行时被载入到 Makefile 文件中，如果 Makefile 中已经定义了这个变量，或者变量由 make 命令带入，那么系统的环境变量的值将被覆盖。 如果系统中定义了 CFLAGS 环境变量，那么就可以在所有的 Makefile 中使用这个变量了。 目标变量可以为某个目标设置局部变量，被称为 Target-specific Variable，它可以和全局变量同名，由于它的作用域值在这条规则以及连带规则中，所以其值只在作用范围内有效，不会影响规则链以外的全局变量的值。 123&lt;target ...&gt;: &lt;variable-assignment&gt;&lt;target ...&gt;: overide &lt;variable-asignment&gt; 指的是各类赋值表达式，如 =、:=、+= 或 ?=。 第二行针对 make 命令带入的变量，或是系统环境变量。 123456789101112prog : CFLAGS = -gprog : prog.o foo.o bar.o $(CC) $(CFLAGS) prog.o foo.o bar.oprog.o : prog.c $(CC) $(CFLAGS) prog.cfoo.o : foo.c $(CC) $(CFLAGS) foo.cbar.o : bar.c $(CC) $(CFLAGS) bar.c 上面的示例，不管全局的 $(CFLAGS) 的值是什么，在目标 prog 中，以及其所引发的所有规则中（prog.o foo.o bar.o 的规则）， $(CFLAGS) 的值都是 -g。 模式变量GNU 的 Make 还支持模式变量（Pattern-specific Variable），可以给定一种模式，把变量定义在符合这种模式的所有目标上。 模式（pattern）至少含有一个 %，定义如下，给所有以 .o 结尾的目标定义目标变量。 1%.o: FLAGS = -o 模式变量的语法和目标变量一样： 123&lt;pattern ...&gt;; : &lt;variable-assignment&gt;&lt;pattern ...&gt;; : override &lt;variable-assignment&gt; 使用条件判断示例条件判断，可以让 Make 根据运行时的不同情况选择不同分支。 123456789libs_for_gcc = -lgnunormal_libs =foo: $(objects)ifeq ($(CC),gcc) $(CC) -o foo $(objects) $(libs_for_gcc)else $(CC) -o foo $(objects) $(normal_libs)endif 上面的示例，目标 foo 根据变量 $(CC) 的值来选取不同的函数库编译程序。 上面也可写成如下： 1234567891011libs_for_gcc = -lgnunormal_libs =ifeq ($(CC),gcc) libs=$(libs_for_gcc)else libs=$(normal_libs)endiffoo: $(objects) $(CC) -o foo $(objects) $(libs) 语法123&lt;conditional-directive&gt;&lt;text-if-true&gt;endif 12345&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif 表示条件关键字。 ifeq 比较两个参数的值是否相同，参数中还可以使用 Make 支持的函数。 12345ifeq (&lt;arg1&gt;, &lt;arg2&gt;)ifeq '&lt;arg1&gt;' '&lt;arg2&gt;'ifeq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;ifeq &quot;&lt;arg1&gt;&quot; '&lt;arg2&gt;'ifeq '&lt;arg1&gt;' &quot;&lt;arg2&gt;&quot; 包含函数： 123ifeq ($(strip $(foo)),)&lt;text-if-empty&gt;endif 上面表示如果函数的返回值是空（Empty），那么 生效。 ifneq 比较两个参数是否不相同。 12345ifneq (&lt;arg1&gt;, &lt;arg2&gt;)ifneq '&lt;arg1&gt;' '&lt;arg2&gt;'ifneq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;ifneq &quot;&lt;arg1&gt;&quot; '&lt;arg2&gt;'ifneq '&lt;arg1&gt;' &quot;&lt;arg2&gt;&quot; ifdef 判断变量的值不为空，则通过。 1ifdef &lt;vaiable-name&gt; 它不会扩展变量值到当前位置，只会判断是否有值。 ifndef 与 ifdef 相反。 1ifndef &lt;variable-name&gt; 在 这行，允许后面存在多余的空格，但是不能以 [Tab] 键作为开始。那么注释符 # 是安全的。 Make 在读取 Makefile 时就计算条件表达式的值，所以避免将自动化变量如 $@ 放入条件表达式，因为它们是运行时才有的。 Make 不允许把整个条件语句分成两部分放在不同的文件中。 使用函数Makefile 中可以使用函数来处理变量。 函数的调用语法1$(&lt;function&gt; &lt;arguments&gt;) 或： 1${&lt;function&gt; &lt;arguments&gt;} 是函数名， 为函数参数，多个参数使用 , 分隔。 12345comma:= ,empty:=space:= $(empty) $(empty)foo:= a b cbar:= $(subst $(space),$(comma),$(foo)) 上面使用了字符串替换函数 subst，将 $(foo) 中的空格替换成了 , 结果是 $(bar)=a,b,c 字符串处理函数 subst 123456$(subst, &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)# 名称：字符串替换函数# 功能：把字符串 &lt;text&gt; 中的 &lt;from&gt; 字符串替换成 &lt;to&gt;# 结果：返回被替换过后的字符串# 示例：fEEt on the strEEt = $(subst ee,EE,feet on the street) patsubst 1234567$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)# 名称：模式字符串替换函数# 功能：查找 &lt;text&gt; 中的单词（单词以“空格”、“Tab”或“回车”、“换行”分隔）是否符合模式 &lt;pattern&gt; ，如果匹配的话，则以 &lt;replacement&gt; 替换。这里， &lt;pattern&gt; 可以包括通配符 % ，表示任意长度的字串。如果 &lt;replacement&gt; 中也包含 % ，那么， &lt;replacement&gt; 中的这个 % 将是 &lt;pattern&gt; 中的那个 % 所代表的字串。（可以用 \\ 来转义，以 \\% 来表示真实含义的 % 字符）# 结果：返回被替换过后的字符串# 示例：x.c.o bar.o = $(patsubst %.c,%.o,x.c.c bar.c)# 备注：$(var:&lt;pattern&gt;=&lt;replacement&gt;;) 相当于 $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))，而 $(var: &lt;suffix&gt;=&lt;replacement&gt;) 则相当于 $(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var)) strip 123456$(strip &lt;string&gt;)# 名称：去除空格函数# 功能：去除 &lt;string&gt; 字符串中开头和结尾的空字符# 结果：返回被去掉空格的字符串# 示例：a b c = $(strip a b c ) findstring 12345678$(findstring &lt;find&gt;,&lt;in&gt;)# 名称：查找字符串函数# 功能：在字串 &lt;in&gt; 中查找 &lt;find&gt; 字串# 结果：如果找到，那么返回 &lt;find&gt; ，否则返回空字符串# 示例： a = $(findstring a,a b c) = $(findstring a,b c) filter 12345678910$(filter &lt;pattern...&gt;,&lt;text&gt;)# 名称：过滤函数# 功能：以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，保留符合模式 &lt;pattern&gt; 的单词，可以有多个模式# 结果：返回符合模式 &lt;pattern&gt; 的字串# 示例： sources := foo.c bar.c baz.s ugh.h foo: $(sources) cc $(filter %.c %.s,$(sources)) -o foo # 返回值：foo.c bar.c baz.s filter-out 123456789$(filter-out &lt;pattern...&gt;,&lt;text&gt;)# 名称：反过滤函数# 功能：以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，去除符合模式 &lt;pattern&gt; 的单词，可以有多个模式# 结果：返回不符合模式 &lt;pattern&gt; 的字串# 示例： objects = main1.o foo.o main2.o bar.o mains = main1.o main2.o # 返回值：foo.o bar.o sort 1234567$(sort &lt;list&gt;)# 名称：排序函数# 功能：给字符串 &lt;list&gt; 中的单词排序（升序）# 结果：返回排序后的字符串# 示例：bar foo lose = $(sort foo bar lose)# 备注：sort 函数会去掉 &lt;list&gt; 中相同的单词 word 123456$(word &lt;n&gt;,&lt;text&gt;)# 名称：取单词函数# 功能：取字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。（从一开始）# 结果：返回字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。如果 &lt;n&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串# 示例：bar = $(word 2, foo bar baz) wordlist 123456$(wordlist &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)# 名称：取单词串函数# 功能：从字符串 &lt;text&gt; 中取从 &lt;ss&gt; 开始到 &lt;e&gt; 的单词串。 &lt;ss&gt; 和 &lt;e&gt; 是一个数字# 结果：返回字符串 &lt;text&gt; 中从 &lt;ss&gt; 到 &lt;e&gt; 的单词字串。如果 &lt;ss&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串。如果 &lt;e&gt; 大于 &lt;text&gt; 的单词数，那么返回从 &lt;ss&gt; 开始，到 &lt;text&gt; 结束的单词串# 示例：bar baz = $(wordlist 2, 3, foo bar baz) words 1234567$(words &lt;text&gt;)# 名称：单词个数统计函数# 功能：统计 &lt;text&gt; 中字符串中的单词个数# 结果：返回 &lt;text&gt; 中的单词数# 示例：3 = $(words, foo bar baz)# 备注：如果要取 &lt;text&gt; 中最后的一个单词，可以这样：$(word $(words &lt;text&gt;),&lt;text&gt;) firstword 1234567$(firstword &lt;text&gt;)# 名称：首单词函数# 功能：取字符串 &lt;text&gt; 中的第一个单词# 结果：返回字符串 &lt;text&gt; 的第一个单词# 示例：foo = $(firstword foo bar)# 备注：可以用 word 函数来实现：$(word 1,&lt;text&gt;) 字符串函数实例： 利用搜索路径 VPATH 来指定编译器对头文件的搜索路径参数 CFLAGS 12override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))# $(VPATH) 值是 src:../headers ，那么 $(patsubst %,-I%,$(subst :, ,$(VPATH))) 将返回 -Isrc -I../headers 文件名操作函数每个函数的参数字符串都会被当做一个或是一系列的文件名来对待 dir 123456$(dir &lt;names...&gt;)# 名称：取目录函数# 功能：文件名序列 &lt;names&gt; 中取出目录部分。目录部分是指最后一个反斜杠（ / ）之前的部分。如果没有反斜杠，那么返回 ./# 结果：返回文件名序列 &lt;names&gt; 的目录部分# 示例：src/ ./ = $(dir src/foo.c hacks) notdir 123456$(notdir &lt;names...&gt;)# 名称：取文件函数# 功能：从文件名序列 &lt;names&gt; 中取出非目录部分。非目录部分是指最後一个反斜杠（ / ）之后的部分# 结果：返回文件名序列 &lt;names&gt; 的非目录部分# 示例：foo.c hacks = $(notdir src/foo.c hacks) suffix 123456$(suffix &lt;names...&gt;)# 名称：取后缀函数# 功能：从文件名序列 &lt;names&gt; 中取出各个文件名的后缀# 结果：返回文件名序列 &lt;names&gt; 的后缀序列，如果文件没有后缀，则返回空字串# 示例：.c .c = $(suffix src/foo.c src-1.0/bar.c hacks) basename 123456$(basename &lt;names...&gt;)# 名称：取前缀函数# 功能：从文件名序列 &lt;names&gt; 中取出各个文件名的前缀部分# 结果：返回文件名序列 &lt;names&gt; 的前缀序列，如果文件没有前缀，则返回空字串# 示例：src/foo src-1.0/bar hacks = $(basename src/foo.c src-1.0/bar.c hacks) addsuffix 123456$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)# 名称：加后缀函数# 功能：把后缀 &lt;suffix&gt; 加到 &lt;names&gt; 中的每个单词后面# 结果：返回加过后缀的文件名序列# 示例：foo.c bar.c = $(addsuffix .c,foo bar) addprefix 123456$(addprefix &lt;prefix&gt;,&lt;names...&gt;)# 名称：加前缀函数# 功能：把前缀 &lt;prefix&gt; 加到 &lt;names&gt; 中的每个单词后面# 结果：返回加过前缀的文件名序列# 示例：src/foo src/bar = $(addprefix src/,foo bar) join 123456$(join &lt;list1&gt;,&lt;list2&gt;)# 名称：连接函数# 功能：把 &lt;list2&gt; 中的单词对应地加到 &lt;list1&gt; 的单词后面。如果 &lt;list1&gt; 的单词个数要比 &lt;list2&gt; 的多，那么， &lt;list1&gt; 中的多出来的单词将保持原样。如果 &lt;list2&gt; 的单词个数要比 &lt;list1&gt; 多，那么， &lt;list2&gt; 多出来的单词将被复制到 &lt;list1&gt; 中# 结果：返回连接过后的字符串# 示例：aaa111 bbb222 333 = $(join aaa bbb , 111 222 333) foreach 函数1$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;) ，把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中，然后再执行 &lt;text&gt; 所包含的表达式。每一次 &lt;text&gt; 会返回一个字符串，循环过程中， &lt;text&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， &lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值 实例： 12names := a b c dfiles := $(foreach n,$(names),$(n).o) $(name) 中的单词会被挨个取出，并存到变量 n 中，$(n).o 每次根据 $(n) 计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，那么，$(files) 的值是 a.o b.o c.o d.o if 函数123$(if &lt;condition&gt;,&lt;then-part&gt;)# 或$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;) if 函数可以包含“else”部分，或是不含。即 if 函数的参数可以是两个，也可以是三个。 &lt;condition&gt; 参数是 if 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，&lt;then-part&gt; 会被计算，否则 &lt;else-part&gt; 会被计算。 if 函数的返回值：如果 &lt;condition&gt; 为真（非空字符串），那个 &lt;then-part&gt; 会是整个函数的返回值，如果 &lt;condition&gt; 为假（空字符串），那么 &lt;else-part&gt; 会是整个函数的返回值，此时如果 &lt;else-part&gt; 没有被定义，那么，整个函数返回空字串。 所以，&lt;then-part&gt; 和 &lt;else-part&gt; 只会有一个被计算 call 函数唯一一个可以用来创建新的参数化的函数，可以写一个非常复杂的表达式，这个表达式中，可以定义许多参数，然后可以用 call 函数来向这个表达式传递参数。 1$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;) 当 Make 执行这个函数时，&lt;expression&gt; 参数中的变量，如 $(1) 、$(2) 等，会被参数 &lt;parm1&gt; 、&lt;parm2&gt; 、&lt;parm3&gt; 依次取代。而 &lt;expression&gt; 的返回值就是 call 函数的返回值。 示例： 12reverse = $(1) $(2)foo = $(call reverse,a,b) foo 的值就是 a b ，参数的次序可以是自定义的，不一定是顺序的。 12reverse = $(2) $(1)foo = $(call reverse,a,b) 此时的 foo 的值就是 b a 备注：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第 2 个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向 call 函数提供参数时，最安全的做法是去除所有多余的空格。 origin 函数它并不操作变量的值，它告诉你这个变量的来源。 1$(origin &lt;variable&gt;) 是变量的名字，不应该是引用（使用 $ 符号） 返回值： 1234567undefined -&gt; 如果 &lt;variable&gt; 从来没有定义过default -&gt; 如果 &lt;variable&gt; 是一个默认的定义，比如“CC”这个变量environment -&gt; 如果 &lt;variable&gt; 是一个环境变量，并且当 Makefile 被执行时，-e 参数没有被打开file -&gt; 如果 &lt;variable&gt; 这个变量被定义在 Makefile 中command line -&gt; 如果 &lt;variable&gt; 这个变量是被命令行定义的override -&gt; 如果 &lt;variable&gt; 是被 override 指示符重新定义的automatic -&gt; 如果 &lt;variable&gt; 是一个命令运行中的自动化变量 用法实例： 有一个 Makefile 包含了一个定义文件 Make.def，在 Make.def 中定义了一个变量“bletch”，而此时环境中也有一个环境变量“bletch”，此时，判断如果变量来源于环境，那么就把之重定义，如果来源于 Make.def 或是命令行等非环境的，那么就不重新定义它。 12345ifdef bletch ifeq &quot;$(origin bletch)&quot; &quot;environment&quot; bletch = barf, gag, etc. endifendif shell 函数它的参数就是操作系统 Shell 的命令，shell 函数把执行操作系统命令后的输出作为函数返回。 示例： 12contents := $(shell cat foo)files := $(shell echo *.c) 备注：这个函数会新生成一个 Shell 程序来执行命令，所以你要注意其运行性能。 控制 Make 的函数12345$(error &lt;text ...&gt;)# 产生一个致命的错误，&lt;text ...&gt; 是错误信息$(warning &lt;text ...&gt;)# 输出一段警告信息 可以将函数提前保存到变量，在合适的时候使用： 123ifdef ERROR_001 $(error error is $(ERROR_001))endif Make 的运行Make 的退出码make 命令执行后有三个退出码： 0 表示成功执行 1 Make 运行时出现任何错误 2 如果使用了 Make 的 -q 选项，并且 Make 使得一些目标不需要更新 指定 Makefile可以使用 -f 或 -makefile 给 Make 指定特殊名字的 Makefile 文件。 1make -f hello.mk 指定目标在 make 命令后面跟目标名字即可指定目标。 1make clean make 的环境变量 MAKECMDGOALS 会存放命令指定的目标的列表，如果命令行没有指定，则是空值。 可以将它用于特殊情况： 1234sources = foo.c bar.cifneq ( $(MAKECMDGOALS),clean) include $(sources:.c=.d)endif 如果没有执行 make clean，那么会包含 foo.d 和 bar.d 这两个 Makefile 12.PHONY: allall: prog1 prog2 prog3 prog4 可 make all 编译所有目标，也可以 make prog1 单独编译目标。 GNU Makefile 目标编写规范： 伪目标 含义 all 编译所有的文件 clean 删除所有被 make 创建的文件 install 安装已编译好的程序，就是把目标文件复制到指定的目标 print 列出改变过的源文件 tar 把源程序打包备份成一个 tar 文件 dist 创建一个压缩文件，一般先把 tar 文件压缩成 Z 文件，或者 gz 文件 TAGS 更新所有的目标，以准备完整地编译使用 check/test 一般用来测试 Makefile 的流程 检查规则检查命令，或执行序列，不执行 Makefile 中的规则，指定使用如下参数： 1-n, --just-print, --dry-run, --recon 不执行，只打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，这些参数对于调试 Makefile 很有用处。 1-t, --touch 把目标文件的时间更新，但不更改目标文件。就是说，Make 假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。 1-q, --question 寻找目标的意思，如果目标存在，那么什么也不输出，也不会执行编译，如果目标不存在，打印出一条出错信息。 1-W &lt;file&gt;, --what-if=&lt;file&gt;, --assume-new=&lt;file&gt;, --new-file=&lt;file&gt; 指定一个文件。一般是是源文件（或依赖文件），Make 会根据规则推导来运行依赖于这个文件的命令，一般可以和“-n”参数同时使用，用来查看这个依赖文件发生的规则命令。 结合 -p 和 -v 来输出 Makefile 被执行时的信息。 Make 参数GNU Make 3.80 的所有参数。 参数 含义 -b, -m 作用是忽略和其它版本 Make 的兼容性 -B, –always-make 认为所有的目标都需要更新（重编译） -C , –directory= 指定读取 Makefile 的目录。如果有多个 -C 参数，Make 的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：make -C ~hchen/test -C prog 等价于 make -C ~hchen/test/prog -debug[=] 输出 Make 的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是的取值：1. a：all，输出所有的调试信息；2. b：basic，只输出简单的调试信息。即输出不需要重编译的目标；3. v：verbose，在 b 选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等；4. i：implicit，输出所以的隐含规则；5. j：jobs，输出执行规则中命令的详细信息，如命令的 PID、返回码等；6. m：Makefile，输出 Make 读取 Makefile，更新 Makefile，执行 Makefile 的信息。 -d 相当于 –debug=a -e, –environment-overrides 指明环境变量的值覆盖 Makefile 中定义的变量的值 -f=, –file=, –makefile= 指定需要执行的 Makefile -h, –help 显示帮助信息 -i , –ignore-errors 执行时忽略所有的错误 -I , –include-dir= 定一个被包含 Makefile 的搜索目标。可以使用多个 -I 参数来指定多个目录 -j [], –jobs[=] 指同时运行命令的个数。如果不指定此参数，Make 运行命令时能运行多少就运行多少。如果有一个以上的 -j 参数，那么仅最后一个 -j 才是有效的。（这个参数在 MS-DOS 中是无用的） -k, –keep-going 出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行 -l , –load-average[=], -max-load[=] 指定 Make 运行命令的负载 -n, –just-print, –dry-run, –recon 仅输出执行过程中的命令序列，但并不执行 -o , –old-file=, –assume-old= 不重新生成的指定的 &lt;file&gt;，即使这个目标的依赖文件新于它 -p, –print-data-base 输出 Makefile 中的所有数据，包括所有的规则和变量。这会让一个简单的 Makefile 都输出一堆信息。如果只是想输出信息而不想执行 Makefile，可以使用 make -qp 命令。如果想查看执行 Makefile 前的预设变量和规则，你可以使用 make –p –f /dev/null。这个参数输出的信息会包含着你的 Makefile 文件的文件名和行号，所以，用来调试 Makefile 会很有用，特别是当环境变量很复杂时 -q, –question 不运行命令，也不输出。仅检查所指定的目标是否需要更新。如果是 0 说明要更新，如果是 2 说明有错误发生 -r, –no-builtin-rules 禁止 Make 使用任何隐含规则 -R, –no-builtin-variabes 禁止 Make 使用任何作用于变量上的隐含规则 -s, –silent, –quiet 在命令运行时不输出命令的输出 -S, –no-keep-going, –stop 取消 -k 选项的作用。因为有些时候，Make 的选项是从环境变量 MAKEFLAGS 中继承下来的。所以可以在命令行中使用这个参数让环境变量中的 -k 选项失效 -t, –touch 相当于 UNIX 的 touch 命令，只是把目标的修改日期变成最新的，就是阻止生成目标的命令运行 -v, –version 输出 Make 程序的版本、版权等关于 Make 的信息 -w, –print-directory 输出运行 Makefile 之前和之后的信息。这对于跟踪嵌套式调用 Make 时很有用 –no-print-directory 禁止 -w 选项 -W , –what-if=, –new-file=, –assume-file= 假定目标 &lt;file&gt; 需要更新，如果和 -n 选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有 -n 那么就像运行 UNIX 的 touch 命令一样，使 &lt;file&gt; 的修改时间为当前时间 –warn-undefined-variables 只要 Make 发现有未定义的变量，那么输出警告信息 隐含规则Makefile 中包含了一些隐含规则，是一种默认约定，例如将 .c 文件自动编译为 .o 文件。 12foo : foo.o bar.o cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS) 可以省略如下使用 cc 编译器生成 .o 的规则。 1234foo.o : foo.c cc –c foo.c $(CFLAGS)bar.o : bar.c cc –c bar.c $(CFLAGS) 隐含规则列表make 命令的参数 -r 或 --no-builtin-rules 选项可取消所有的预置的隐含规则。 一个特殊的隐含规则，不能通过 -r 选项关闭。就是后缀规则，文件名中包含如下后缀，那么隐含规则生效。 1.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el 编译C程序的隐含规则 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.c，并且其生成命令是 $(CC) –c $(CPPFLAGS) $(CFLAGS)。 编译 C++ 程序的隐含规则 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.cc 或是 &lt;n&gt;.C，并且其生成命令是 $(CXX) –c $(CPPFLAGS) $(CFLAGS)（建议使用 .cc 作为 C++ 源文件的后缀，而不是 .C）。 编译 Pascal 程序的隐含规则 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.p，并且其生成命令是 $(PC) –c $(PFLAGS) 。 编译 Fortran/Ratfor 程序的隐含规则 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.r 或 &lt;n&gt;.F 或 &lt;n&gt;.f，并且其生成命令是: 123.f $(FC) –c $(FFLAGS).F $(FC) –c $(FFLAGS) $(CPPFLAGS).f $(FC) –c $(FFLAGS) $(RFLAGS) 预处理 Fortran/Ratfor 程序的隐含规则 &lt;n&gt;.f 的目标的依赖目标会自动推导为 &lt;n&gt;.r 或 &lt;n&gt;.F。这个规则只是转换 Ratfor 或有预处理的 Fortran 程序到一个标准的 Fortran 程序。其使用的命令是： 12.F $(FC) –F $(CPPFLAGS) $(FFLAGS).r $(FC) –F $(FFLAGS) $(RFLAGS) 编译 Modula-2 程序的隐含规则 &lt;n&gt;.sym 的目标的依赖目标会自动推导为 &lt;n&gt;.def，并且其生成命令是：$(M2C) $(M2FLAGS) $(DEFFLAGS)；&lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.mod，并且其生成命令是：$(M2C) $(M2FLAGS) $(MODFLAGS)。 汇编和汇编预处理的隐含规则 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.s，默认使用编译器 as，并且其生成命令是：$ (AS) $(ASFLAGS)；&lt;n&gt;.s 的目标的依赖目标会自动推导为 &lt;n&gt;.S，默认使用 C 预编译器 cpp，并且其生成命令是：$(AS) $(ASFLAGS)。 链接 Object 文件的隐含规则 &lt;n&gt; 目标依赖于 &lt;n&gt;.o，通过运行 C 的编译器来运行链接程序生成（一般是 ld），其生成命令是：$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)。这个规则对于只有一个源文件的工程有效，同时也对多个 Object 文件（由不同的源文件生成）的也有效。 Yacc C 程序时的隐含规则 &lt;n&gt;.c 的依赖文件被自动推导为 n.y（Yacc 生成的文件），其生成命令是：$(YACC) $(YFALGS)。 Lex C 程序时的隐含规则 &lt;n&gt;.c 的依赖文件被自动推导为 n.l（Lex 生成的文件），其生成命令是：$(LEX) $(LFALGS)。 Lex Ratfor 程序时的隐含规则 &lt;n&gt;.r 的依赖文件被自动推导为 n.l（Lex 生成的文件），其生成命令是：$(LEX) $(LFALGS)。 从 C 程序、Yacc 文件或 Lex 文件创建 Lint 库的隐含规则 &lt;n&gt;.ln（lint 生成的文件）的依赖文件被自动推导为 n.c，其生成命令是：$(LINT) $(LINTFALGS) $(CPPFLAGS) -i。对于 &lt;n&gt;.y 和 &lt;n&gt;.l 也是同样的规则。 隐含规则使用的变量隐含规则的命令使用了一些预置的变量。 make 命令的 -R 或 --no–builtin-variables 参数可以取消自定义的变量对隐含规则的作用。 隐含规则会使用两类变量，命令类型和命令参数类型。 关于命令的变量 变量 含义 AR 函数库打包程序，默认命令是 ar AS 汇编语言编译程序。默认命令是 as CC C语言编译程序。默认命令是 cc CXX C++语言编译程序。默认命令是 g++ CO 从 RCS文件中扩展文件程序。默认命令是 co CPP C程序的预处理器（输出是标准输出设备）。默认命令是 $(CC) –E FC Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 f77 GET 从SCCS文件中扩展文件的程序。默认命令是 get LEX Lex方法分析器程序（针对于C或Ratfor）。默认命令是 lex PC Pascal语言编译程序。默认命令是 pc YACC Yacc文法分析器（针对于C程序）。默认命令是 yacc YACCR Yacc文法分析器（针对于Ratfor程序）。默认命令是 yacc –r MAKEINFO 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 makeinfo TEX 从TeX源文件创建TeX DVI文件的程序。默认命令是 tex TEXI2DVI 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 texi2dvi WEAVE 转换Web到TeX的程序。默认命令是 weave CWEAVE 转换C Web 到 TeX的程序。默认命令是 cweave TANGLE 转换Web到Pascal语言的程序。默认命令是 tangle CTANGLE 转换C Web 到 C。默认命令是 ctangle RM 删除文件命令。默认命令是 rm –f 关于命令参数的变量 变量 含义 ARFLAGS 函数库打包程序AR命令的参数。默认值是 rv ASFLAGS 汇编语言编译器参数。（当明显地调用 .s 或 .S 文件时） CFLAGS C 语言编译器参数 CXXFLAGS C++ 语言编译器参数 COFLAGS RCS 命令参数 CPPFLAGS C 预处理器参数（ C 和 Fortran 编译器也会用到） FFLAGS Fortran 语言编译器参数 GFLAGS SCCS “get” 程序参数 LDFLAGS 链接器参数 LFLAGS Lex 文法分析器参数 PFLAGS Pascal 语言编译器参数 RFLAGS Ratfor 程序的 Fortran 编译器参数 YFLAGS Yacc 文法分析器参数 隐含规则链有时一个目标可能被一系列的隐含规则所作用，例如 .o 文件可能先被 Yacc 生成 .c 文件，再由 C 编译器编译 C 文件生成，如果 .c 文件存在， 那么直接调用 C 的编译隐含规则，否则先寻找 Yacc 的 .y 文件，产生 .c。 这一系列的隐含规则叫做“隐含规则链”。 上面由隐含规则推断出来的中间过程的 .c 文件，被称为中间目标。 默认情况下，中间目标和一般目标的 2 个区别：除非中间的目标不存在，才会引发中间规则；只要目标成功产生，那么所产生的中间目标文件会被以 rm -f 删除。 可以使用伪目标 .INTERMEDIATE 来强制声明某个目标为中间目标。例如：.INTERMEDIATE : mid。 可以使用伪目标 .SECONDARY 来强制声明阻止 Make 删除中间目标。例如：.SECONDARY : sec。 定义模式规则模式规则中，至少在规则的目标定义中要包含 %。目标中的 % 定义表示对文件名的匹配，% 表示长度任意的非空字符串。 模式规则示例 12%.o : %.c ; &lt;command ......&gt;;# 定义了怎样从所有的 .c 文件生成相应的 .o 文件的规则 123%.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@# $@ 表示所有的目标的相邻值， $&lt; 表示了所有依赖目标的相邻值 123%.tab.c %.tab.h: %.y bison -d $&lt;# 把所有的 .y 文件都以 bison -d &lt;n&gt;.y 执行，然后生成 &lt;n&gt;.tab.c 和 &lt;n&gt;.tab.h 文件（其中，&lt;n&gt; 表示一个任意字符串 自动化变量 这种变量会把模式中所定义的一系列的文件自动依次取出，直至所有的符合模式的文件都取完了。 自动化变量只应出现在规则的命令中。 自动化变量 含义 $@ 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么 $@ 就是匹配于目标中模式定义的集合 $% 仅当目标是函数库文件中，表示规则中的目标成员名 $&lt; 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $&lt; 将是符合模式的一系列的文件集 $? 所有比目标新的依赖目标的集合，以空格分隔 $^ 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份 $+ 这个变量类似 $^，也是所有依赖目标的集合。只是它不去除重复的依赖目标 $* 这个变量表示目标模式中 % 及其之前的部分。如果目标是 dir/a.foo.b ，并且目标的模式是 a.%.b ，那么，$* 的值就是 dir/a.foo 最好给 $ 后面的那个特定字符都加上圆括号，比如 $(&lt;) 就要比 $&lt; 要好。 四个变量（$@ 、$&lt; 、$% 、$* ）在扩展时只会有一个文件，而外另三个的值是一个文件列表。 搭配上 D 或 F 字符，可以取得文件的目录名或是在当前目录下的符合模式的文件名。 这是 GNU Make 旧版的特性，在新版，使用函数 dir 或 notdir 就可以做到。 七个变量分别加上 D 或是 F 的含义： $(@D) 表示 $@ 的目录部分（不以斜杠作为结尾），如果 $@ 值是 dir/foo.o ，那么 $(@D) 就是 dir ，而如果 $@ 中没有包含斜杠的话，其值就是 . （当前目录）。 $(@F)表示 $@ 的文件部分，如果 $@ 值是 dir/foo.o ，那么 $(@F) 就是 foo.o ， $(@F) 相当于函数 $(notdir $@) 。 $(*D), $(*F) 和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， $(*D) 返回 dir ，而 $(*F) 返回 foo $(%D), $(%F) 分别表示了函数包文件成员的目录部分和文件部分。这对于形同 archive(member) 形式的目标中的 member 中包含了不同的目录很有用。 $(&lt;D), $(&lt;F) 分别表示依赖文件的目录部分和文件部分。 $(^D), $(^F) 分别表示所有依赖文件的目录部分和文件部分。（无相同的） $(+D), $(+F) 分别表示所有依赖文件的目录部分和文件部分。（可以有相同的） $(?D), $(?F) 分别表示被更新的依赖文件的目录部分和文件部分 模式的匹配% 所匹配的内容被称为“茎”，例如 %.c 所匹配的文件 test.c 中 test 就是“茎”。 在目标和依赖目标中同时有 % 时，依赖目标的“茎”会传给目标，当做目标中的“茎”。 当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。 例如有一个模式 e%t，文件 src/eat 匹配于该模式，于是 src/a 就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 c%r，那么目标就是 src/car （“茎”被传递）。 重载内建隐含规则可以重新构造和内建隐含规则不同的命令： 12%.o : %.c $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date) 旧版“后缀规则”后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步取代。 后缀规则有两种方式：“双后缀”和“单后缀” 双后缀 双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。 如 .c.o 相当于 %o : %c 单后缀 定义源文件的后缀。如 .c 相当于 % : %.c 后缀规则中所定义的后缀应该是 Make 所认识的。 12.c.o: $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt; 后缀规则不允许任何的依赖文件。 12.c.o: foo.h $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt; 使用伪目标 .SUFFIXES 来定义或是删除特定后缀。 12.SUFFIXES: # 删除默认的后缀.SUFFIXES: .c .o .h # 定义自己的后缀 make 命令的参数 -r 或 -no-builtin-rules 也会使默认的后缀列表为空。 变量 SUFFIXE 被用来定义默认的后缀列表，可以用 .SUFFIXES 来改变后缀列表，但不要改变变量 SUFFIXE 的值。 隐含规则搜索算法使用 Make 更新函数库文件设有目标 T，搜索目标 T 的规则的算法如下： 所有的后缀规则在 Makefile 被载入内存时，会被转换成模式规则。如果目标是 archive(member) 的函数库文件模式，这个算法会被运行两次，第一次是找目标 T，如果没有找到，进入第二次，第二次把 member 当作 T 来搜索。 把 T 的目录部分分离出来。叫 D，而剩余部分叫 N。（如：如果 T 是 src/foo.o，那么 D 就是 src/，N 就是 foo.o）； 创建所有匹配于T或是N的模式规则列表； 如果在模式规则列表中有匹配所有文件的模式，如 %，那么从列表中移除其它的模式； 移除列表中没有命令的规则； 对于第一个在列表中的模式规则： 1&gt; 推导其“茎”S，S 应该是 T 或是 N 匹配于模式中 % 非空的部分； 2&gt; 计算依赖文件。把依赖文件中的 % 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把 D 加在第一个依赖文件的开头； 3&gt; 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）； 4&gt; 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则： 1&gt; 如果规则是终止规则，那就忽略它，继续下一条模式规则； 2&gt; 计算依赖文件（同第 5 步）； 3&gt; 测试所有的依赖文件是否存在或是理当存在； 4&gt; 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到； 5&gt; 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法； 6&gt; 如果没有隐含规则可以使用，查看 .DEFAULT 规则，如果有，采用，把 .DEFAULT 的命令给T使用。 一旦规则被找到，就会执行其相当的命令，而此时自动化变量的值才会生成。 使用 Make 更新函数库文件函数库文件就是对 Object 文件（程序编译的中间文件）的打包文件。 在Unix下，一般是由 ar 命令来完成打包工作。 函数库文件的成员一个函数库文件由多个文件组成，使用如下格式指定函数库文件及其组成： 1archive(member) 例如： 12foolib(hack.o) : hack.o ar cr foolib hack.o 指定多个 member，使用空格隔开： 1foolib(hack.o kludge.o) 等价于： 1foolib(hack.o) foolib(kludge.o) 使用通配符： 1foolib(*.o) 函数库成员的隐含规则当 Make 搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 a(m) 形式的，其会把目标变成 (m)。 如果成员是 %.o 的模式定义，并且如果使用 make foo.a(bar.o) 的形式调用 Makefile，隐含规则会去找 bar.o 的规则，如果没有定义 bar.o 的规则，那么内建隐含规则生效，Make 会去找 bar.c 文件来生成 bar.o。 流程如下： 123cc -c bar.c -o bar.oar r foo.a bar.orm -f bar.o 函数库文件的后缀规则可以使用“后缀规则”和“隐含规则”来生成函数库打包文件： 1234.c.a: $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o $(AR) r $@ $*.o $(RM) $*.o 等效于： 1234(%.o) : %.c $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o $(AR) r $@ $*.o $(RM) $*.o 注意事项在进行函数库打包文件生成时，需要小心使用 Make 的并行机制（-j 参数）。如果多个 ar 命令在同一时间运行在同一个函数库打包文件上，就很有可能损坏这个函数库文件。","link":"/2020/07/14/makefile-%E6%8C%87%E5%8D%97/"},{"title":"Android JNI 指南","text":"前言编写此文档的用意： 作为 Android NDK 项目开发的参考手册。 对于 NDK 工程的搭建可参考 Android NDK 指南 JNI 简介JNI（Java Native Interface，Java 原生接口），是 Java 和 C++ 组件用以互相通信的接口。 Android 平台下的 JNI 支持由 Android NDK 提供，它是一套能将 C 或 C++（原生代码）嵌入到 Android 应用中的工具。 为什么要使用 JNI 在 Android 平台下进行编程： 在平台之间移植应用； 重复使用现有库，或者提供自己的库供重复使用； 在某些情况下提供高性能，特别是像游戏这种计算密集型应用； 提供安全性保障，在二进制层面比字节码层面的逆向工作更加困难。 JNI 优化原则 尽可能减少跨 JNI 层的编组（Marshalling）数据资源的次数，因为跨 JNI 层进行编组的开销很大。尽可能设计一种接口，减少需要编组的数据量以及必须进行数据编组的频率； 尽量避免在使用受管理的编程语言（在虚拟机中运行）中与 C/C++ 编写的代码之间进行异步通信（例如 C/C++ 中开启线程后直接回调 Java 语言），这样可以使 JNI 接口更容易维护。通常使用与编写界面的相同语言进行异步更新，以简化异步界面的更新，例如，使用 Java 语言创建线程，然后发出对 C++ 层的阻塞调用，然后在阻塞完成后通知界面线程； 尽可能减少需要访问 JNI 或被 JNI 访问的线程数。如果确实需要以 Java 和 C++ 两种语言来利用线程池，请尝试在池所有者之间（而不是各个工作线程之间）保持 JNI 通信； 将接口保存在少量的容易识别的 C++ 和 Java 源位置，以便于将来进行重构。 名词说明下文叙述中使用到的名词说明： JNI 方法，在 Java 层使用 native 声明，使用 C/C++ 中实现的方法。 JNI 函数，JNI 提供的与 Java 层交互的工具一系列函数，例如 RegisterNatives。 不透明，具体结构未知，由具体的虚拟机实现决定。 JavaVM 和 JNIEnvJNI 定义了两个关键的数据结构，JavaVM 和 JNIEnv，它们的本质都是指向函数表的二级指针（在 C++ 版本中，两者都是类，类中都有一个指向函数表的指针，它们的成员函数封装了通过函数表进行访问的 JNI 函数），可以使用 JavaVM 类进行创建和销毁 JavaVM 的操作。理论上，每个进程可以有多个 JavaVM，但 Android 只允许有一个。 JNIEnv 的指针将在每个 JNI 函数的第一个参数中。 这个 JNIEnv 只能用于线程本地存储（Thread Local），所以无法在线程之间共享 JNIEnv，如果需要在其他线程中访问 JNIEnv，可以通过 JavaVM 调用 GetEnv 函数获得相应的 JNIEnv 指针（需要在之前使用过 AttachCurrentThread 对此线程进行附加后调用）。 JavaVM 指针是全局的，可以在线程之间共享，通过保存 JavaVM 用于在其他线程中获取 JNIEnv。 JNIEnv 和 JavaVM 在 C 源文件和 C++ 源文件中的声明不同，使用 C 文件和 C++ 文件包含 jni.h 时，会有不同的类型定义。 123456789// jni.h#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#elsetypedef const struct JNINativeInterface* JNIEnv;typedef const struct JNIInvokeInterface* JavaVM;#endif 因此，不建议同时在这两种语言包含的头文件中添加 JNIEnv 参数（容易导致混乱）。或者当源文件中出现 #ifdef __cplusplus ，且该文件中所有的内容都引用了 JNIEnv 时，那么可能需要做额外的处理。 JNI 方法注册JNI 方法是 Java 代码与 C/C++ 代码沟通的桥梁，使用它时必须首先注册。JNI 方法的声明在 Java 类中，实现在 C/C++ 代码中，在 Java 层的方法声明前面必须添加 native 关键字，然后才能进行注册。 注册方式分为静态注册（根据 JNI 命令规范直接定义对应名字的 C/C++ 函数）和动态注册（使用 RegisterNatives 函数注册到 C/C++ 函数上）两种方式。 例如，Java 声明了如下 JNI 方法： 1234567891011// io.l0neman.jniexample.NativeHandlerpublic class NativeHandler { static { System.loadLibrary(&quot;hello&quot;); } // 期望 JNI 返回一个字符串。 public static native String getString();} NDK 工程描述如下： 123456789src/main/ | +-- java +-- jni | +-- Android.mk +-- Application.mk +-- hello.cpp +-- hello.h 12345678910# Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := helloLOCAL_SRC_FILES := hello.cppinclude $(BUILD_SHARED_LIBRARY) 下面将针对上面搭建的 NDK 工程，采用两种方式在 C/C++ 代码中实现 Java 类 NativeHandler 中的 getString 方法并注册。 静态注册静态注册只需要按照 JNI 接口规范，在 C/C++ 代码中声明一个 Java_[全类名中 的 . 替换为 _]_[方法名] 函数，然后添加 JNIEXPORT 前缀即可。 当系统加载 so 文件后，将根据名字对应规则，自动注册 JNI 方法。 下面采用了 C++ 代码描述，其中的函数需要使用 extern &quot;C&quot; 来包括（为了兼容 C 语言的符号签名规则，让 C 语言能够正常链接调用它）。 12345678910111213// hello.h#ifndef NDKTPROJECT_MAIN_H#define NDKTPROJECT_MAIN_H#include &lt;jni.h&gt;extern &quot;C&quot; {JNIEXPORT jstring JNICALLJava_io_l0neman_jniexample_NativeHandler_getString(JNIEnv *env, jclass clazz);}#endif //NDKTPROJECT_MAIN_H 123456789// hello.cpp#include &quot;main.h&quot;extern &quot;C&quot; {jstring Java_io_l0neman_jniexample_NativeHandler_getString(JNIEnv *env, jclass clazz) { return env-&gt;NewStringUTF(&quot;hello&quot;);}} 如果是 C 语言代码的实现，那么可以去除 extern &quot;C&quot; 的声明，且返回字符串的代码要改为： 12// 此时 C 语言中的 env 不是类，只是一个指向函数表的指针return (*env)-&gt;NewStringUTF(env, &quot;hello&quot;); 此时就注册完成了，Java 层可以直接调用 textView.setText(NativeHandler.getString()) 进行测试了。 这种注册方式简单直接，但是所有 C/C++ 中实现的 JNI 函数符号都需要被导出，对于逆向人员来说，使用 IDA Pro 可以直接看到注册 JNI 方法的名字，快速定位到对应的 Java 代码。 动态注册动态注册与静态注册不同，它是用 JNIEnv 类型提供的 registerNatives 方法来将 JNI 方法动态绑定到指定的 C/C++ 函数上。 首先需要实现 JNI 提供的标准入口函数，JNI_OnLoad，它将会在调用 System.loadLibrary(&quot;hello&quot;) 后，由 Java 虚拟机进行回调，同时可以实现可选的 JNI_OnUnload 函数，用于虚拟机将动态库卸载时回收资源。 12345// hello.cppJNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { return JNI_VERSION_1_6;} 返回值表示要使用的 JNI 版本，返回低版本，将不能使用高版本提供的一些 JNI 函数，这里返回当前最高版本 JNI_VERSION_1_6，如果返回其它非版本数值，将导致加载 so 库失败。 完整注册代码如下： 1234567891011121314151617181920212223242526272829303132333435// hello.cppstatic const char *CLASS_NAME = &quot;io/l0neman/jniexample/NativeHandler&quot;;static jstring getString(JNIEnv *env, jclass nativeHandler) { return env-&gt;NewStringUTF(&quot;hello&quot;);}static JNINativeMethod gMethods[] = { {&quot;getString&quot;, &quot;()Ljava/lang/String;&quot;, (void *) getString},};JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = nullptr; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } jclass nativeHandlerClass = env-&gt;FindClass(CLASS_NAME); if (nativeHandlerClass == nullptr) { return JNI_ERR; } jint methods = sizeof(gMethods) / sizeof(JNINativeMethod); jint ret = env-&gt;RegisterNatives(nativeHandlerClass, gMethods, methods); if (ret != JNI_OK) { return ret; } return JNI_VERSION_1_6;}JNIEXPORT void JNI_OnUnload(JavaVM *vm, void *reserved) { // 回收工作} 从 JNI_OnLoad 开始看。 首先 RegisterNatives 这个函数由 JNIEnv 类型提供，而 JNI_OnLoad 第一个参数是 JavaVM *，所以，这里首先获取 JNIEnv 类型指针，使用 JavaVM 的 GetEnv 函数获取（由于系统默认已经附加到线程，所以这里才能直接 GetEnv）; 下面需要使用 RegisterNatives 注册 JNI 函数，看一下它的声明： 123// jni.hjint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods); 第 1 个参数是 JNI 方法所在的 Java 类，第 2 个是包含需要注册的 JNI 方法对应关系的数组，第 3 个是要注册的 JNI 方法数量或者说前面的数组大小。 那么，就根据要求填充相关参数。 使用 JNIEnv 的 FindClass 来获得表示 NativeHandler 类型的 jclass，可以看到描述全类名的方法，将 . 替换为路径符号 / 即可，这样得到了第一个参数； 定义一个 JNINativeMethod 的数组，每个 JNINativeMethod 都用于描述一个 JNI 方法的 Java 方法声明和 C/C++ 函数的一对一关系。 JNINativeMethod 定义如下： 1234567// jni.htypedef struct { const char* name; const char* signature; void* fnPtr;} JNINativeMethod; 分别是 Java 层 JNI 方法的名字，方法签名，和要注册的 C/C++ 函数地址。 在方法签名中，每种 Java 基本类型都有对应的签名字符串，引用类型则为 L[全类型名中的 . 替换为 /];。 JNI 类型签名如下表： 签名 Java 类型 Z boolean B byte C char S short I int J long F float D double L 引用类型 [ 数组前缀 示例： 1long f (int n, String s, int[] arr); 签名为： 1(ILjava/lang/String;[I)J 那么前面的代码中的 gMethods 数组，即表明了要把 NativeHandler 中的 getString 注册绑定到 C++ 中的 getString 函数上。 最后调用 env-&gt;RegisterNatives 函数就可以了，一般情况下，注册成功，那么返回 JNI_OK。 可以允许在 JNI_OnLoad 中绑定多个 Java 类中的 native 方法，建议不要这样做，会导致难以维护。 动态注册的好处是，可以只导出 JNI_OnLoad（注册的 C/C++ 函数可以进行符号优化，不导出），生成速度更快且更小的代码，且可避免与加载到应用中的其他库发生潜在冲突。 类静态方法和类成员方法注册 Java 中的静态 JNI 方法和类成员 JNI 方法的区别是，对应的 C/C++ 函数的回调参数不同。 123456789101112// io.l0neman.jniexample.NativeHanderpublic class NativeHandler { static { System.loadLibrary(&quot;hello&quot;); } public static native String getString(); public native String getHello();} 对应的 C++ 函数： 12345678jstring getString(JNIEnv *env, jclass nativeHandler) { return env-&gt;NewStringUTF(&quot;hello&quot;);}jstring getHello(JNIEnv *env, jobject thiz) { jclass nativeHandlerClass = env-&gt;GetObjectClass(thiz); return env-&gt;NewStringUTF(&quot;hello&quot;);} 静态方法传递的是代码 Java 类的 jclass，而类方法传递的是表示 Java this 对象的 jobject，可以使用它来访问对应的 this 对象内的成员变量和相关方法。如果需要访问 jclass，使用 JNI 提供的 GetObjectClass 函数获取。 在注册工作完成后，就可以从 Java 层调用 JNI 方法，使用 C/C++ 语言处理逻辑了。 Java 层访问在 C/C++ 代码中，需要对 Java 层进行访问，最基本的两种访问操作就是读写 Java 类成员和调用 Java 类方法。 Java 成员变量访问JNI 提供了一系列访问 Java 类的静态成员和对象成员的函数，例如。 123456789GetStaticIntField(); // 读取 Java 类型为 int 的类静态成员SetStaticIntField(); // 写入 Java 类型为 int 的类静态成员GetStaticObjectField(); // 读取类型为 Java 引用的类静态成员SetStaticObjectField(); // 写入类型为 Java 引用的类静态成员GetIntField(); // 读取 Java 类型为 int 的类对象成员SetIntField(); // 写入 Java 类型为 int 的类对象成员GetObjectField(); // 读取类型为 Java 引用的类对象成员SetObjectField(); // 写入类型为 Java 引用的类对象成员 总结为： 1234GetStatic&lt;type&gt;Field(); // 读取 Java 类型为 type 的类静态成员SetStatic&lt;type&gt;Field(); // 写入 Java 类型为 type 的类静态成员Get&lt;type&gt;Field(); // 读取 Java 类型为 type 的类对象成员Set&lt;type&gt;Field(); // 写入 Java 类型为 type 的类对象成员 当需要访问静态成员时需要提供一个代表 Java 类型的 jclass 作为参数，访问类对象成员时则需要一个表示 Java 对象的 jobject 作为参数。 同时两者都需要首先提供目标 Java 类成员的 JNI 类型签名（符合上面的 JNI 签名表规则），用来获取一个不透明的 jfieldID 类型，传递给 JNI 函数，用于找到目标成员，之后才能使用上述 JNI 函数访问 Java 类成员。 1jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig); Java 类方法访问JNI 同时也提供了一系列调用 Java 类的静态方法和对象方法的函数，例如： 123456789CallStaticVoidMethod(); // 调用返回值类型为 void 的静态方法CallStaticIntMethod(); // 调用返回值类型为 int 的静态方法CallObjectMethod(); // 调用返回值类型为 Java 引用的静态方法// ...CallVoidMethod(); // 调用返回值类型为 void 的对象方法CallIntMethod(); // 调用返回值类型为 int 的对象方法CallObjectMethod(); // 调用返回值类型为 Java 引用的成员方法// ... 总结为： 12env-&gt;CallStatic&lt;type&gt;Method(); // 调用返回值类型为 type 的静态方法env-&gt;Call&lt;type&gt;Method(); // 调用返回值类型为 type 的成员方法 当需要调用静态方法时需要提供一个代表 Java 类型的 jclass 作为参数，调用类成员方法时则需要一个表示 Java 对象的 jobject 作为参数。 同时两者都需要首先提供目标 Java 方法的 JNI 签名（符合上面的 JNI 签名表规则），用来获取一个不透明的 jMethodID 类型，传递给 JNI 函数，用于找到目标方法，之后才能使用上述 JNI 函数调用 Java 类方法。 Java 层访问实例下面对实际的 Java 类成员和方法进行访问和调用。 首先定义一个 Java 类，JniCallExample。 123456789101112131415// io.hexman.jniexample.JniCallExamplepublic class JniCallExample { private static int sFlag = 256; private String mData = &quot;info&quot;; public String getData() { return mData; } public static boolean setHello(String hello) { return &quot;hello&quot;.equals(hello); }} JniCallExample 类具有一个静态成员 sFlag，和成员变量 mData，还包含一个 getData 成员方法和一个静态方法。 那么下面将进行如下操作： 读取 sFlag 的值并打印； 改变 mData 的值，然后调用 Java 层的 getData 方法，获得修改后的值； 调用 Java 层的 sayHello 方法，传递 hello 字符串，获得方法返回值。 这里需要在 C/C++ 代码中打印变量，所以需要使用 NDK 提供的 liblog 库，Android.mk 如下： 1234567891011LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := helloLOCAL_SRC_FILES := hello.cpp# 此行表示依赖 liblog 库LOCAL_LDLIBS := -lloginclude $(BUILD_SHARED_LIBRARY) 下面开始编写源代码。 首先在 NativeHandler 类里面，声明 JNI 方法 void testAccessJava(JniCallExample jniCallExample)，用于调用 C/C++ 代码来启动测试。 其中提供一个 JniCallExample 对象，是因为需要访问它的成员值。 12345678910// io.hexman.jniexample.NativeHandlerpublic class NativeHandler { static { System.loadLibrary(&quot;hello&quot;); } public static native void testAccessJava(JniCallExample jniCallExample);} 然后在 C++ 代码中定义对应的 JNI 方法的实现函数，并在 JNI_OnLoad 中注册函数。 12345678910111213141516171819202122232425262728293031// hello.cppstatic const char *CLASS_NAME = &quot;io/l0neman/jniexample/NativeHandler&quot;;static JNINativeMethod gMethods[] = { {&quot;testAccessJava&quot;, &quot;(Lio/l0neman/jniexample/JniCallExample;)V&quot;, (void *) testAccessJava},};void testAccessJava(JNIEnv *env, jobject nativeHandler) { // ...}JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = nullptr; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } jclass nativeHandlerClass = env-&gt;FindClass(CLASS_NAME); if (nativeHandlerClass == nullptr) { return JNI_ERR; } jint methods = sizeof(gMethods) / sizeof(JNINativeMethod); jint ret = env-&gt;RegisterNatives(nativeHandlerClass, gMethods, methods); if (ret != JNI_OK) { return ret; } return JNI_VERSION_1_6;} 下面填充 testAccessJava 的逻辑： 1234567891011121314151617181920212223242526272829303132333435363738// hello.cppstatic const char *TAG = &quot;TAJ&quot;;// 用于输出 Java 字符串（mData）的工具函数void utilPrintJavaStr(JNIEnv *env, jstring jStr) { const char *mDataCChar = env-&gt;GetStringUTFChars(jStr, nullptr); // str+ // 这里需要把 Java 字符串转为 C 字符串才能输出 __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;jniCallExample.mData: %s&quot;, mDataCChar); env-&gt;ReleaseStringUTFChars(jStr, mDataCChar); // str-}void testAccessJava(JNIEnv *env, jclass nativeHandler, jobject jniCallExample) { jclass jniCallExampleClass = env-&gt;FindClass(&quot;io/l0neman/jniexample/JniCallExample&quot;); jfieldID sFlagStaticFieldId = env-&gt;GetStaticFieldID(jniCallExampleClass, &quot;sFlag&quot;, &quot;I&quot;); // Java: int sFlag = JniCallExample.sFlag; jint sFlag = env-&gt;GetStaticIntField(jniCallExampleClass, sFlagStaticFieldId); __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;JniCallExample.sFlag: %d&quot;, sFlag); jfieldID mDataFieldId = env-&gt;GetFieldID(jniCallExampleClass, &quot;mData&quot;, &quot;Ljava/lang/String;&quot;); // Java: newData = &quot;data; jstring newData = env-&gt;NewStringUTF(&quot;data&quot;); // Java: jniCallExample.mData = newData; env-&gt;SetObjectField(jniCallExample, mDataFieldId, newData); jmethodID getDataMethodId = env-&gt;GetMethodID(jniCallExampleClass, &quot;getData&quot;, &quot;()Ljava/lang/String;&quot;); // Java: String newMData = jniCallExample.getData(); jstring newMData = (jstring) env-&gt;CallObjectMethod(jniCallExample, getDataMethodId); utilPrintJavaStr(env, newMData); jmethodID setHelloStaticMethodId = env-&gt;GetStaticMethodID(jniCallExampleClass, &quot;setHello&quot;, &quot;(Ljava/lang/String;)Z&quot;); // JavaL helloParam = &quot;hello&quot;; jstring helloParam = env-&gt;NewStringUTF(&quot;hello&quot;); // Java: JniCallExample.setHello(helloParam); jboolean isSetHello = (jboolean) env-&gt;CallStaticBooleanMethod(jniCallExampleClass, setHelloStaticMethodId, helloParam); __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;isSetHello %d&quot;, isSetHello);} 打印出如下结果： 123JniCallExample.sFlag: 256jniCallExample.mData: dataisSetHello 1 其中注释 Java: xxx 表示与 Java 代码有相同作用。 其中包含一部分对于字符串的操作： env-&gt;NewStringUTF(&quot;data&quot;) 用于创建一个 Java 字符串（new String()），它的内存由 Java 虚拟机管理，它使用 jstring 类型来描述，是一个 JNI 提供的不透明类型，用于映射一个 Java 字符串。每种 Java 类型都有对应的映射类型（下面会提供映射表），这里用作 Java 变量来给 Java 变量赋值或者作为参数传递。 env-&gt;GetStringUTFChars(jStr, nullptr); 用于从 Java 字符串中取得 C 形式的 Modified_UTF-8（下文介绍）字符串，它将会在 native 层分配内存，而不是由 Java 虚拟机管理，所以使用后需要手动使用 ReleaseStringUTFChars 释放。 访问优化在对 Java 层进行访问时，不管是访问 Java 类成员还是调用 Java 方法，都需要首先使用 FindClass 找到目标 Java 类，然后获取对应的成员 ID 和方法 ID， 对于 FindClass 和查找相关 ID 的函数，每次调用它们可能都需要进行多次的字符串比较，而使用这些 ID 去访问对于的 Java 类成员和方法速度却是很快的。 那么如果需要多次访问相同的 Java 目标，那么考虑将这些 jclass（FindClass 的结果）和相关 ID 缓存起来。 这些变量在被访问的 Java 类被卸载之前保证是有效的。只有在与 ClassLoader 关联的所有类都满足垃圾回收条件时，系统才会卸载这些类，这种情况比较少见，但在 Android 中是有可能出现的。 Android 推荐的方法是，在 Java 类中声明一个名叫 nativeInit 的 JNI 方法，在类的静态块内调用，这个 JNI 方法就负责提前缓存要使用的 Java 类型，那么一个类被加载时，nativeInit 就会被调用。 可以在 Android 系统源码中看到许多名叫 nativeInit 的 JNI 方法，它们就是负责此用途的。 一般使用 static 结构来缓存这些 ID 和 jclass，jclass 作为 Java 引用，需要使用 NewGlobalRef 函数创建一个全局引用来保护它不被回收。 那么现在改进之前的 Java 访问实例，如下： 首先在 NativeHandler 中增加 nativeInit 方法。 12345678910111213// io.hexman.jniexample.NativeHandlerpublic class NativeHandler { static { System.loadLibrary(&quot;hello&quot;); nativeInit(); } public static native void nativeInit(); public static native void testAccessJava(JniCallExample jniCallExample);} 然后是源代码，注册部分只修改 JNINativeMethod 数组即可： 1234static JNINativeMethod gMethods[] = { {&quot;testAccessJava&quot;, &quot;(Lio/l0neman/jniexample/JniCallExample;)V&quot;, (void *) testAccessJava}, {&quot;nativeInit&quot;, &quot;()V&quot;, (void *) nativeInit}}; 然后是 nativeInit 的逻辑和修改过的 testAccessJava 函数的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// hello.cpp// 缓存结构体struct JniCallExampleHolder { jclass jniCallExampleClass; jfieldID sFlagStaticFieldId; jfieldID mDataFieldId; jmethodID getDataMethodId; jmethodID setHelloStaticMethodId;};static JniCallExampleHolder gJniCallExampleHolder;// 提前缓存 jclass 和访问 IDvoid nativeInit(JNIEnv *env, jclass clazz) { jclass jniCallExampleClass = env-&gt;FindClass(&quot;io/l0neman/jniexample/JniCallExample&quot;); gJniCallExampleHolder.jniCallExampleClass = (jclass) env-&gt;NewGlobalRef(jniCallExampleClass); // gr+ gJniCallExampleHolder.sFlagStaticFieldId = env-&gt;GetStaticFieldID(jniCallExampleClass, &quot;sFlag&quot;, &quot;I&quot;);; gJniCallExampleHolder.mDataFieldId = env-&gt;GetFieldID(jniCallExampleClass, &quot;mData&quot;, &quot;Ljava/lang/String;&quot;); gJniCallExampleHolder.getDataMethodId = env-&gt;GetMethodID(jniCallExampleClass, &quot;getData&quot;, &quot;()Ljava/lang/String;&quot;);; gJniCallExampleHolder.setHelloStaticMethodId = env-&gt;GetStaticMethodID(jniCallExampleClass, &quot;setHello&quot;, &quot;(Ljava/lang/String;)Z&quot;);}void testAccessJava(JNIEnv *env, jclass nativeHandler, jobject jniCallExample) { // Java: int sFlag = JniCallExample.sFlag; jint sFlag = env-&gt;GetStaticIntField(gJniCallExampleHolder.jniCallExampleClass, gJniCallExampleHolder.sFlagStaticFieldId); __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;JniCallExample.sFlag: %d&quot;, sFlag); // Java: newData = &quot;data; jstring newData = env-&gt;NewStringUTF(&quot;data&quot;); // Java: jniCallExample.mData = newData; env-&gt;SetObjectField(jniCallExample, gJniCallExampleHolder.mDataFieldId, newData); // Java: String newMData = jniCallExample.getData(); jstring newMData = (jstring) env-&gt;CallObjectMethod(jniCallExample, gJniCallExampleHolder.getDataMethodId); utilPrintJavaStr(env, newMData); // JavaL helloParam = &quot;hello&quot;; jstring helloParam = env-&gt;NewStringUTF(&quot;hello&quot;); // Java: JniCallExample.setHello(helloParam); jboolean isSetHello = (jboolean) env-&gt;CallStaticBooleanMethod(gJniCallExampleHolder.jniCallExampleClass, gJniCallExampleHolder.setHelloStaticMethodId, helloParam); __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;isSetHello %d&quot;, isSetHello);} 其中有一个地方使用了 env-&gt;NewGlobalRef 建立了一个全局引用，它会保护这个 jclass 不会在 JNI 函数执行完之后被回收，注意需要在不使用的时候使用 env-&gt;DeleteGlobalRef 释放引用，例如 JNI_OnUnload 中。 JNI 类型每种 Java 类型在 JNI 中都有对应的本地数据类型，C/C++ 通过 JNI 方法与 Java 层进行交互时，均是使用这些类型进行参数传递，此时虚拟机再根据每种类型翻译为相应的 Java 类型传递给 Java 层方法. 还有一些特殊的数据类型用来存储 Java 方法 ID 和类成员 ID。 基本数据类型 Java 类型 本地类型 说明 boolean jboolean unsigned 8 bits byte jbyte signed 8 bits char jchar signed 16 bits short jshort signed 16 bits int jint signed 32 bits long jlong signed 64 bits float jfloat 32 bits double jdouble 64 bits void void 无 jboolean 的两种取值： 12#define JNI_FALSE 0 #define JNI_TRUE 1 jsize 类型用于描述数组大小或者索引。 从 jni.h 中看它们和真实 C/C++ 数据类型的对应关系： 1234567891011121314// jni.h/* Primitive types that match up with Java equivalents. */typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 *//* &quot;cardinal indices and sizes&quot; */typedef jint jsize; 引用类型在 C++ 中，Java 引用类型使用一些类表示，它们的继承关系如下： 1234567891011121314151617jobject (所有 Java 对象) | +-- jclass (java.lang.Class 对象) +-- jstring (java.lang.String 对象) +-- jarray (数组) | | | +-- jobjectArray (object 数组) | +-- jbooleanArray (boolean 数组) | +-- jbyteArray (byte 数组) | +-- jcharArray (char 数组) | +-- jshortArray (short 数组) | +-- jintArray (int 数组) | +-- jlongArray (long 数组) | +-- jfloatArray (float 数组) | +-- jdoubleArray (double 数组) | +- jthrowable (java.lang.Throwable 对象) 源码中定义如下： 1234567891011121314151617181920212223242526272829303132// jni.hclass _jobject {};class _jclass : public _jobject {};class _jstring : public _jobject {};class _jarray : public _jobject {};class _jobjectArray : public _jarray {};class _jbooleanArray : public _jarray {};class _jbyteArray : public _jarray {};class _jcharArray : public _jarray {};class _jshortArray : public _jarray {};class _jintArray : public _jarray {};class _jlongArray : public _jarray {};class _jfloatArray : public _jarray {};class _jdoubleArray : public _jarray {};class _jthrowable : public _jobject {};typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray* jbyteArray;typedef _jcharArray* jcharArray;typedef _jshortArray* jshortArray;typedef _jintArray* jintArray;typedef _jlongArray* jlongArray;typedef _jfloatArray* jfloatArray;typedef _jdoubleArray* jdoubleArray;typedef _jthrowable* jthrowable;typedef _jobject* jweak; 在 C 语言中，所有 JNI 引用类型都与 jobject 的定义相同。 1234567891011121314151617// jni.htypedef void* jobject;typedef jobject jclass;typedef jobject jstring;typedef jobject jarray;typedef jarray jobjectArray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jobject jthrowable;typedef jobject jweak; 方法和类成员 ID它们是不透明结构体指针类型： 1234567// jni.hstruct _jfieldID;typedef struct _jfieldID *jfieldID; struct _jmethodID;typedef struct _jmethodID *jmethodID; 数组元素jvalue 用于作为参数数组中的元素类型： 12345678910111213// jni.htypedef union jvalue { jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l;} jvalue; 引用管理Java 对象在 JNI 中有两种引用方式，一种是局部引用；一种是全局引用。 局部引用Java 层通过 JNI 方法传递给 C/C++ 函数的每个对象参数，以及 C/C++ 通过 JNI 函数（Call&lt;type&gt;Method）调用接收的 Java 方法的对象返回值都属于局部引用。 局部引用仅在当前线程中的当前 C/C++ 函数运行期间有效。在 C/C++ 函数返回后，即使对象本身继续存在，该引用也无效。 局部引用适用于 jobject 的所有子类，包括 jclass、jstring 和 jarray。 全局引用创建全局引用只能使用 NewGlobalRef 和 NewWeakGlobalRef 函数。 如果希望长时间的持有某个引用，那么必须使用全局引用，使用 NewGlobalRef 函数时将局部引用作为参数传入，换取全局引用。在调用 DeleteGlobalRef 删除全局引用之前，此引用保证有效。 通常用于缓存 FindClass 返回的 jclass，就像前面的 Java 访问优化中所做的措施一样。 12jclass localClass = env-&gt;FindClass(&quot;MyClass&quot;);jclass globalClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(localClass)); 提示对于同一个对象的引用可能存在多个不同的值，例如，对于同一个对象多次调用 NewGlobalRef 所返回的值可能不同。 如果需要比较两个引用是否指向同一个对象，必须使用 IsSameObject 函数，切勿在 C/C++ 代码中使用 == 比较各个引用。 在两次调用 NewGlobalRef 对同一个对象创建全局引用时，表示这个对象的 32 位值可能不同；而在多次调用 NewGlobalRef 创建不同对象的全局引用时，它们可能具有相同的 32 位值，所以不能将 jobject 用作 key 使用。 不要过度分配局部引用，如果需要创建大量引用，应该主动调用 DeleteLocalRef 删除它们，而不是期望 JNI 自动删除。JNI 默认实现只能保留 16 个局部引用，如果需要保存更多数量，可以按照需要删除，或使用 EnsureLocalCapacity/PushLocalFrame 申请保留更多引用数量。 jfieldID 和 jmethodID 为不透明类型，不属于对象引用，所以不能使用 NewGlobalRef 保护。GetStringUTFChars 和 GetByteArrayElements 返回的原始数据指针也不属于对象。 一种特殊情况是，如果使用 AttachCurrentThread 附加到 C/C++ 线程，那么在线程分离之前，运行中的代码一定不会自动释放局部引用。代码创建的任何局部引用都必须手动删除。通常，在循环中创建局部引用的任何 C/C++ 代码需要执行某些手动删除操作。 谨慎使用全局引用。全局引用不可避免，但它们很难调试，并且可能会导致难以诊断的内存（不良）行为。在所有其他条件相同的情况下，全局引用越少，解决方案的效果可能越好。 Java 常用数据访问对 Java 字符串和数组的访问方法。访问这些数据是 JNI 开发的基础。 访问字符串访问字符串有如下两种情况： Java 层调用 JNI 方法，String 对象以 jstring 的形式传入 JNI 方法，此时 C/C++ 语言接收使用； C/C++ 产生字符串数据，返回给 Java 层使用。 代码如下： 1234// Java Code// hello = &quot;result&quot;final String hello = NativeHandler.testAccessString(&quot;hello&quot;); 123456789// C++ Codejstring testAccessString(JNIEnv *env, jclass clazz, jstring hello) { const char *stringChars = env-&gt;GetStringUTFChars(hello, nullptr); // str+ __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;java string: %s&quot;, stringChars); env-&gt;ReleaseStringUTFChars(hello, stringChars); // str- return env-&gt;NewStringUTF(&quot;result&quot;);} 获取字符串GetStringUTFChars 将返回 C/C++ 语言可以直接使用的 Modified_UTF-8 格式字符串（Modified_UTF-8 格式是 JNI 提供的优化后的 UTF-8 格式字符串，优化后的编码对 C 代码友好，因为它将 \\u0000 编码为 0xc0 0x80，而不是 0x00。这样做的好处是，可以依靠以 \\0 终止的 C 样式字符串，非常适合与标准 libc 字符串函数配合使用。但缺点是，无法将任意 UTF-8 的数据传递给 JNI 函数）。 在使用 GetStringUTFChars 获取字符串后，JavaVM 为字符串在 native 层分配了内存，在字符串使用完毕后，必须使用 ReleaseStringUTFChars 释放内存，否则将会造成内存泄漏。 从 C/C++ 获取 Java 字符串的长度有两种方式，可直接使用 GetStringUTFLength 对 jstring 计算长度： 1234// Java Codejstring hello;jsize utfLength = env-&gt;GetStringUTFLength(hello); 或者使用 C/C++ 的 strlen 计算： 1234// C++ Codeconst char *stringChars = env-&gt;GetStringUTFChars(hello, nullptr);size_t utfLength = strlen(stringChars); GetStringUTFChars 函数的第 2 个参数是一个 jboolean 类型的指针，表示关心是否创建了字符串的副本，如果创建了字符串的副本它会返回 JNI_TRUE，否则为 JNI_FALSE，不管是否创建，都需要 Release 操作，所以一般不会关心它的结果，传递 nullptr 即可（C 语言传递 NULL）。 123456789// C++ Codejboolean isCopy;const char *stringChars = env-&gt;GetStringUTFChars(hello,); // str+if (isCopy == JNI_TRUE) { // 创建了字符串副本} else if (isCopy == JNI_FALSE) { // 未创建字符串副本} 提示JNI 还提供了 GetStringChars 函数，它返回的是 UTF-16 字符串，使用 UTF-16 字符串执行操作通常会更快，但是 UTF-16 字符串不是以零终止的，并且允许使用 \\u0000，因此需要保留字符串长度和返回的 jchar 指针。 一般的开发中几乎都使用 GetStringUTFChars 获取字符串。 返回字符串如果需要返回给 Java 层字符串，使用 env-&gt;NewStringUTF(&quot;result&quot;) 即可，JavaVM 将会基于 C 字符串创建一个新的 String 的对象，它的内存由虚拟机管理。 注意传递给 NewStringUTF 的数据必须采用 Modified_UTF-8 格式。一种常见的错误是从文件或网络数据流中读取字符数据，在未过滤的情况下将其传递给 NewStringUTF。除非确定数据是有效的 Modified_UTF-8 格式（或 7 位 ASCII，这是一个兼容子集），否则需要剔除无效字符或将它们转换为适当的 Modified_UTF-8 格式。如果不这样做，UTF-16 转换可能会产生意外的结果（Java 语言使用的是 UTF-16）。默认状态下 CheckJNI 会为模拟器启用，它会扫描并在收到无效字符串输入时中止虚拟机。 访问数组和访问 Java 成员类似，JNI 提供了一系列访问数组的函数： 1234GetIntArrayElements();GetBooleanArrayElements();GetDoubleArrayElements();// ... 总结为： 1Get&lt;type&gt;ArrayElements(); 其中 &lt;type&gt; 中只能是 Java 的基本类型，不包含 String 以及其他引用类型。 下面分别使用 C/C++ 获取 Java 传递的 int 类型和 String 的数组，作为获取 Java 基本类型和引用类型数组的典型示例： 12345// Java Codeint[] array0 = {1, 2, 3, 4, 5};String[] array1 = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;};NativeHandler.testAccessArray(array0, array1); 1234567891011121314151617181920212223// C++ Codevoid testAccessArray(JNIEnv *env, jclass clazz, jintArray array0, jobjectArray array1) { // 访问原始数组 jint *elements0 = env-&gt;GetIntArrayElements(array0, nullptr); if(elements0 != nullptr) { jsize array0Length = env-&gt;GetArrayLength(array0); for (jint i = 0; i &lt; array0Length; i++) { __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;array0[%d] = %d&quot;, i, elements0[i]); } env-&gt;ReleaseIntArrayElements(array0, elements0, 0); } // 访问对象数组 jsize array1Length = env-&gt;GetArrayLength(array1); for (jint i = 0; i &lt; array1Length; i++) { jstring element = (jstring) env-&gt;GetObjectArrayElement(array1, i); const char *chars = env-&gt;GetStringUTFChars(element, nullptr); // str+ __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;array1[%d] = %s&quot;, i, chars); env-&gt;ReleaseStringUTFChars(element, chars); // str- }} 输出如下： 12345678910array0[0] = 1array0[1] = 2array0[2] = 3array0[3] = 4array0[4] = 5array1[0] = aarray1[1] = barray1[2] = carray1[3] = darray1[4] = e 代码比较清晰，可以看到基本类型的数组，直接可以使用 Get&lt;type&gt;ArrayElements(...) 获得一个数组的首地址，使用 GetArrayLength 获取数组长度后，即可像 C/C++ 原生数组一样使用指针遍历每一个元素。 在对原生类型的数组访问之后，需要调用 Release&lt;type&gt;ArrayElements 请求释放内存。 对象数组则没有提供 Get&lt;type&gt;ArrayElements(...) 的方法，但是它提供了获取单个元素的 GetObjectArrayElement 方法，那么也可以使用循环获取每个 jobject 元素，然后转换为原本的类型。 如果需要更改原生类型的数组元素值，直接修改获取 C/C++ 数组元素的值，JNI 将会把值复制回原始数据区中。 如果需要更改引用类型的数组元素值，JNI 提供了 SetObjectArrayElement 函数，可直接修改原始元素对象。 1env-&gt;SetObjectArrayElement(array1, 1, env-&gt;NewStringUTF(&quot;hello&quot;)); 提示JNI 为了在不限制虚拟机实现的情况下使接口尽可能高效，允许 Get&lt;type&gt;ArrayElements(...) 函数的调用在运行时直接返回指向实际数据元素的指针，或者分配一些内存创建数据的副本。 在调用 Release 之前，返回的原生数组指针保证可用，如果没有创建数据的副本，那么原生数组将被固定，在虚拟机整理内存碎片时不会调整原生数组的位置，Release 的时候需要进行判空操作，防止在 Get 数组失败时 Release 空指针。 ReleaseIntArrayElements 函数的最后一个函数的 mode 参数有三个，运行时执行的操作取决于返回的指针指向实际数据还是指向数据副本。 mode 以及对应的 Release 行为： 0 实际数据：取消数组元素固定。数据副本：将数据复制回原始数据，释放包含副本的缓冲区。 JNI_COMMIT 实际数据：不执行任何操作。数据副本：将数据复制回原始数据，不释放包含副本的缓冲区。 JNI_ABORT 实际数据：取消数组元素固定，不中止早期的写入数据。数据副本：释放包含相应副本的缓冲区；对该副本所做的任何更改都会丢失。 通常传递 0 来保持固定和复制数组的行为一致，其他选项可以用来更好地控制内存，需要谨慎传递。 其中 GetIntArrayElements 的第 2 个参数，它类似于 GetStringUTFChars 的第 2 个参数，也是 isCopy，表示获取数组时是否创建了数据副本。 通常检查 isCopy 标志的原因有两个： 了解是否需要在对数组进行更改后使用 JNI_COMMIT 调用 Release 函数，如果需要在对数组进行更改和仅使用数组内容的代码之间切换，则可以跳过释放缓冲区提交（更改数组数据后需要继续访问数组）； 有效处理 JNI_ABORT，考虑可能需要获取一个数组，然后进行适当修改后，将数组的一部分传递给其他函数使用，最后舍弃对数组的修改。如果知道 JNI 为数组创建了副本，那么就不需要自己创建一个可被修改的副本，如果 JNI 传递的是实际数据的指针，那么就需要自己创建数组的副本。 注意不能认为 *isCopy 为 JNI_FALSE 时就不需要调用 Release，这是一种常见误区。 如果 JNI 没有分配任何副本缓冲区，返回指向实际数据的指针，那么虚拟机必须固定实际数组的内存，此时垃圾回收器将不能移动内存，造成内存不能释放。 JNI_COMMIT 标记不会释放数组，最终还需要使用其他标记再次调用 Release。 数组区域调用如果只想复制 Java 数组，使用 Get&lt;type&gt;ArrayRegion 更好。 通常使用 Get&lt;type&gt;ArrayElements 时，如果需要复制数组数据到外部的缓冲区中，代码如下： 12345jbyte* data = env-&gt;GetByteArrayElements(array, NULL);if (data != nullptr) { memcpy(buffer, data, len); env-&gt;ReleaseByteArrayElements(array, data, JNI_ABORT);} 这样会复制数组 len 长度的字节到 buffer 中，然后释放数组内存。其中 Get 调用可能会返回实际数组或者实际数组的副本，取决于运行时的情况，代码复制数据（那么上面的代码可能是第 2 次复制），那么这种情况下，使用 JNI_ABORT 确保不会再出现第 3 次复制。 使用 Get&lt;type&gt;ArrayRegion 函数不仅可以完成相同操作，而且不必考虑 Release 调用： 12// 复制数组 len 长度的字节到缓冲区 buffer 中env-&gt;GetByteArrayRegion(array, 0, len, buffer); 区域调用优点： 只需要一个 JNI 调用，而不是两个，减少开销； 不需要固定实际数组或额外复制数据； 降低风险，不存在操作失败后忘记调用 Release 的风险。 除此之外，JNI 还提供了针对于字符串的区域调用函数，GetStringUTFRegion 或 GetStringRegion 将字符数据复制到 String 对象之外。 线程所有线程都是 Linux 线程，由内核调度。线程通常从受虚拟机管理的代码启动（使用 Thread#start() 方法），但也可以在 native 层创建，然后通过 JNI 函数附加到 JavaVM。在 C/C++ 代码中例如使用 pthread_create 启动本地线程，然后调用 JNI 提供的 AttachCurrentThread 或 AttachCurrentThreadAsDeamon 函数，在附加之前，这个线程不会包含任何 JNIEnv，所以无法调用 JNI（JNIEnv 指针不能在多个线程中共享，只能分别附加，主线程默认已被附加）。 被附加成功的本地线程会构建 java.lang.Thread 对象并被添加到 Main ThreadGroup，从而使调试程序能够看到它。在已附加的线程上调用 AttachCurrentThread 属于空操作。 通过 JNI 附加的线程在退出之前必须调用 DetachCurrentThread 分离附加。如果直接对此进行编写代码会很麻烦，可以使用 pthread_key_create 定义在线程退出之前调用的析构函数，之后再调用 DetachCurrentThread。（将该 key 与 pthread_setspecific 配合使用，以将 JNIEnv 存储在线程本地存储中；这样一来，该 key 将作为参数传递到线程的析构函数中。） 附加到本地线程下面是一个附加到线程的示例，使用 pthread_create 创建一个线程，并在线程执行代码中附加： 123// Java Code:NativeHandler.testThread(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// C++ Code:// 线程函数static void *threadTest(void *arg) { JNIEnv *env = nullptr; // 尝试获得已附加的 JNIEnv jint ret = gJavaVM-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6); switch (ret) { case JNI_OK: __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;获得了 JNIEnv.&quot;); break; case JNI_EDETACHED: ret = gJavaVM-&gt;AttachCurrentThread(&amp;env, nullptr); if (ret == JNI_OK) { __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;线程已附加. %ld&quot;, (long) pthread_getspecific(gKey)); } else { __android_log_print(ANDROID_LOG_ERROR, TAG, &quot;线程附加失败，code: %d.&quot;, ret); } break; case JNI_EVERSION: __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;错误 JNI_EVERSION.&quot;); break; default: __android_log_print(ANDROID_LOG_ERROR, TAG, &quot;未知错误：%d&quot;, ret); break; } return nullptr;}// 线程销毁函数static void threadDestroy(void *arg) { JNIEnv *env = nullptr; jint ret = gJavaVM-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6); if (ret == JNI_OK) { __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;线程分离.&quot;); gJavaVM-&gt;DetachCurrentThread(); }}void testThread(JNIEnv *env, jclass clazz) { // 获取 JavaVM 指针 env-&gt;GetJavaVM(&amp;gJavaVM); // 创建线程本地存储，指定线程析构函数 pthread_key_create(&amp;gKey, &amp;threadDestroy); // 创建线程 pthread_t tid; int ret = pthread_create(&amp;tid, nullptr, &amp;threadTest, nullptr); if (ret != 0) { __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;thread [%ld] create err&quot;, tid); return; } // 等待线程结束 pthread_join(tid, nullptr); // 移除线程本地存储 pthread_key_delete(gKey);} 上述代码，首先保存 JavaVM，然后启动线程，在线程中使用 GetEnv 函数尝试从线程获得 JNIEnv，返回值将有 3 种结果： JNI_OK，说明此线程已附加，可直接使用获得的 JNIEnv； JNI_EDETACHED，说明此线程未附加，那么需要使用 AttachCurrentThread 进行附加； JNI_EVERSION，说明不支持指定的版本。 在获得 JNIEnv 之后线程就执行完毕了，那么 pthread_create 中指定的线程析构函数 threadDestroy 将被回调，在这里确认线程已被附加后，使用 DetachCurrentThread 分离线程。 AttachCurrentThread 的第 2 个参数一般可以指定为空，它是一个 JavaVMAttachArgs 结构指针，用于指定格外信息。 1234567// jni.hstruct JavaVMAttachArgs { jint version; /* must be &gt;= JNI_VERSION_1_2 */ const char* name; /* NULL or name of thread as modified UTF-8 str */ jobject group; /* global ref of a ThreadGroup object, or NULL */}; JNI 异常当原生代码出现异常挂起时，大多数 JNI 函数无法被调用。通过 C/C++ 代码可以检查到是否出现了异常（通过 ExceptionCheck 或者 ExceptionOccurred 的返回值）；或者直接清除异常。 在异常挂起时，只能调用如下 JNI 函数： 123456789101112131415DeleteGlobalRefDeleteLocalRefDeleteWeakGlobalRefExceptionCheckExceptionClearExceptionDescribeExceptionOccurredMonitorExitPopLocalFramePushLocalFrameRelease&lt;PrimitiveType&gt;ArrayElementsReleasePrimitiveArrayCriticalReleaseStringCharsReleaseStringCriticalReleaseStringUTFChars 许多 JNI 调用都会抛出异常，但通常可以使用一种更简单的方法来检查失败调用，例如 NewString 函数返回非空，则表示不需要检查异常。如果使用 CallObjectMethod 函数，则始终必须检查异常，如果系统抛出异常，那么函数返回值无效。 检查异常使用 ExceptionCheck 函数可检查上一次代码调用是否出现了异常，如果出现异常，ExceptionCheck 将返回 JNI_TRUE，否则为 JNI_FALSE；或使用 ExceptionOccurred 函数，如果出现异常，它会返回一个 jthrowable 对象，否则为空。 通常使用 ExceptionCheck 函数，因为它不需要创建局部引用（jthrowable）。 在捕获到异常之后，使用 ExceptionDescribe 打印异常信息，如果调用 ExceptionClear 清除异常，那么异常将被忽略（不过在未处理的情况下盲目地忽略异常可能会出现问题）。 12345678910// 检查异常bool checkException(JNIEnv *env) { if (env-&gt;ExceptionCheck() == JNI_TRUE) { env-&gt;ExceptionDescribe(); env-&gt;ExceptionClear(); return true; } return false;} 抛出异常目前 Android 并不支持 C++ 异常。 JNI 提供了 Throw 和 ThrowNew 用来抛出 Java 异常，但不会在调用后就抛出异常，只是在当前线程中设置了异常指针。从本地代码返回到受虚拟机管理的代码后，会观察到这些异常指针并进行相应处理（抛出异常）。 JNI 没有提供直接操作 Java Throwable 对象本身的内置函数（直接创建对象或者获取异常信息）。 如果想要抛出指定异常，则需要自己找到 Throwable 类后，调用 ThrowNew 函数产生异常： 1234// 抛出 NullPointerExceptionenv-&gt;ThrowNew(env-&gt;FindClass(&quot;java/lang/NullPointerException&quot;), msg);// 抛出 RuntimeExceptionenv-&gt;ThrowNew(env-&gt;FindClass(env, &quot;java/lang/RuntimeException&quot;), msg); 如果需要获取异常信息，那么需要查找 Throwable#getMessage() 的方法 ID 并调用。 参考 https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html https://developer.android.google.cn/training/articles/perf-jni","link":"/2020/07/14/android-jni-%E6%8C%87%E5%8D%97/"},{"title":"Android Dex 文件解析","text":"前言Java 代码文件在经过 javac 编译器编译后会产出 .class 格式的 Java 虚拟机可执行的字节码文件，而 Dex 文件则是 Android SDK 编译 Java 代码后的产物（Android SDK 使用 dx 或 d8 编译器将 .class 文件编译为 .dex 文件），了解 Dex 文件结构是理解 Android 虚拟机原理的基础，同时也是学习 Android 逆向工程的基础。 Dex 文件的文件后缀为 .dex，是 Android 虚拟机的可执行文件。 基本数据类型首先说明组成 Dex 文件结构中的基本类型，包含原生类型和 uleb128 类型： 名称 说明 byte 8 位有符号整数 ubyte 8 位无符号整数 short 16 位有符号整数，小端字节序 ushort 16 位无符号整数，小端字节序 int 32 位有符号整数，小端字节序 uint 32 位无符号整数，小端字节序 long 64 位有符号整数，小端字节序 ulong 64 位无符号整数，小端字节序 sleb128 有符号 LEB128，可变长度 uleb128 无符号 LEB128，可变长度 uleb128p1 无符号 LEB128 + 1，可变长度 在系统源码 DexFile.h 的对应类型别名定义如下： 12345678910// DexFile.htypedef uint8_t u1;typedef uint16_t u2;typedef uint32_t u4;typedef uint64_t u8;typedef int8_t s1;typedef int16_t s2;typedef int32_t s4;typedef int64_t s8; LEB128 类型LEB128 类型是 Dex 文件中的基础类型之一，该类型格式借鉴了 DWARF3 规范。在 Dex 文件中，LEB128 仅用于对 32 位数字进行编码。 LEB128 全称为“Little-Endian Base 128“，表示任意有符号或无符号整数的可变长度编码。 每个 LEB128 编码值由 1-5 个字节组成，共同表示一个 32 位的值，设计 LEB128 的目的是为了节省内存。 表示方法是：每个字节的首位为标志位，为 0 说明这个字节是 LEB128 类型的最后一个字节，为 1 则表示后面还有若干字节，然后将每个字节去除标志位后的 7 位组合成一个 32 数字。 uleb128对于无符号的 uleb128 类型，使用两个字节表示十进制数字 4176 的示例如下： 11 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 去除标志位后： 123 1 0 1 0 0 0 0 0 1 0 0 0 0 0^ ^去除 去除 组合后使用便于阅读的大端格式表示为： 1230 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0^ ^补充 0 1000001010000 转化为十进制的值为 4176。 leb128对于有符号的 leb128 类型，最后一个字节的除了标志位的最高位将为符号位，将进行符号扩展。 例如下面使用两个字节的 leb128 表示有符号数： 1231 1 0 1 0 0 0 0 0 1 1 0 0 0 0 0 ^ 将进行符号扩展 去除标志位后： 123 1 0 1 0 0 0 0 1 1 0 0 0 0 0^ ^去除 去除 组合后使用便于阅读的大端格式表示为： 1230 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0^ ^补充 0 由于符号位为 1，说明表示负数，则使用补码计算： 1234567首先求反码：0 0 0 0 1 1 1 1 1 0 1 0 1 1 1 1然后 +1 -&gt;0 0 0 0 1 1 1 1 1 0 1 1 0 0 0 0 111110110000 的十进制结果为 4016，添加负号为 -4016。 uleb128p1uleb128p1 用于表示一个有符号值，它的编码方法为 uleb128 的值加 1，那么解码时首先以 uleb128 格式解析值，然后减去 1，主要是为了表示 -1 这个常用数而节省空间，原本使用 sleb128 需要 2 个字节才能表示 -1（11111111 01111111），现在一个字节就可以表示了（00000000）。 LEB128 类型的一些典型值： Binary Hex sleb128 uleb128 uleb128p1 00000000 00000000 00 0 0 -1 00000000 00000001 01 1 1 0 00000000 01111111 7f -1 127 126 10000000 01111111 80 7f -128 16256 16255 Dex 文件结构图Dex 文件的总体结构图： Dex 结构说明下面对于 Dex 的详细结构进行说明（下面的参考了 Android 9.0.0_r3 系统源码中的 dalvik/libdex/DexFile.h 头文件）。 hedaer_item首先 Dex 文件的头部具有一个 hedaer_item 结构，它存放了整个 Dex 文件的元信息，描述了一个 Dex 文件的概要结构。 下面是它的结构定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct hedaer_item { /* 魔数 */ u1 magic[8]; /* 文件剩余内容（除 magic 和此字段之外的所有内容)的 adler32 校验和； 用于检测文件损坏情况。 */ u4 checksum; /* 文件剩余内容（除 magic、checksum 和此字段之外的所有内容)的 SHA-1 签名（哈希)； 用于对文件进行唯一标识。 */ u1 signature[20]; /* 整个文件（包括标头)的大小，以字节为单位 */ u4 file_size; /* 标头（整个区段)的大小，以字节为单位。这一项允许至少一定程度的向后/向前兼容性， 而不必让格式失效。 */ u4 header_size; /* 字节序标记 */ u4 endian_tag; /* 链接区段的大小；如果此文件未进行静态链接，则该值为 0 */ u4 link_size; /* 从文件开头到链接区段的偏移量；如果 link_size == 0，则该值为 0。 该偏移量（如果为非零值)应该是到 link_data 区段的偏移量。 */ u4 link_off; /* 从文件开头到映射项的偏移量。该偏移量（必须为非零)应该是到 data 区段的偏移量 */ u4 map_off; /* 字符串标识符列表中的字符串数量 */ u4 string_ids_size; /* 从文件开头到字符串标识符列表的偏移量；如果 string_ids_size == 0（极端情况)， 则该值为 0。该偏移量（如果为非零值)应该是到 string_ids 区段开头的偏移量。 */ u4 string_ids_off; /* 类型标识符列表中的元素数量，最多为 65535 */ u4 type_ids_size; /* 从文件开头到类型标识符列表的偏移量；如果 type_ids_size == 0（极端情况)， 则该值为 0。该偏移量（如果为非零值)应该是到 type_ids 区段开头的偏移量。 */ u4 type_ids_off; /* 原型标识符列表中的元素数量，最多为 65535 */ u4 proto_ids_size; /* 从文件开头到原型标识符列表的偏移量；如果 proto_ids_size == 0（极端情况)， 则该值为 0。该偏移量（如果为非零值)应该是到 proto_ids 区段开头的偏移量。 */ u4 proto_ids_off; /* 字段标识符列表中的元素数量 */ u4 field_ids_size; /* 从文件开头到字段标识符列表的偏移量；如果 field_ids_size == 0，则该值为 0。 该偏移量（如果为非零值)应该是到 field_ids 区段开头的偏移量。 */ u4 field_ids_off; /* 方法标识符列表中的元素数量 */ u4 method_ids_size; /* 从文件开头到方法标识符列表的偏移量；如果 method_ids_size == 0，则该值为 0。 该偏移量（如果为非零值)应该是到 method_ids 区段开头的偏移量 */ u4 method_ids_off; /* 类定义列表中的元素数量 */ u4 class_defs_size; /* 从文件开头到类定义列表的偏移量；如果 class_defs_size == 0（极端情况)， 则该值为 0。该偏移量（如果为非零值)应该是到 class_defs 区段开头的偏移量。 */ u4 class_defs_off; /* data 区段的大小（以字节为单位)。该数值必须是 sizeof(uint) 的偶数倍 */ u4 data_size; /* 从文件开头到 data 区段开头的偏移量 */ u4 data_off;}; 和所有文件格式标准一样（使用魔数标识文件类型），Dex 文件的前 8 个字节 magic 字段是魔数，表示 Dex 这种文件类型，它的值是 dex 字符串和文件格式版本号的组合，例如 dex\\n039\\0，其中版本号用于为系统识别解析不同版本格式的 Dex 文件提供支持，不同版本的 Dex 文件可能具有结构差异，新版本可能支持更多指令。039 版本的格式在 Android 9.0 中被增加。 从前面的结构图中可以知道，Dex 文件大致分为 3 块区域，文件头、索引区域以及数据区域。其中索引区域用于描述 Dex 几个关键子结构的分布，包含指向子结构的地址偏移的列表，数据区用于存放具体的信息，是索引区域所指向的目标区域，包含每个类的详细信息以及类成员和类方法的信息，以及每个方法的完整字节码指令等。 如果要对一个 Dex 文件进行解析，那么可以按照从上至下的方式，由文件概要信息自然的解析到具体数据结构。 索引区内容，包含 string_ids、type_ids、proto_ids、field_ids、method_ids、class_defs、call_site_ids 一共 7 个 Dex 核心结构，上面 header_item 结构的已经包含了每个结构的相关信息，每个结构都是一个数组，在 header_item 的描述中都具有一个 size 属性表示数组成员数量，和一个 off 表示在文件中的偏移值。 下面介绍索引区结构的详细结构。 string_idsstring_ids 是字符串池，保存 Dex 文件中所用到的所有字符串，其他结构中如果包含字符串类型的变量，将会提供对应字符串在字符串池中的索引。 string_ids 是数组结构，每个数组成员为一个 string_id_item，它存放了每个字符串在 data 结构中的偏移地址。 1234567struct string_id_item { /* 从文件开头到此项的字符串数据的偏移量。该偏移量应该是到 data 区段中某个位置的 偏移量。 */ u4 string_data_off;}; string_id_item 的偏移指向一个表示字符串的结构，为 string_data_item，它包含字符串的长度和具体内容，长度使用 uleb128 类型存储： 123456789101112struct string_data_item{ /* 此字符串的大小；以 UTF-16 代码单元（在许多系统中为“字符串长度”）为单位。 也就是说，这是该字符串的解码长度（编码长度隐含在 0 字节的位置）。 */ uleb128 utf16_size; /* 一系列 MUTF-8 代码单元（又称八位字节），后跟一个值为 0 的字节。 */ u1* data;} type_idstype_ids 是类型标识符信息，包含了代码中使用到的所有 Java 类型以及原始类型。 type_ids 是数组结构，每个数组成员为一个 type_id_item 结构，它存放了类型所对应名字的字符串的在字符串池中的索引。 12345678struct type_id_item{ /* 此类描述符字符串的 string_ids 列表中的索引。该字符串必须符合上文定义的 TypeDescriptor 的语法。 */ u4 descriptor_idx;}; proto_idsproto_ids 是方法原型标识符信息，存放方法返回值和参数的类型标识符信息。 proto_ids 是数组结构，每个数组成员为一个 proto_id_item，它存放了方法返回类型标识符字符串在字符串池中的索引，以及参数、返回类型在 type_ids 中的索引。 12345678910111213141516struct proto_id_item{ /* 此原型的简短式描述符字符串的 string_ids 列表中的索引。该字符串必须符合上文定义 的 ShortyDescriptor 的语法，而且必须与该项的返回类型和参数相对应。 */ u4 shorty_ids; /* 此原型的返回类型的 type_ids 列表中的索引 */ u4 return_type_idx; /* 从文件开头到此原型的参数类型列表的偏移量；如果此原型没有参数，则该值为 0。 该偏移量（如果为非零值）应该位于 data 区段中，且其中的数据应采用下文中 “&quot;type_list&quot;”指定的格式。此外，不得对列表中的类型 void 进行任何引用。 */ u4 parameters_off;}; field_idsfield_ids 是类成员变量标识符信息，存放所有类成员类型标识符信息。 field_ids 是数组结构，每个数组成员为一个 field_id_item，它存放了成员变量所属类型的信息，和成员变量本身的类型信息： 123456789101112131415struct field_id_item{ /* 此字段的定义符的 type_ids 列表中的索引。此项必须是“类”类型，而不能是“数组”或 “基元”类型。 */ u2 class_idx; /* 此字段的类型的 type_ids 列表中的索引 */ u2 type_idx; /* 此字段的名称的 string_ids 列表中的索引。该字符串必须符合上文定义的 MemberName 的语法。 */ u4 name_idx;}; method_idsmethod_ids 是类方法标识符信息，存放所有类方法的类型标识符信息。 method_ids 是数组结构，每个数组成员为一个 method_id_item，它存放了方法所属类型的信息，和方法本身的类型信息： 123456789101112131415struct method_id_item{ /* 此方法的定义符的 type_ids 列表中的索引。此项必须是“类”或“数组”类型，而不能是 “基元”类型。 */ u2 class_idx; /* 此方法的原型的 proto_ids 列表中的索引 */ u2 proto_idx; /* 此方法名称的 string_ids 列表中的索引。该字符串必须符合上文定义的 MemberName 的语法。 */ u4 name_idx;}; class_defsclass_defs 是类定义信息，存放了所有类的定义信息。 class_defs 是数组结构，每个数组成员为一个 class_def_item，包含这个类定义所需要的全部信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct class_def_item{ /* 此类的 type_ids 列表中的索引。此项必须是“类”类型，而不能是“数组”或“基元”类型。 */ u4 class_idx; /* 类的访问标记（public、final 等）。有关详情，请参阅“access_flags 定义”。 */ u4 access_flag; /* 超类的 type_ids 列表中的索引。如果此类没有超类（即它是根类，例如 Object）， 则该值为常量值 NO_INDEX。如果此类存在超类，则此项必须是“类”类型，而不能是 “数组”或“基元”类型。 */ u4 superclass_idx; /* 从文件开头到接口列表的偏移量；如果没有接口，则该值为 0。该偏移量应该位于 data 区段，且其中的数据应采用下文中“type_list”指定的格式。该列表的每个元素都必须是 “类”类型（而不能是“数组”或“基元”类型），并且不得包含任何重复项。 */ u4 interfaces_off; /* 文件（包含这个类（至少大部分）的原始来源）名称的 string_ids 列表中的索引； 或者该值为特殊值 NO_INDEX，以表示缺少这种信息。任何指定方法的 debug_info_item 都可以覆盖此源文件，但预期情况是大多数类只能来自一个源文件。 */ u4 source_file_idx; /* 从文件开头到此类的注释结构的偏移量；如果此类没有注释，则该值为 0。该偏移量 （如果为非零值）应该位于 data 区段，且其中的数据应采用下文中 “annotations_directory_item”指定的格式，同时所有项将此类作为定义符进行引用。 */ u4 annotations_off; /* 从文件开头到此项的关联类数据的偏移量；如果此类没有类数据，则该值为 0（这种情况 有可能出现，例如，如果此类是标记接口）。该偏移量（如果为非零值）应该位于 data 区段，且其中的数据应采用下文中“class_data_item”指定的格式，同时所有项将此类作 为定义符进行引用。 */ u4 class_data_off; /* 从文件开头到 static 字段的初始值列表的偏移量；如果没有该列表（并且所有 static 字段都将使用 0 或 null 进行初始化），则该值为 0。该偏移量应该位于 data 区段， 且其中的数据应采用下文中“encoded_array_item”指定的格式。该数组的大小不得超出 此类所声明的 static 字段的数量，且 static 字段所对应的元素应采用相对应的 field_list 中所声明的顺序每个数组元素的类型均必须与其相应字段的声明类型相匹配。 如果该数组中的元素比 static 字段中的少，则剩余字段将使用适当类型 0 或 null 进行初始化。 */ u4 static_values_off;}; 其中 access_flags 为访问标识符，可选值如下： 1234567891011121314151617181920212223242526272829303132333435enum { ACC_PUBLIC = 0x00000001, // class, field, method, ic ACC_PRIVATE = 0x00000002, // field, method, ic ACC_PROTECTED = 0x00000004, // field, method, ic ACC_STATIC = 0x00000008, // field, method, ic ACC_FINAL = 0x00000010, // class, field, method, ic ACC_SYNCHRONIZED= 0x00000020, // method (only allowed on natives) ACC_SUPER = 0x00000020, // class (not used in Dalvik) ACC_VOLATILE = 0x00000040, // field ACC_BRIDGE = 0x00000040, // method (1.5) ACC_TRANSIENT = 0x00000080, // field ACC_VARARGS = 0x00000080, // method (1.5) ACC_NATIVE = 0x00000100, // method ACC_INTERFACE = 0x00000200, // class, ic ACC_ABSTRACT = 0x00000400, // class, method, ic ACC_STRICT = 0x00000800, // method ACC_SYNTHETIC = 0x00001000, // field, method, ic ACC_ANNOTATION = 0x00002000, // class, ic (1.5) ACC_ENUM = 0x00004000, // class, field, ic (1.5) ACC_CONSTRUCTOR = 0x00010000, // method (Dalvik only) ACC_DECLARED_SYNCHRONIZED = 0x00020000, // method (Dalvik only) ACC_CLASS_MASK = (ACC_PUBLIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT | ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM), ACC_INNER_CLASS_MASK = (ACC_CLASS_MASK | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC), ACC_FIELD_MASK = (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC | ACC_FINAL | ACC_VOLATILE | ACC_TRANSIENT | ACC_SYNTHETIC | ACC_ENUM), ACC_METHOD_MASK = (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED | ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE | ACC_ABSTRACT | ACC_STRICT | ACC_SYNTHETIC | ACC_CONSTRUCTOR | ACC_DECLARED_SYNCHRONIZED),}; call_site_idscall_site_ids 存放的是调用站点标识符信息，它是和 Java 中的提供的 MethodHandler 相关的信息。 call_site_ids 是数组结构，每个数组成员为一个 call_site_id_item。 12345678struct call_site_id_item{ /* 从文件开头到调用点定义的偏移量。该偏移量应位于数据区段中，且其中的数据应采用下 文中“call_site_item”指定的格式。 */ u4 call_site_off;}; call_site_item 是一个 encoded_array_item 结构，具体内容，可参考官方介绍，这里不对它进行重点关注。 到这里就介绍完了索引区的基本内容。 然后现在回到 header_item 中，看第 9 个 map_off 字段，它指向一个 map_list 结构，map_list 存放了 Dex 文件所有的结构描述，同时也包含 header_item 区域和索引区结构，下面看一下它的具体内容。 map_listmap_list 结构定义如下： 12345struct map_list{ u4 size; // 列表的大小（以条目数表示）。 map_item* list; // 列表的元素。}; 有大小和数组成员，在解析时首先读取数组元素的大小，再根据大小解析指定数量的 map_item 数组成员结构。 map_item 结构定义如下： 1234567struct map_item{ u2 type; // 项的类型。 u2 unused; // 未使用。 u4 size; // 在指定偏移量处找到的项数量。 u4 offset; // 从文件开头到相关项的偏移量。}; 根据 type 的值来可确认其说明的对应结构： 1234567891011121314151617181920212223enum{ TYPE_HEADER_ITEM = 0x0000, // header_item TYPE_STRING_ID_ITEM = 0x0001, // string_id_item TYPE_TYPE_ID_ITEM = 0x0002, // type_id_item TYPE_PROTO_ID_ITEM = 0x0003, // proto_id_item TYPE_FIELD_ID_ITEM = 0x0004, // field_id_item TYPE_METHOD_ID_ITEM = 0x0005, // method_id_item TYPE_CLASS_DEF_ITEM = 0x0006, // class_def_item TYPE_CALL_SITE_ID_ITEM = 0x0007, // call_site_id_item TYPE_METHOD_HANDLE_ITEM = 0x0008, // method_handle_item TYPE_MAP_LIST = 0x1000, // map_list TYPE_TYPE_LIST = 0x1001, // type_list TYPE_ANNOTATION_SET_REF_LIST = 0x1002, // annotation_set_ref_list TYPE_ANNOTATION_SET_ITEM = 0x1003, // annotation_set_item TYPE_CLASS_DATA_ITEM = 0x2000, // class_data_item TYPE_CODE_ITEM = 0x2001, // code_item TYPE_STRING_DATA_ITEM = 0x2002, // string_data_item TYPE_DEBUG_INFO_ITEM = 0x2003, // debug_info_item TYPE_ANNOTATION_ITEM = 0x2004, // annotation_item TYPE_ENCODED_ARRAY_ITEM = 0x2005, // encoded_array_item TYPE_ANNOTATIONS_DIRECTORY_ITEM = 0x2006, // annotations_directory_item}; 通过遍历 map_list 即可得到每个结构的偏移地址和结构中项的数量，从而对整个 Dex 文件进行解析。 下面看一下除了索引区结构的其他结构。 type_listtype_list 是类型列表，结构如下： 12345struct type_list{ u4 size; // 列表的大小（以条目数表示） type_item *list; // 列表的元素。}; 每个列表成员为 type_item，包含 type_ids 数组的索引： 1234struct type_item{ u2 type_idx; // type_ids 列表中的索引。}; class_data_itemclass_data_item 表示类的信息，包含类成员和类方法的信息。 1234567891011121314151617181920212223242526struct class_data_item{ uleb128 static_fields_size; // 此项中定义的静态字段的数量。 uleb128 instance_fields_size; // 此项中定义的实例字段的数量。 uleb128 direct_methods_size; // 此项中定义的直接方法的数量。 uleb128 virtual_methods_size; // 此项中定义的虚拟方法的数量。 /* 定义的静态字段；以一系列编码元素的形式表示。这些字段必须按 field_idx 以升序进行排序。 */ encoded_field* static_fields; /* 定义的实例字段；以一系列编码元素的形式表示。这些字段必须按 field_idx 以升序进行排序。 */ encoded_field* instance_fields; /* 定义的直接（static、private 或构造函数的任何一个）方法；以一系列编码元素的形式 表示。这些方法必须按 method_idx 以升序进行排序。 */ encoded_method* direct_methods; /* 定义的虚拟（非 static、private 或构造函数）方法；以一系列编码元素的形式表示。 此列表不得包括继承方法，除非被此项所表示的类覆盖。这些方法必须按 method_idx 以 升序进行排序。虚拟方法的 method_idx 不得与任何直接方法相同。 */ encoded_method* virtual_methods;}; 描述类成员和类方法的子结构： 123456789101112struct encoded_field{ /* 此字段标识（包括名称和描述符）的 field_ids 列表中的索引； 它会表示为与列表中前一个元素的索引之间的差值。列表中第一个元素的索引则直接表示出来。 */ uleb128 field_idx_diff; /* 字段的访问标记（public、final 等）。 */ uleb128 access_flags;}; 1234567891011121314151617struct encoded_method{ /* 此方法标识（包括名称和描述符）的 method_ids 列表中的索引； 它会表示为与列表中前一个元素的索引之间的差值。列表中第一个元素的索引则直接表示出来。 */ uleb128 method_idx_diff; /* 方法的访问标记（public、final 等）。 */ uleb128 access_flags; /* 从文件开头到此方法代码结构的偏移量；如果此方法是 abstract 或 native，则该值为 0。 该偏移量应该是到 data 区段中某个位置的偏移量。数据格式由下文的“code_item”指定。 */ uleb128 code_off;}; code_itemcode_item 是字节码信息，包含每个 Java 代码块的代码，和寄存器数量等相关信息。 12345678910111213141516171819202122232425262728293031323334353637383940struct code_item{ u2 registers_size; // 此代码使用的寄存器数量。 u2 ins_size; // 此代码所用方法的传入参数的字数。 u2 outs_size; // 此代码进行方法调用所需的传出参数空间的字数。 /* 此实例的 try_item 数量。如果此值为非零值，则这些项会显示为 tries 数组 （正好位于此实例中 insns 的后面）。 */ u2 tries_size; /* 从文件开头到此代码的调试信息（行号 + 局部变量信息）序列的偏移量；如果没有任 何信息，则该值为 0。该偏移量（如果为非零值）应该是到 data 区段中某个位置的偏移量。数据格式由下文的“debug_info_item”指定。 */ u4 debug_info_off; u4 insns_size; // 指令列表的大小（以 16 位代码单元为单位）。 /* 字节码的实际数组。insns 数组中代码的格式由随附文档 Dalvik 字节码指定。请注意， 尽管此项被定义为 ushort 的数组，但仍有一些内部结构倾向于采用四字节对齐方式。 此外，如果此项恰好位于某个字节序交换文件中，则交换操作将只在单个 ushort 上进 行，而不是在较大的内部结构上进行。 */ u2* insns; /* （可选）使 tries 实现四字节对齐的两字节填充。只有 tries_size 为非零值且 insns_size 是奇数时，此元素才会存在。 */ u2 padding; /* （可选）用于表示在代码中捕获异常的位置以及如何对异常进行处理的数组。该数组的元 素在范围内不得重叠，且数值地址按照从低到高的顺序排列。只有 tries_size 为非零 值时，此元素才会存在。 */ try_item* tries; /* （可选）用于表示“捕获类型列表和关联处理程序地址”的列表的字节。每个 try_item 都具有到此结构的分组偏移量。只有 tries_size 为非零值时，此元素才会存在。 */ encoded_catch_handler_list handlers;}; string_data_item 前面已经说过了，表示 Dex 文件中用到的每一个字符串。 debug_info_itemdebug_info_item 存放代码调试信息。 1234567891011121314151617struct debug_info_item{ /* 状态机的 line 寄存器的初始值。不表示实际的位置条目。 */ uleb128 line_start; /* 已编码的参数名称的数量。每个方法参数都应该有一个名称，但不包括实例方法的 this （如果有）。 */ uleb128 parameters_size; /* 方法参数名称的字符串索引。NO_INDEX 的编码值表示该关联参数没有可用的名称。 该类型描述符和签名隐含在方法描述符和签名中。 */ uleb128p1 parameter_names;}; 其他几个 annotation_set_ref_list、annotation_set_item、annotation_item、annotations_directory_item 是存放代码注释相关信息的结构，这里不再列出了。 到这里整个 Dex 文件的结构也就介绍的差不多了，但是只看这些文字说明，并不能真正了解一个 Dex 文件中的内容，下面通过解析一个真实的 Dex 文件，来了解 Dex 文件的具体内容。 Dex 文件解析为了解析 Dex 文件，首先需要有一个 Dex 文件，下面来手动构建一个 Dex 文件。 构建 Dex 文件Dex 文件由 dx 或 d8 编译器编译 .class 文件生成，这里首先编写一个简单的 Java 类，包含成员变量和方法： 123456789101112131415// io/l0neman/example/Hello.javapackage io.l0neman.example; public class Hello { private static int sField = 1; private String mField = &quot;field&quot;; private void test() { System.out.println(mField); } public static void main(String[] args) { System.out.println(&quot;Hello Dex.&quot;); }} 编译为 Hello.class 文件： 1javac io/l0neman/example/Hello.java 然后使用 dx 命令将 Hello.class 编译为 Hello.dex 文件： 1dx --dex --output=Hello.dex io/l0neman/example/Hello.class 或使用 d8 命令将 Hello.class 编译为 Hello.jar 文件，Hello.jar 是一个压缩包，里面包含一个 classes.dex 文件： 1d8 --output Hello-d8.jar io/l0neman/example/Hello.class 使用 dx 或者 d8 编译出来的 dex 文件的执行结果是一样的（打印出 Hello Dex.）。 执行 Dex 文件Dex 文件是 Android 虚拟机的可执行文件，所以在 Android 设备上可以直接执行 Dex 文件。 首先将 Dex 文件推送到 Android 设备： 1adb push Hello.dex /sdcard/ 然后使用如下两种方式之一进行执行： 使用 dalvikvm 命令 1dalvikvm -cp Hello.dex io.l0neman.example.Hello 使用 app_process 命令 1app_process -Djava.class.path=Hello.dex /data/local/temp io.l0neman.example.Hello 解析 Dex 文件下面开始解析 Dex 文件。 对于解析一个文件结构来说，使用 C/C++ 语言要比 Java 语言更容易实现，因为 C/C++ 语言的 read 函数可直接传入一个结构体指针，文件中对应的字节将会被字节映射到结构体中，而 Java 只能逐个字节的解析，除非进行封装。 如果想要类似于 C/C++ 方法的 read 函数体验，可以用我之前封装的一个工具类：ObjectInput，可以直接自动将文件指定字节，解析到类的每个类型的成员上。 这里采用 C++ 语言对 Dex 文件进行解析。 首先将上面每个结构体放在新建的 DexFile.h 中，为了解析时可以直接用到它们（相关结构体可直接从 Android 系统源码中提取，路径是 dalvik/libdex/DexFile.h）。 解析核心方法主要是利用 fread 和 fseek 函数读取文件和控制文件读取偏移，遇到具体结构再根据具体内容进行解析，例如遇到 uleb128 作为数组大小，那就先解析这个 uleb128 的值，再根据它的值再解析每个数组成员。 开始解析下面开始解析 Dex 文件，首先需要读取 Hello.dex 文件，这里使用面向对象的方式，首先定义一个解析类 DexFileParser，通过它的构造函数传入 Dex 文件路径。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// DexParser.h#ifndef DEX_PARSER_H#define DEX_PARSER_H#include &lt;iostream&gt;#include &quot;type/DexFile.h&quot;class DexParser{public: DexParser(char const* dex_file_path); ~DexParser(); void parse();private: // 解析各个结构的方法 void parse_header_item(); void parse_map_list(); void parse_string_list(const u4 size, const u4 offset); void parse_type_ids(const u4 size, const u4 offset); void parse_proto_ids(const u4 size, const u4 offset); void parse_field_ids(const u4 size, const u4 offset) const; void parse_method_ids(const u4 size, const u4 offset) const; void parse_class_defs(const u4 size, const u4 offset) const; void parse_encoded_field(const u4 offset, encoded_field* p) const; void parse_encoded_method(const u4 offset, encoded_method* p) const; void parse_class_data_list(const u4 size, const u4 offset) const; void parse_code_list(const u4 size, const u4 offset) const; void call_site_ids(); void method_handles(); const char* get_string_from_string_list(const u4 index) const; const char* get_type_description(const u4 index) const; proto_id_item get_proto_item(const u4 index) const; // Dex 文件的指针 FILE* dex_file_; // 文件头。 header_item dex_header_; // 类型映射表。 map_list map_list_; // 字符串偏移信息。 string_id_item* string_ids_; // 字符串数量。 u4 string_list_size_; // 字符串列表。 string_data_item* string_list_; // 类型列表。 type_id_item* type_list_; // 原型列表。 proto_id_item* proto_list_;};#endif // !DEX_PARSER_H main 函数调用代码如下： 123456789101112// DexFileParser.cpp#include &lt;iostream&gt;#include &quot;DexParser.h&quot;int main(){ DexParser dex_parser(R&quot;(.\\Hello.dex)&quot;); // 开始解析 dex_parser.parse(); return 0;} 打开 Dex 文件下面看构造函数如何打开文件： 12345678910111213141516171819202122// DexParser.cppDexParser::DexParser(char const* dex_file_path){ // 相关指针初始化 this-&gt;dex_file_ = nullptr; this-&gt;dex_header_ = header_item(); this-&gt;map_list_ = map_list(); this-&gt;string_ids_ = nullptr; this-&gt;string_list_size_ = 0; this-&gt;string_list_ = nullptr; this-&gt;type_list_ = nullptr; this-&gt;proto_list_ = nullptr; printf(&quot;dex file: %s\\n\\n&quot;, dex_file_path); // 打开 dex 文件，并将文件指针赋予给 this-&gt;dex_file_ 保存起来 const auto s = fopen_s(&amp;this-&gt;dex_file_, dex_file_path, &quot;rb&quot;); if (s != 0 || this-&gt;dex_file_ == nullptr) { printf(&quot;open dex file error: %s\\n&quot;, dex_file_path); }} 读取后就可以开始使用 fread 函数解析结构体了。 header_item首先解析 Dex 文件头，header_item 结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// DexParser.cppvoid DexParser::parse(){ printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse header_item &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); parse_header_item(); // ...}void DexParser::parse_header_item(){ // 解析数据到 header_item 结构体 if (0 == fread(&amp;this-&gt;dex_header_, sizeof(header_item), 1, this-&gt;dex_file_)) { printf(&quot;parse dex header error.\\n&quot;); } // 打印 header_item print_dex_header(&amp;this-&gt;dex_header_);}inline void print_dex_header(header_item* dex_header) { printf(&quot;magic: &quot;); Printer::print_hex_array(dex_header-&gt;magic, 8); printf(&quot;checksum: %6x\\n&quot;, dex_header-&gt;checksum); printf(&quot;signature: &quot;); Printer::print_hex_array(dex_header-&gt;signature, 20); printf(&quot;file_size: %d\\n&quot;, dex_header-&gt;file_size); printf(&quot;header_size: %d\\n&quot;, dex_header-&gt;header_size); printf(&quot;endian_tag: %d\\n&quot;, dex_header-&gt;endian_tag); printf(&quot;link_size: %d\\n&quot;, dex_header-&gt;link_size); printf(&quot;link_off: %d\\n&quot;, dex_header-&gt;link_off); printf(&quot;map_off: %d\\n&quot;, dex_header-&gt;map_off); printf(&quot;string_ids_size: %d\\n&quot;, dex_header-&gt;string_ids_size); printf(&quot;string_ids_off: %d\\n&quot;, dex_header-&gt;string_ids_off); printf(&quot;type_ids_size: %d\\n&quot;, dex_header-&gt;type_ids_size); printf(&quot;type_ids_off: %d\\n&quot;, dex_header-&gt;type_ids_off); printf(&quot;proto_ids_size: %d\\n&quot;, dex_header-&gt;proto_ids_size); printf(&quot;proto_ids_off: %d\\n&quot;, dex_header-&gt;proto_ids_off); printf(&quot;field_ids_size: %d\\n&quot;, dex_header-&gt;field_ids_size); printf(&quot;field_ids_off: %d\\n&quot;, dex_header-&gt;field_ids_off); printf(&quot;method_ids_size: %d\\n&quot;, dex_header-&gt;method_ids_size); printf(&quot;method_ids_off: %d\\n&quot;, dex_header-&gt;method_ids_off); printf(&quot;class_defs_size: %d\\n&quot;, dex_header-&gt;class_defs_size); printf(&quot;class_defs_off: %d\\n&quot;, dex_header-&gt;class_defs_off); printf(&quot;data_size: %d\\n&quot;, dex_header-&gt;data_size); printf(&quot;data_off: %d\\n&quot;, dex_header-&gt;data_off);} 可以看到，解析非常简单，一行代码就搞定了。 上面的 print_hex_array 函数是把整型数组作为 16 进制打印出来，更适合阅读： 123456789void Printer::print_hex_array(uint8_t const* array, const unsigned int size){ for (unsigned int i = 0; i &lt; size; i++) { printf(&quot;%.2x &quot;, array[i]); } printf(&quot;\\n&quot;);} 对于 Hello.dex 的 header_item 解析结果如下： 12345678910111213141516171819202122232425&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse header_item &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;magic: 64 65 78 0a 30 33 35 00checksum: 99137d68signature: 68 bf 36 a6 0d f7 51 a8 7e 79 c8 09 2f 15 ac fa 7b da 6a 42file_size: 944header_size: 112endian_tag: 305419896link_size: 0link_off: 0map_off: 784string_ids_size: 20string_ids_off: 112type_ids_size: 8type_ids_off: 192proto_ids_size: 3proto_ids_off: 224field_ids_size: 3field_ids_off: 260method_ids_size: 6method_ids_off: 284class_defs_size: 1class_defs_off: 332data_size: 580data_off: 364 其中 magic 的值如下（. 表示空格）： 164 65 78 0A 30 33 35 00 -&gt; dex.035. 符合前面所说的 Dex 文件的魔数，里面包含 dex 字符串，以及版本号 035； 其中的 file_size 为 Dex 文件的大小，在电脑上看这个 Dex 文件的大小属性，将和 file_size 一致。 其他的字段为文件校验值和各个结构的偏移。 下面解析其他结构，这里不用根据 header_item 里面提供的索引区标识来解析，由于 map_list 结构就包含了整个 Dex 文件的所有结构的信息，那么直接解析它就可以了解 Dex 文件其他结构的信息了，从而解析每个结构。 map_list123456789101112// DexParser.cppvoid DexParser::parse(){ printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse header_item &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); parse_header_item(); printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse map_list &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); parse_map_list(); // ...} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void DexParser::parse_map_list(){ // 从 header_item 中读取 map_off （map_list 的偏移） const auto offset = this-&gt;dex_header_.map_off; // 移动至 map list 偏移处 if (0 != fseek(dex_file_, offset, 0)) { printf(&quot;#parse_map_list - seek file error.\\n&quot;); return; } // 解析 map_list 大小 u4 t_size = 0; if (0 == fread(&amp;t_size, sizeof(int), 1, dex_file_)) { printf(&quot;#parse_map_list - read file error.\\n&quot;); return; } if (t_size == 0) { printf(&quot;#parse_map_list - map_list.size error.\\n&quot;); return; } // 创建 map_list 结构体，将 size 传入，用于初始化 map_item 数组 this-&gt;map_list_ = map_list(t_size); printf(&quot;map_list size: %u\\n&quot;, this-&gt;map_list_.size); // 移动到 map_item 区域 if (0 != _fseeki64(dex_file_, offset + sizeof(u4), 0)) { printf(&quot;#parse_map_list - seek file error.\\n&quot;); return; } // 创建 map_item 数组 this-&gt;map_list_.list = new map_item[this-&gt;map_list_.size]; const size_t size = this-&gt;map_list_.size; // 解析整个 map_item，数量为 size if (0 == fread(this-&gt;map_list_.list, sizeof(map_item), size, dex_file_)) { printf(&quot;#parse_map_list - read map_list.list error.\\n&quot;); return; } for (u4 i = 0; i &lt; this-&gt;map_list_.size; i++) // 打印 map_item 内容 print_map_item(&amp;this-&gt;map_list_.list[i]);}inline void print_map_item(map_item const* map_item){ printf(&quot;\\nmap_item:\\n&quot;); printf(&quot;type: 0x%x\\n&quot;, map_item-&gt;type); printf(&quot;type desc: %s\\n&quot;, type_string(map_item-&gt;type)); printf(&quot;size: %d\\n&quot;, map_item-&gt;size); printf(&quot;offset: %u\\n&quot;, map_item-&gt;offset);} 上面解析了 map_list 结构，包含一个 map_item 数组，每个 map_item 描述 Dex 文件的每个结构。 解析结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse map_list &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;map_list size: 13map_item:type: 0x0type desc: header_itemsize: 1offset: 0map_item:type: 0x1type desc: string_id_itemsize: 20offset: 112map_item:type: 0x2type desc: type_id_itemsize: 8offset: 192map_item:type: 0x3type desc: proto_id_itemsize: 3offset: 224map_item:type: 0x4type desc: field_id_itemsize: 3offset: 260map_item:type: 0x5type desc: method_id_itemsize: 6offset: 284map_item:type: 0x6type desc: class_def_itemsize: 1offset: 332map_item:type: 0x2001type desc: code_itemsize: 4offset: 364map_item:type: 0x1001type desc: type_listsize: 2offset: 484map_item:type: 0x2002type desc: string_data_itemsize: 20offset: 498map_item:type: 0x2003type desc: debug_info_itemsize: 4offset: 731map_item:type: 0x2000type desc: class_data_itemsize: 1offset: 755map_item:type: 0x1000type desc: map_listsize: 1offset: 784 下面就可以遍历 map_list 了，然后根据提供的偏移和大小解析对应结构就好了。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void DexParser::parse(){ printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse header_item &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); parse_header_item(); printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse map_list &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); parse_map_list(); // 遍历 map_list 以解析每个结构 for (u4 i = 0; i &lt; this-&gt;map_list_.size; i++) { const map_item item = map_list_.list[i]; printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse %s:\\n\\n&quot;, type_string(item.type)); if (item.size == 0) { printf(&quot;item is empty.\\n&quot;); continue; } switch (item.type) { case TYPE_STRING_ID_ITEM: parse_string_list(item.size, item.offset); break; case TYPE_TYPE_ID_ITEM: parse_type_ids(item.size, item.offset); break; case TYPE_PROTO_ID_ITEM: parse_proto_ids(item.size, item.offset); break; case TYPE_FIELD_ID_ITEM: parse_field_ids(item.size, item.offset); break; case TYPE_METHOD_ID_ITEM: parse_method_ids(item.size, item.offset); break; case TYPE_CLASS_DEF_ITEM: parse_class_defs(item.size, item.offset); break; case TYPE_MAP_LIST: printf(&quot;ignore.\\n&quot;); break; case TYPE_TYPE_LIST: printf(&quot;ignore.\\n&quot;); break; case TYPE_ANNOTATION_SET_ITEM: printf(&quot;ignore.\\n&quot;); break; case TYPE_CLASS_DATA_ITEM: parse_class_data_list(item.size, item.offset); break; case TYPE_CODE_ITEM: parse_code_list(item.size, item.offset); break; case TYPE_STRING_DATA_ITEM: printf(&quot;ignore.\\n&quot;); break; case TYPE_DEBUG_INFO_ITEM: printf(&quot;ignore.\\n&quot;); break; case TYPE_ANNOTATION_ITEM: printf(&quot;ignore.\\n&quot;); break; case TYPE_ENCODED_ARRAY_ITEM: printf(&quot;ignore.\\n&quot;); break; case TYPE_ANNOTATIONS_DIRECTORY_ITEM: printf(&quot;ignore.\\n&quot;); break; default: printf(&quot;item: %s\\n&quot;, type_string(item.type)); } }} 下面是 Dex 关键结构（跳过了一些注释和调试结构的解析）的解析代码以及解析 Hello.dex 的结果。 string_list123456789101112131415161718192021222324252627282930313233343536373839404142434445// DexParser.cppvoid DexParser::parse_string_list(const u4 size, const u4 offset){ printf(&quot;string ids count: %u\\n&quot;, size); printf(&quot;string ids offset: %u\\n&quot;, offset); if (size == 0) { printf(&quot;#parse_string_list - not found string ids.\\n&quot;); return; } // parse string id items. { if (0 != fseek(this-&gt;dex_file_, offset, 0)) { printf(&quot;#parse_string_list - seek file error.&quot;); return; } this-&gt;string_ids_ = new string_id_item[size]; if (0 == fread(this-&gt;string_ids_, sizeof(string_id_item), size, this-&gt;dex_file_)) { printf(&quot;#parse_string_list - read file error.&quot;); return; } } // parse string data items. this-&gt;string_list_size_ = size; this-&gt;string_list_ = new string_data_item[size]; for (u4 i = 0; i &lt; size; i++) { const auto str_off = this-&gt;string_ids_[i].string_data_off; printf(&quot;\\nstring offset: %d\\n&quot;, str_off); string_data_item&amp; item = this-&gt;string_list_[i]; item.parse(this-&gt;dex_file_, str_off); printf(&quot;string: %s\\n&quot;, this-&gt;string_list_[i].data); }} 解析结果如下，包含 Dex 文件中所有使用到的字符串： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse string_id_item:string ids count: 20string ids offset: 112string offset: 498string: &lt;clinit&gt;string offset: 508string: &lt;init&gt;string offset: 516string: Hello Dex.string offset: 528string: Hello.javastring offset: 540string: Istring offset: 543string: Lio/l0neman/example/Hello;string offset: 571string: Ljava/io/PrintStream;string offset: 594string: Ljava/lang/Object;string offset: 614string: Ljava/lang/String;string offset: 634string: Ljava/lang/System;string offset: 654string: Vstring offset: 657string: VLstring offset: 661string: [Ljava/lang/String;string offset: 682string: fieldstring offset: 689string: mFieldstring offset: 697string: mainstring offset: 703string: outstring offset: 708string: printlnstring offset: 717string: sFieldstring offset: 725string: test type_ids123456789101112131415161718192021222324252627282930313233void DexParser::parse_type_ids(const u4 size, const u4 offset){ const auto type_ids_size = size; if (type_ids_size == 0) { printf(&quot;#parse_type_ids - not found type ids.\\n&quot;); return; } printf(&quot;type_ids size: %u\\n&quot;, type_ids_size); printf(&quot;type_ids offset: %u\\n&quot;, offset); if (0 != fseek(this-&gt;dex_file_, offset, 0)) { printf(&quot;#parse_type_ids - seek file error.\\n&quot;); return; } this-&gt;type_list_ = new type_id_item[type_ids_size]; if (0 == fread(this-&gt;type_list_, sizeof(type_id_item), type_ids_size, this-&gt;dex_file_)) { printf(&quot;#parse_type_ids - read file error.\\n&quot;); return; } for (u4 i = 0; i &lt; type_ids_size; i++) { printf(&quot;type: %s\\n&quot;, get_string_from_string_list( this-&gt;type_list_[i].descriptor_idx)); }} 解析结果如下，所有类型标识符： 123456789101112&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse type_id_item:type_ids size: 8type_ids offset: 192type: Itype: Lio/l0neman/example/Hello;type: Ljava/io/PrintStream;type: Ljava/lang/Object;type: Ljava/lang/String;type: Ljava/lang/System;type: Vtype: [Ljava/lang/String; proto_ids12345678910111213141516171819202122232425262728void DexParser::parse_proto_ids(const u4 size, const u4 offset){ printf(&quot;proto ids size: %d\\n&quot;, size); printf(&quot;proto ids offset: %d\\n\\n&quot;, offset); if (0 != fseek(this-&gt;dex_file_, offset, 0)) { printf(&quot;#parse_proto_ids - seek file error.\\n&quot;); return; } this-&gt;proto_list_ = new proto_id_item[size]; if (0 == fread(this-&gt;proto_list_, sizeof(proto_id_item), size, this-&gt;dex_file_)) { printf(&quot;#parse_proto_ids - read file error.&quot;); return; } for (u4 i = 0; i &lt; size; i++) { printf(&quot;shorty: %s\\n&quot;, get_string_from_string_list( this-&gt;proto_list_[i].shorty_ids)); printf(&quot;return type: %s\\n&quot;, get_type_description( this-&gt;proto_list_[i].return_type_idx)); printf(&quot;parameters offset: %d\\n\\n&quot;, this-&gt;proto_list_[i].parameters_off); }} 解析结果如下，方法类型标识符： 12345678910111213141516&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse proto_id_item:proto ids size: 3proto ids offset: 224shorty: Vreturn type: Vparameters offset: 0shorty: VLreturn type: Vparameters offset: 484shorty: VLreturn type: Vparameters offset: 492 field_ids1234567891011121314151617181920212223242526272829void DexParser::parse_field_ids(const u4 size, const u4 offset) const{ printf(&quot;field list size: %d\\n&quot;, size); printf(&quot;field list offset: %d\\n\\n&quot;, offset); if (0 != fseek(this-&gt;dex_file_, offset, 0)) { printf(&quot;#parse_field_ids - seek file error.\\n&quot;); return; } auto field_list = new field_id_item[size]; if (0 == fread(field_list, sizeof(field_id_item), size, this-&gt;dex_file_)) { printf(&quot;#parse_field_ids - read file error.\\n&quot;); return; } for (u4 i = 0; i &lt; size; i++) { printf(&quot;field name: %s\\n&quot;, get_string_from_string_list(field_list[i].name_idx)); printf(&quot;parent class name: %s\\n&quot;, get_type_description(field_list[i].class_idx)); printf(&quot;type name: %s\\n\\n&quot;, get_type_description(field_list[i].type_idx)); } delete[] field_list; field_list = nullptr;} 解析结果如下，所有类成员： 12345678910111213141516&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse field_id_item:field list size: 3field list offset: 260field name: mFieldparent class name: Lio/l0neman/example/Hello;type name: Ljava/lang/String;field name: sFieldparent class name: Lio/l0neman/example/Hello;type name: Ifield name: outparent class name: Ljava/lang/System;type name: Ljava/io/PrintStream; method_ids12345678910111213141516171819202122232425262728293031void DexParser::parse_method_ids(const u4 size, const u4 offset) const{ printf(&quot;method ids size: %d\\n&quot;, size); printf(&quot;method ids offset: %d\\n\\n&quot;, offset); if (0 != fseek(this-&gt;dex_file_, offset, 0)) { printf(&quot;#parse_method_ids - seek file error.\\n&quot;); return; } auto method_list = new method_id_item[size]; if (0 == fread(method_list, sizeof(method_id_item), size, this-&gt;dex_file_)) { printf(&quot;#parse_method_ids - read file error.\\n&quot;); return; } for (u4 i = 0; i &lt; size; i++) { printf(&quot;method name: %s\\n&quot;, get_string_from_string_list( method_list[i].name_idx)); printf(&quot;method proto return type: %s\\n&quot;, get_type_description( get_proto_item(method_list[i].proto_idx).return_type_idx)); printf(&quot;parent class name: %s\\n\\n&quot;, get_type_description(method_list[i].class_idx)); } delete[] method_list; method_list = nullptr;} 解析结果如下，所有类方法信息： 12345678910111213141516171819202122232425262728&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse method_id_item:method ids size: 6method ids offset: 284method name: &lt;clinit&gt;method proto return type: Vparent class name: Lio/l0neman/example/Hello;method name: &lt;init&gt;method proto return type: Vparent class name: Lio/l0neman/example/Hello;method name: mainmethod proto return type: Vparent class name: Lio/l0neman/example/Hello;method name: testmethod proto return type: Vparent class name: Lio/l0neman/example/Hello;method name: printlnmethod proto return type: Vparent class name: Ljava/io/PrintStream;method name: &lt;init&gt;method proto return type: Vparent class name: Ljava/lang/Object; class_def_item123456789101112131415161718192021222324252627282930void DexParser::parse_class_defs(const u4 size, const u4 offset) const{ printf(&quot;class defs size: %u\\n&quot;, size); printf(&quot;class defs offset: %u\\n\\n&quot;, offset); if (0 != fseek(this-&gt;dex_file_, offset, 0)) { printf(&quot;#parse_class_defs - seek file error.\\n&quot;); return; } auto class_def_list = new class_def_item[size]; if (0 == fread(class_def_list, sizeof(class_def_item), size, this-&gt;dex_file_)) { printf(&quot;#parse_class_defs - read file error.\\n&quot;); return; } for (u4 i = 0; i &lt; size; i++) { printf(&quot;class name: %s\\n&quot;, get_type_description(class_def_list[i].class_idx)); printf(&quot;access flags: &quot;); print_access_flags_description(class_def_list[i].access_flag); printf(&quot;\\n\\n&quot;); } delete[] class_def_list; class_def_list = nullptr;} 解析结果如下，类定义信息，这里只有一个 Hello 类： 1234567&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse class_def_item:class defs size: 1class defs offset: 332class name: Lio/l0neman/example/Hello;access flags: public class_data_list1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void DexParser::parse_class_data_list(const u4 size, const u4 offset) const{ printf(&quot;class data list size: %u\\n&quot;, size); printf(&quot;class data list offset: %u\\n&quot;, offset); if (0 != fseek(this-&gt;dex_file_, offset, 0)) { printf(&quot;#parse_class_data_list - seek file error.\\n&quot;); return; } class_data_item* class_data_list = new class_data_item[size]; u4 seek_add = 0; for (u4 i = 0; i &lt; size; i++) { printf(&quot;\\nparse %d class_data_item:\\n\\n&quot;, i); printf(&quot;seek add: %d\\n&quot;, seek_add); class_data_item* item = &amp;class_data_list[i]; // parse static_fields_size. item-&gt;static_fields_size.parse(this-&gt;dex_file_, offset + seek_add); printf(&quot;static fields size: %d\\n&quot;, item-&gt;static_fields_size.value); seek_add += item-&gt;static_fields_size.length; // parse instance_field_size. item-&gt;instance_fields_size.parse(this-&gt;dex_file_, offset + seek_add); printf(&quot;instance fields size: %d\\n&quot;, item-&gt;instance_fields_size.value); seek_add += item-&gt;instance_fields_size.length; // parse direct_methods_size. item-&gt;direct_methods_size.parse(this-&gt;dex_file_, offset + seek_add); printf(&quot;direct methods size: %d\\n&quot;, item-&gt;direct_methods_size.value); seek_add += item-&gt;direct_methods_size.length; // parse virtual_methods_size. item-&gt;virtual_methods_size.parse(this-&gt;dex_file_, offset + seek_add); printf(&quot;virtual methods size: %d\\n&quot;, item-&gt;virtual_methods_size.value); seek_add += item-&gt;virtual_methods_size.length; // parse static_fields. item-&gt;static_fields = new encoded_field[item-&gt;static_fields_size.value]; for (u4 j = 0; j &lt; item-&gt;static_fields_size.value; j++) { parse_encoded_field(offset + seek_add, &amp;item-&gt;static_fields[j]); seek_add += item-&gt;static_fields[j].field_idx_diff.length + item-&gt;static_fields[j].access_flags.length; } // parse instance_fields. item-&gt;instance_fields = new encoded_field[item-&gt;instance_fields_size.value]; for (u4 j = 0; j &lt; item-&gt;instance_fields_size.value; j++) { parse_encoded_field(offset + seek_add, &amp;item-&gt;instance_fields[j]); seek_add += item-&gt;instance_fields[j].field_idx_diff.length + item-&gt;instance_fields[j].access_flags.length; } // parse direct_methods. item-&gt;direct_methods = new encoded_method[item-&gt;direct_methods_size.value]; for (u4 j = 0; j &lt; item-&gt;direct_methods_size.value; j++) { parse_encoded_method(offset + seek_add, &amp;item-&gt;direct_methods[j]); seek_add += item-&gt;direct_methods[j].method_idx_diff.length + item-&gt;direct_methods[j].access_flags.length + item-&gt;direct_methods[j].code_off.length; } // parse virtual_methods. item-&gt;virtual_methods = new encoded_method[item-&gt;virtual_methods_size.value]; for (u4 j = 0; j &lt; item-&gt;virtual_methods_size.value; j++) { encoded_method* vmethod = &amp;item-&gt;virtual_methods[j]; parse_encoded_method(offset + seek_add, &amp;item-&gt;virtual_methods[j]); seek_add += vmethod-&gt;method_idx_diff.length + vmethod-&gt;access_flags.length + vmethod-&gt;code_off.length; } } delete[] class_data_list; class_data_list = nullptr;} 打印如下信息： 123456789101112&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse class_data_item:class data list size: 1class data list offset: 755parse 0 class_data_item:seek add: 0static fields size: 1instance fields size: 1direct methods size: 4virtual methods size: 0 code_item12345678910111213141516171819202122232425262728293031323334void DexParser::parse_code_list(const u4 size, const u4 offset) const{ printf(&quot;code list size: %u\\n&quot;, size); printf(&quot;code list offset: %u\\n&quot;, offset); code_item* code_list = new code_item[size]; u4 seek_add = 0; for (u4 i = 0; i &lt; size; i++) { printf(&quot;\\nparse %d code_item:\\n\\n&quot;, i); printf(&quot;seek_add: %u\\n&quot;, seek_add); code_item* item = &amp;code_list[i]; u4 item_size = item-&gt;parse(this-&gt;dex_file_, offset + seek_add); if (item_size == -1) { printf(&quot;parse code list error.\\n&quot;); return; } // Byte aligned!. { auto mod = item_size % 4; item_size += (mod == 0 ? 0 : 4 - mod); } seek_add += item_size; } delete[] code_list; code_list = nullptr;} 解析结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse code_item:code list size: 4code list offset: 364parse 0 code_item:seek_add: 0registers_size: 1ins_size: 0outs_size: 0tries_size: 0debug_info_off: 731insns_size: 4insns: 1012 0067 0001 000eparse 1 code_item:seek_add: 24registers_size: 2ins_size: 1outs_size: 1tries_size: 0debug_info_off: 736insns_size: 8insns: 1070 0005 0001 001a 000d 105b 0000 000eparse 2 code_item:seek_add: 56registers_size: 3ins_size: 1outs_size: 2tries_size: 0debug_info_off: 742insns_size: 8insns: 0062 0002 0011a 0002 206e 0004 0010 000eparse 3 code_item:seek_add: 88registers_size: 3ins_size: 1outs_size: 2tries_size: 0debug_info_off: 749insns_size: 8insns: 0062 0002 2154 0000 206e 0004 0010 000e 对应代码字节码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.class public Lio/l0neman/example/Hello;.super Ljava/lang/Object;.source &quot;Hello.java&quot;# static fields.field private static sField:I# instance fields.field private mField:Ljava/lang/String;# direct methods.method static constructor &lt;clinit&gt;()V .registers 1 .prologue const/4 v0, 0x1 sput v0, Lio/l0neman/example/Hello;-&gt;sField:I return-void.end method.method public constructor &lt;init&gt;()V .registers 2 .prologue invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V const-string v0, &quot;field&quot; iput-object v0, p0, Lio/l0neman/example/Hello;-&gt;mField:Ljava/lang/String; return-void.end method.method public static main([Ljava/lang/String;)V .registers 3 .prologue sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream; const-string v1, &quot;Hello Dex.&quot; invoke-virtual {v0, v1}, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V return-void.end method.method private test()V .registers 3 .prologue sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream; iget-object v1, p0, Lio/l0neman/example/Hello;-&gt;mField:Ljava/lang/String; invoke-virtual {v0, v1}, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V return-void.end method uleb128对于 uleb128 类型的解析，这里参考了系统实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// uleb128.cppuint32_t Leb128::decode_signed_leb128(uint8_t const** data){ auto ptr = *data; int32_t result = *(ptr++); if (result &lt;= 0x7f) { result = (result &lt;&lt; 25) &gt;&gt; 25; } else { int cur = *(ptr++); result = (result &amp; 0x7f) | ((cur &amp; 0x7f) &lt;&lt; 7); if (cur &lt;= 0x7f) { result = (result &lt;&lt; 18) &gt;&gt; 18; } else { cur = *(ptr++); result |= (cur &amp; 0x7f) &lt;&lt; 14; if (cur &lt;= 0x7f) { result = (result &lt;&lt; 11) &gt;&gt; 11; } else { cur = *(ptr++); result |= (cur &amp; 0x7f) &lt;&lt; 21; if (cur &lt;= 0x7f) { result = (result &lt;&lt; 4) &gt;&gt; 4; } else { // Note: We don't check to see if cur is out of range here, // meaning we tolerate garbage in the four high-order bits. cur = *(ptr++); result |= cur &lt;&lt; 28; } } } } *data = ptr; return result;}uint32_t Leb128::decode_unsigned_leb128(uint8_t const** data){ auto ptr = *data; int result = *(ptr++); if (LIKELY(result &gt; 0x7f)) { int cur = *(ptr++); result = (result &amp; 0x7f) | ((cur &amp; 0x7f) &lt;&lt; 7); if (cur &gt; 0x7f) { cur = *(ptr++); result |= (cur &amp; 0x7f) &lt;&lt; 14; if (cur &gt; 0x7f) { cur = *(ptr++); result |= (cur &amp; 0x7f) &lt;&lt; 21; if (cur &gt; 0x7f) { // Note: We don't check to see if cur is out of range here, // meaning we tolerate garbage in the four high-order bits. cur = *(ptr++); result |= cur &lt;&lt; 28; } } } } *data = ptr; return static_cast&lt;uint32_t&gt;(result);} 这里解析代码就列出的差不多了，真正理解具体的解析还需要自己去动手实现，下面给出仓库地址，可以参考相关代码进行解析。 dexdumpAndroid SDK 提供了一个 dexdump 工具，可以解析 Dex 文件的信息。 例如： 1dexdump -f Hello.dex 结果如下： 12345678910111213141516171819202122232425Processing 'Hello.dex'...Opened 'Hello.dex', DEX version '035'DEX file header:magic : 'dex\\n035\\0'checksum : 99137d68signature : 68bf...6a42file_size : 944header_size : 112link_size : 0link_off : 0 (0x000000)string_ids_size : 20string_ids_off : 112 (0x000070)type_ids_size : 8type_ids_off : 192 (0x0000c0)proto_ids_size : 3proto_ids_off : 224 (0x0000e0)field_ids_size : 3field_ids_off : 260 (0x000104)method_ids_size : 6method_ids_off : 284 (0x00011c)class_defs_size : 1class_defs_off : 332 (0x00014c)data_size : 580data_off : 364 (0x00016c)... 代码仓库 https://github.com/l0neman/DexFileParser/ 参考 https://source.android.google.cn/devices/tech/dalvik/dex-format http://androidxref.com/9.0.0_r3/xref/dalvik/libdex/DexFile.h http://www.520monkey.com/archives/579","link":"/2020/09/09/android-dex-%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"},{"title":"Android so(ELF) 文件解析","text":"前言ELF 是一种可执行文件的格式，全称是 Executable and Linkable Format，即可执行和链接格式，它是 Unix/Linux 系统下的二进制文件的标准格式，与之对应的是 Windows 系统的 PE（Portable Executable）可执行文件格式，它们都是由 COFF（Common Object File Format，通用对象文件格式）文件格式发展而来。 so 文件是 Unix/Linux 系统中的动态库文件，被称为共享目标文件（Shared Object File），后缀名为 .so，它是 ELF 的一种，另外属于 ELF 类型的还有可重定位文件（Relocatable File）以及核心转储文件（Core Dump File）。 ELF 文件类型 说明 实例 可重定位文件（Relocatable File） 这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类 Linux 的 .o；Windows 的 .obj 共享目标文件（Shared Object File） 这种文件包含了代码和数据，可以在以下两种情况中使用，一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件，第二种是动态连接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行 Linux 的 .so，如 /lib/glibc-2.5.so，Windows 的 DLL 核心转储文件（Core Dump File） 当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件 Linux 下的 Core Dump Android 是基于 Linux 内核开发的操作系统，所以 Android 平台上的可执行文件格式和 Unix/Linux 是一致的。 下面以 Android 平台下的 so 文件为例子对 ELF 这种文件格式进行解析。 生成 so 文件为了对 so 文件进行解析，首先需要生成一个 so 文件。 NDK 开发可参考：Android NDK 指南 首先建立一个最基本的 NDK 开发工程，创建 Java 类 NativeHandler： 12345678910// NativeHandler.javapackage io.l0neman.nativetproject;public class NativeHandler { static { // 加载 libfoo.so 库 System.loadLibrary(&quot;foo&quot;); } public static native String getHello();} 编写 C++ 代码文件，为了稍微显得没有那么简单，加入一些变量和简单函数： 1234567891011// foo.h#ifndef NATIVETPROJECT_FOO_H#define NATIVETPROJECT_FOO_H#include &lt;jni.h&gt;extern &quot;C&quot; {JNIEXPORT jstring JNICALLJava_io_l0neman_nativetproject_NativeHandler_getHello(JNIEnv *env, jclass clazz);}#endif //NATIVETPROJECT_FOO_H 12345678910111213141516171819202122232425262728// foo.cpp#include &quot;foo.h&quot;#include &lt;cstdio&gt;#include &lt;jni.h&gt;int global_init_var = 84;int global_uninit_var;void func1(int i) { printf(&quot;%d&quot;, i);}int test() { static int static_var = 85; static int static_var2; int a = 1; int b; func1(static_var + static_var2 + a + b); return a;}extern &quot;C&quot; {jstring Java_io_l0neman_nativetproject_NativeHandler_getHello(JNIEnv *env, jclass clazz) { test(); return env-&gt;NewStringUTF(&quot;hello&quot;);}} mk 文件： 123# Application.mkAPP_ABI := armeabi-v7a arm64-v8aAPP_OPTIM := release 1234567891011# Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := foo.cppLOCAL_CFLAGS := -ginclude $(BUILD_SHARED_LIBRARY) 这些文件在 src/main/jni 目录中，进入 jni 目录，然后执行 ndk-build 命令，将编译出 armeabi-v7a 和 arm64-v8a 架构的 libfoo.so 文件，它们的位置在 src/main/jni/libs/armxxx/libfoo.so。 有了文件，下面开始进行解析。 相关工具在解析之前介绍两个用于解析 ELF 文件的工具，它们通常是 Linux 系统中自带的软件，可直接使用。 如果想要在 Windows 系统中使用，推荐使用 Windows 子系统（Windows Subsystem for Linux）。 objdump可解析目标文件的工具，可显示 ELF 文件的概要信息。常用选项如下： 123456789-h 显示所有节的信息-x 显示所有节的内容-d 显示可执行节的汇编程序内容-D --disassemble-all 显示所有节的汇编程序内容-s --full-contents 显示所有节内容-t --syms 显示符号表的内容-T --dynamic-syms 显示动态符号表的内容-r --reloc 显示文件中的重定位条目-R --dynamic-reloc 显示文件中的动态重定位条目 readelf用于解析 ELF 文件的工具，可以详细的输出 ELF 文件的信息。常用选项如下： 123456789-a 等效于：-h -l -S -s -r -d -V -A -I-h --file-header 显示 ELF 文件头-l --program-headers 显示程序头-s --syms 显示符号表--dyn-syms 显示动态符号表-n --notes 显示核心注释-r --relocs 显示重定位-u --unwind 显示展开信息-d --dynamic 显示动态部分 在下面的解析过程中，可使用这两个工具对解析结果进行参考和对照。 整体结构图 上图反映了一个 ELF 文件的典型结构，首先是一个 ELF 文件的头结构，根据 ELF 所支持的目标执行平台不同，分为 32 位和 64 位的 ELF 文件，32 位 ELF 文件的头结构使用一个 Elf32_Ehdr 结构体描述，ELF 头结构描述了整个 ELF 文件的属性，包括文件类型（可执行文件、可重定位、共享目标文件等）、虚拟入口地址、段表偏移、文件本身的大小等。 文件头下面的就是 ELF 文件的主要内容了，ELF 文件由若干个段（Section）组成，它们的结构各不相同，在 ELF 文件中扮演不同的角色，有各自的分工。通常 ELF 文件包含若干遵循 ELF 结构规范的段。如上图所示，左边带有 . 前缀的为段名，上面几个深蓝色的矩形为 ELF 文件标准结构，它们有明确的结构定义，在 Android 9.0 系统源代码中，可在 art/runtime/elf.h 文件中找到它们对应的定义，在下面的分析中会一一解释它们的含义。 除了具有标准结构的 ELF 段，还有一些常用段以及程序自定义段名的段。下面列举一些常用段的含义： 段名 说明 .rodata Read only Data，存放的是只读数据，比如字符串、全局 const 变量等 .comment 存放编译器版本信息，例如 GCC:(GNU)4.2.0 .debug 调试信息 .dynamic 动态链接信息 .hash 符号哈希表 .line 调试时的行号表，即源代码与行号与编译后指令的对应表 .notes 额外的编译器信息，比如程序的公司名、发布版本等 .strtab String Table，字符串表，用于存储 ELF 文件中用到的字符串 .symtab Symbol Table，符号表，存放 ELF 文件的内部符号 .shstrtab Section String Table，段名字符串表 .plt.got 动态链接的跳转表和全局入口表 .init.fini 程序初始化终结代码段 .interp 存放动态链接器路径 .text 代码段，存放机器指令，是 ELF 文件的主要内容 .bss 为未初始化的全局变量和局部静态变量预留位置，没有内容，不占空间 .data 数据段，存全局变量和局部静态变量 .dynstr 动态符号字符串表 对于任意的 ELF 文件，它的结构可能不会像上面图中一样完整，根据实际情况，编译器编译生成的 ELF 文件会根据实际代码来增加或减少相应的段，顺序也可能和上图不同，但 ELF 文件的头部结构和那几个标准格式段的结构是一致的。 头部结构首先是 ELF 文件的头部结构，32 位 ELF 文件的头部结构定义如下： 123456789101112131415161718192021222324typedef uint32_t Elf32_Addr; // 表示程序地址typedef uint32_t Elf32_Off; // 表示文件偏移typedef uint16_t Elf32_Half;typedef uint32_t Elf32_Word;typedef int32_t Elf32_Sword;EI_NIDENT = 16struct Elf32_Ehdr { unsigned char e_ident[EI_NIDENT]; // 文件标识 Elf32_Half e_type; // 文件类型 Elf32_Half e_machine; // ELF 文件的 CPU 平台属性，相关常量以 EM_ 开头 Elf32_Word e_version; // ELF 版本号，一般为常数 1 Elf32_Addr e_entry; // 入口地址，规定 ELF 程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令 Elf32_Off e_phoff; // Program header 表的文件偏移字节 Elf32_Off e_shoff; // 段表在文件中的偏移 Elf32_Word e_flags; // LF 标志位，用来标识一些 ELF 文件平台相关的属性。相关常量格式一般为 EF_machine_flag，machine 为平台，flag 为标志 Elf32_Half e_ehsize; // ELF 文件头本身的大小 Elf32_Half e_phentsize; // Program header 表的大小 Elf32_Half e_phnum; // Program header 表的数量 Elf32_Half e_shentsize; // 段表描述符的大小，这个一般等于一节 Elf32_Half e_shnum; // 段表描述符数量。这个值等于 ELF 文件中拥有段的数量 Elf32_Half e_shstrndx; // 段表字符串表所在的段在段表中的下标}; e_ident（ELF 魔数） e_ident 是文件标识字段，也就是魔数，32 位 ELF 文件的文件标识为 16 个字节，每个字节含义如下： 12345678 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 ^ ^ ^ ^ ^ ^ E L F | | / \\[ ELF 文件类型 ] [ 字节序 ]0 无效文件 0 无效格式1 32 位 ELF 文件 1 小端格式2 64 位 ELF 文件 2 大端格式 e_type（文件类型） e_type 成员表示 ELF 文件类型，系统通过这个常量来判断 ELF 文件类型，而不是文件扩展名。 常量 值 含义 ET_NONE 0 无类型 ET_REL 1 可重定位文件，一般为 .o 文件 ET_EXEC 2 可执行文件 ET_DYN 3 共享目标文件，一般为 .so 文件 ET_CORE 4 核心文件 e_machine（机器类型） ELF 文件被设计成可以在多个平台下使用，但并不表示同一个 ELF 文件可以在不同的平台下使用，而是表示不同平台下的 ELF 文件都遵循同一套 ELF 标准。e_machine 成员就表示该属性。 相关常量以“EM”开头，例如： 常量 值 含义 EM_M32 1 AT&amp;T WE 32100 EM_SPARC 2 SPARC EM_386 3 Intel x86 EM_68K 4 Motorola 68000 EM_88K 5 Motorola 88000 EM_860 6 Intel 80860 … 完整列表可以参考 elf.h 文件中的相关常量定义。 ELF 文件头结构中其他字段上面的注释中已经能够说明对应的含义，部分字段描述了子结构的偏移，包括 Program Header 表和 Section Header 表以及字符串表，这个在解析对应的结构时会用到。 使用 readelf 工具解析 armeabi-v7a/libfoo.so 头结构结果如下： 1234567891011121314151617181920ELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: ARM Version: 0x1 Entry point address: 0x0 Start of program headers: 52 (bytes into file) Start of section headers: 12920 (bytes into file) Flags: 0x5000200, Version5 EABI, soft-float ABI Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 8 Size of section headers: 40 (bytes) Number of section headers: 27 Section header string table index: 26 段表结构段表由 Elf32_Shdr 结构体数组描述，每个 Elf32_Shdr 描述一个段。 段表的描述结构体数组在文件中的偏移存放在 ELF 文件头中的 e_shoff 字段中，e_shentsize 和 e_shnum 字字段分别为数组的大小和数量。 123456789101112struct Elf32_Shdr { Elf32_Word sh_name; // 段名，位于 .shstrtab 的字符串表。sh_name 是段名在其中的偏移 Elf32_Word sh_type; // 段类型（SHT_*） Elf32_Word sh_flags; // 段标志位（SHF_*） Elf32_Addr sh_addr; // 段的虚拟地址，前提是该段可被加载，否则为 0 Elf32_Off sh_offset; // 段偏移，前提是该段存在于文件中，否则无意义 Elf32_Word sh_size; // 段的长度 Elf32_Word sh_link; // 段的链接信息 Elf32_Word sh_info; // 段的额外信息 Elf32_Word sh_addralign; // 段地址对齐 Elf32_Word sh_entsize; // 项的长度}; sh_type（段的类型） 段的名字只在编译和链接过程中有意义，无法真正表示段的类型，决定段的属性和类型的是段的类型（sh_type）和段的属性（sh_flag） 段类型的相关常量以 SHT 开头，例如： 常量 值 含义 SHT_NULL 0 无效段 SHT_PROGBITS 1 程序段、代码段、数据段都是这种类型 SHT_SYMTAB 2 表示该段的内容为符号表 SHT_STRTAB 3 表示该段的内容为字符串表 SHT_RELA 4 重定位表，该段包含了重定位信息 SHT_HASH 5 符号表的哈希表 SHT_DYNAMIC 6 动态链接信息 SHT_NOTE 7 提示性信息 SHT_NOBITS 8 表示该段在文件中没有内容，比如 .bss 段 SHT_REL 9 该段包含了重定位信息 SHT_SHLIB 10 保留 SHT_DNYSYM 11 动态链接的符号表 … 完整列表可以参考 elf.h 文件中的相关常量定义。 sh_flag（段的标志） 段的标志位表示该段在进程虚拟地址空间中的属性，比如是否可写，是否可执行等。 常见值如下： 常量 值 含义 SHF_WRITE 0x1 表示该段在进程空间中可写 SHF_ALLOC 0x2 表示该段在进程空间中需要分配空间。有些包含指示或者控制信息的段不需要在进程空间中被分配空间，它们一般不会有这个标志。像代码段、数据段和 .bss 段一般都会有这个标志位 SHF_EXECINSTR 0x4 表示该段在进程空间中可以被执行,一般指代码段 … 完整列表可以参考 elf.h 文件中的相关常量定义。 系统保留段相关标志位如下： Name sh_type sh_flags .bss SHT_NOBITS SHF_ALLOC + SHF_WRITE .comment SHT_PROGBITS none .data SHT_PROGBITS SHF_ALLOC + SHF_WRITE .data1 SHT_PROGBITS SHF_ALLOC + SHF_WRITE .debug SHT_PROGBITS none .dynamic SHT_DYNAMIC SHF_ALLOC + SHF_WRITE有些系统下 .dynamic 段可能是只读的，所以没有 SHF_WRITE 标志位 .hash SHT_HASH SHF_ALLOC .line SHT_PROGBITS none .note SHT_NOTE none .rodata SHT_PROGBITS SHF_ALLOC .rodata1 SHT_PROGBITS SHF_ALLOC .shstrtab SHT_STRTAB none .strtab SHT_STRTAB 如果该 ELF 文件中有可装载的段需要用到该字符串表，那么字符串表也将被装载的到内存空间，则有 SHF_ALLOC 标志位 .symtab SHT_SYMTAB 同字符串表 .text SHT_PROGBITS SHF_ALLOC + SHF_WRITE sh_link、sh_info（段的链接信息） 段的类型必须是链接相关的（动态或静态），比如重定位表、符号表等。否则这两个成员无意义。 sh_type sh_link sh_info SHT_DYNAMIC 该段所使用的字符串表在段表中的下标 0 SHT_HASH 该段所使用的符号表在段表中的下标 0 SHT_RELSHT_RELA 该段所使用的相应符号表在段表中的下标 该重定位表所作用的段在段表中的下标 SHT_SYMTABSHT_DYNSYM 操作系统相关的 操作系统相关的 other SHN_UNDEF 0 使用 readelf 工具解析 libfoo.so 段表描述结果如下： 1234567891011121314151617181920212223242526272829Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .note.android.ide NOTE 00000134 000134 000098 00 A 0 0 4 [ 2] .note.gnu.build-i NOTE 000001cc 0001cc 000024 00 A 0 0 4 [ 3] .dynsym DYNSYM 000001f0 0001f0 000350 10 A 4 1 4 [ 4] .dynstr STRTAB 00000540 000540 000373 00 A 0 0 1 [ 5] .gnu.hash GNU_HASH 000008b4 0008b4 00015c 04 A 3 0 4 [ 6] .hash HASH 00000a10 000a10 000170 04 A 3 0 4 [ 7] .gnu.version VERSYM 00000b80 000b80 00006a 02 A 3 0 2 [ 8] .gnu.version_d VERDEF 00000bec 000bec 00001c 00 A 4 1 4 [ 9] .gnu.version_r VERNEED 00000c08 000c08 000040 00 A 4 2 4 [10] .rel.dyn REL 00000c48 000c48 0000c8 08 A 3 0 4 [11] .rel.plt REL 00000d10 000d10 0000f0 08 AI 3 20 4 [12] .plt PROGBITS 00000e00 000e00 00017c 00 AX 0 0 4 [13] .text PROGBITS 00000f7c 000f7c 0016b4 00 AX 0 0 4 [14] .ARM.exidx ARM_EXIDX 00002630 002630 0001a0 08 AL 13 0 4 [15] .ARM.extab PROGBITS 000027d0 0027d0 000180 00 A 0 0 4 [16] .rodata PROGBITS 00002950 002950 000497 01 AMS 0 0 1 [17] .fini_array FINI_ARRAY 00003e08 002e08 000008 04 WA 0 0 4 [18] .data.rel.ro PROGBITS 00003e10 002e10 000048 00 WA 0 0 4 [19] .dynamic DYNAMIC 00003e58 002e58 000110 08 WA 4 0 4 [20] .got PROGBITS 00003f68 002f68 000098 00 WA 0 0 4 [21] .data PROGBITS 00004000 003000 00000c 00 WA 0 0 4 [22] .bss NOBITS 0000400c 00300c 000005 00 WA 0 0 4 [23] .comment PROGBITS 00000000 00300c 000109 01 MS 0 0 1 [24] .note.gnu.gold-ve NOTE 00000000 003118 00001c 00 0 0 4 [25] .ARM.attributes ARM_ATTRIBUTES 00000000 003134 000034 00 0 0 1 [26] .shstrtab STRTAB 00000000 003168 00010f 00 0 0 1 字符串表结构字符串表存放 ELF 文件内需要被使用的字符串，它是由多个字符串首尾相连组成，是一段连续的字节。 通常一个 ELF 文件包含多个字符串表，存放段名和存放符号名的字符串表不是同一个。 其他 ELF 结构包含字符串时，只需提供一个所属字符串表中的索引值。 下面是 libfoo.so 文件的一个字符串表一部分的 16 进制视图，字符串表的第一个字节是 \\0： 123456789 00 2E 73 68 73 74 72 74 . s h s t r t61 62 00 2E 6E 6F 74 65 2E 61 6E 64 72 6F 69 64 a b . n o t e . a n d r o i d2E 69 64 65 6E 74 00 2E 6E 6F 74 65 2E 67 6E 75 . i d e n t . n o t e . g n u2E 62 75 69 6C 64 2D 69 64 00 2E 64 79 6E 73 79 . b u i l d - i d . d y n s y6D 00 2E 64 79 6E 73 74 72 00 2E 67 6E 75 2E 68 m . d y n s t r . g n u . h61 73 68 00 2E 67 6E 75 2E 76 65 72 73 69 6F 6E a s h . g n u . v e r s i o n00 2E 67 6E 75 2E 76 65 72 73 69 6F 6E 5F 64 00 . g n u . v e r s i o n _ d 2E 67 6E 75 2E 76 65 72 73 69 6F 6E 5F 72 00 2E . g n u . v e r s i o n _ r .72 65 6C 2E 64 79 6E 00 2E 72 65 6C 2E 70 6C 74 r e l . d y n . r e l . p l t 使用 readelf 工具解析 libfoo.so 的 .shstrtab 字符串表如下： 12345678910111213141516171819202122232425String dump of section '.shstrtab': [ 1] .shstrtab [ b] .note.android.ident [ 1f] .note.gnu.build-id [ 32] .dynsym [ 3a] .dynstr [ 42] .gnu.hash [ 4c] .gnu.version [ 59] .gnu.version_d [ 68] .gnu.version_r [ 77] .rel.dyn [ 80] .rel.plt [ 89] .text [ 8f] .ARM.exidx [ 9a] .ARM.extab [ a5] .rodata [ ad] .fini_array [ b9] .data.rel.ro [ c6] .dynamic [ cf] .got [ d4] .data [ da] .bss [ df] .comment [ e8] .note.gnu.gold-version [ ff] .ARM.attributes 程序表结构ELF 文件的段分为两种模式，一种是 ELF 文件被链接之前，就是被加载到内存空间之前，ELF 文件中的段使用 Section 描述，也可以称为 ‘节’；另一种是 ELF 文件被链接后，整个 ELF 文件将被加载到内存中，这时 ELF 文件中的段使用 Segment 描述，程序表就是专门用于保存 Segment 信息的列表，用于初始化链接后的内存中的 Segment。 每个程序表结构使用一个 Elf32_Phdr 结构体描述： 12345678910struct Elf32_Phdr { Elf32_Word p_type; // 段类型 Elf32_Off p_offset; // 段在文件中的偏移 Elf32_Addr p_vaddr; // 段的第一个字节在虚拟地址空间的起始位置，整个程序表头中 Elf32_Addr p_paddr; // 段的物理装载地址，即 LMA（Load Memory Address），一般情况下 p_paddr 和 p_vaddr 是相同的 Elf32_Word p_filesz; // 段在 ELF 文件中所占空间的长度，可能为 0 Elf32_Word p_memsz; // 段在进程虚拟空间中所占空间的长度，可能为 0 Elf32_Word p_flags; // 段的权限属性，比如可读 &quot;R&quot;，可写 &quot;W&quot; 和可执行 &quot;X&quot; Elf32_Word p_align; // 段的对齐属性，实际对齐字节等于 2 的 p_align 次方}; 使用 readelf 工具解析 libfoo.so 程序表结果如下： 12345678910Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x00000034 0x00000034 0x00100 0x00100 R 0x4 LOAD 0x000000 0x00000000 0x00000000 0x02de7 0x02de7 R E 0x1000 LOAD 0x002e08 0x00003e08 0x00003e08 0x00204 0x00209 RW 0x1000 DYNAMIC 0x002e58 0x00003e58 0x00003e58 0x00110 0x00110 RW 0x4 NOTE 0x000134 0x00000134 0x00000134 0x000bc 0x000bc R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 EXIDX 0x002630 0x00002630 0x00002630 0x001a0 0x001a0 R 0x4 GNU_RELRO 0x002e08 0x00003e08 0x00003e08 0x001f8 0x001f8 RW 0x4 符号表结构ELF 文件有一个相应的符号表（Symbol Table），每一个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于函数和变量来说，就是它们的地址。 符号表中的所有符号分为如下几类： 定义在本目标文件的全局符号，可被其他目标文件引用； 定义在本目标文件的全局符号，却没有定义在目标文件，一般叫做外部符号（External Symbol），也就是符号引用，例如“printf”； 段名，这种符号往往由编译器产生，它的值就是该段的起始地址； 局部符号，这种符号只在编译单元内部可见，对于链接过程没有作用，调试器可以使用这些符号来分析程序或崩溃时的核心转储文件； 行号信息，即目标文件指令与源代码中代码行的对应关系，它也是可选的。 符号表存在于 .symtab 段和 .dynsym 段，前者包含 ELF 文件中所有符号，后者包含动态符号（只是动态链接相关的导入导出符号，不包含 ELF 内部符号）。 在使用 NDK 编译 so 文件时，如果以 release 模式编译，会被 strip 工具优化，so 文件将被去除内部符号表，那么就只留下 .dynsym 段。 符号表中每个符号使用 Elf32_Sym 结构体描述： 12345678struct Elf32_Sym { Elf32_Word st_name; // 符号名字，包含了该符号名在字符串表中的下标 Elf32_Addr st_value; // 符号相对应的值，是一个绝对值，或地址等。不同的符号，含义不同 Elf32_Word st_size; // 符号的大小 unsigned char st_info; // 符号的类型和绑定信息 unsigned char st_other; // 目前为 0，保留 Elf32_Half st_shndx; // 符号所在段的下标}; st_info（符号类型和绑定信息） 该成员低 4 位表示符号的类型（Symbol Type），高 28 位表示符号绑定信息（Symbol Binding）。 符号绑定信息常见值： 宏定义名 值 说明 STB_LOCAL 0 局部符号，对于目标文件的外部不可见 STB_GLOBAL 1 全局符号，外部可见 STB_WEAK 2 弱引用 符号类型常见值： 宏定义名 值 说明 STT_NOTYPE 0 未知类型符号 STT_OBJECT 1 该符号是一个数据对象，比如变量、数组等 STT_FUNC 2 该符号是一个函数或其他可执行代码 STT_SECTION 3 该符号表示一个段，这种符号必须是 STB_LOCAL 的 STT_FILE 4 该符号表示文件名，一般都是该目标文件所对应的源文件名，它一定是 STB_LOCAL 类型的，并且它的 st_shndx 一定是系统 SHN_ABS st_shndx（符号所在段） 如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标，如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx 值为特殊变量。 常见特殊变量如下： 宏定义名 值 说明 SHN_ABS 0xfff1 表示该符号包含了一个绝对的值。比如文件名的符号类型就是这种 SHN_COMMON 0xff2 表示该符号是一个“COMMON 块”类型的符号，一般来说，未初始化的全局符号定义就是这种类型的，比如 SimpleSection.o 里面的 global_uninit_var SHN_UNDEF 0 表示该符号未定义，这个符号表示该符号在本目标文件中被引用，但是定义在其他目标文件中 st_value（符号值） 有如下几种情况： 在目标文件中，如果是符号的定义并且该符号不是“COMMON 块”类型的，则表示该符号在段中的偏移。即符号所对应的变量或函数位于 sh_shndx 指定的段，偏移 st_value 的位置。 在目标文件中，如果符号是“COMMON 块”类型的，则 st_value 表示该符号的对齐属性。 在可执行文件中，st_value 表示符号的虚拟地址。这个虚拟地址对于动态链接器十分有用。 使用 readelf 工具解析 libfoo.so 符号表结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Symbol table '.dynsym' contains 53 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 FUNC GLOBAL DEFAULT UND __cxa_atexit@LIBC (2) 2: 00000000 0 FUNC GLOBAL DEFAULT UND __cxa_finalize@LIBC (2) 3: 00000000 0 FUNC GLOBAL DEFAULT UND dladdr@LIBC (3) 4: 00000000 0 FUNC GLOBAL DEFAULT UND snprintf@LIBC (2) 5: 00000000 0 FUNC GLOBAL DEFAULT UND printf@LIBC (2) 6: 00000000 0 OBJECT GLOBAL DEFAULT UND __sF@LIBC (2) 7: 00000000 0 FUNC GLOBAL DEFAULT UND __stack_chk_fail@LIBC (2) 8: 00000000 0 OBJECT GLOBAL DEFAULT UND __stack_chk_guard@LIBC (2) 9: 00000000 0 FUNC GLOBAL DEFAULT UND abort@LIBC (2) 10: 00000000 0 FUNC GLOBAL DEFAULT UND fflush@LIBC (2) 11: 00000000 0 FUNC GLOBAL DEFAULT UND fprintf@LIBC (2) 12: 00000000 0 FUNC GLOBAL DEFAULT UND __aeabi_memclr8 13: 00000000 0 FUNC GLOBAL DEFAULT UND __aeabi_memcpy 14: 00000000 0 FUNC GLOBAL DEFAULT UND __gnu_Unwind_Find_exidx 15: 00001a37 6 FUNC GLOBAL DEFAULT 13 unw_save_vfp_as_X 16: 00000ffd 80 FUNC GLOBAL DEFAULT 13 decode_eht_entry 17: 00001561 8 FUNC GLOBAL DEFAULT 13 __aeabi_unwind_cpp_pr0 18: 00000fdd 32 FUNC GLOBAL DEFAULT 13 Java_io_l0neman_nativetpr 19: 00001599 8 FUNC GLOBAL DEFAULT 13 __aeabi_unwind_cpp_pr1 20: 00001761 2 FUNC GLOBAL DEFAULT 13 _Unwind_Complete 21: 000015a1 8 FUNC GLOBAL DEFAULT 13 __aeabi_unwind_cpp_pr2 22: 00001854 0 FUNC GLOBAL DEFAULT 13 unw_getcontext 23: 00001765 104 FUNC GLOBAL DEFAULT 13 _Unwind_Resume 24: 0000104d 620 FUNC GLOBAL DEFAULT 13 _Unwind_VRS_Interpret 25: 00004004 4 OBJECT GLOBAL DEFAULT 21 global_init_var 26: 000019c3 32 FUNC GLOBAL DEFAULT 13 unw_get_proc_info 27: 00001a2b 12 FUNC GLOBAL DEFAULT 13 unw_is_signal_frame 28: 0000400c 4 OBJECT GLOBAL DEFAULT 22 global_uninit_var 29: 00001411 336 FUNC GLOBAL DEFAULT 13 _Unwind_VRS_Pop 30: 00004008 4 OBJECT GLOBAL DEFAULT 21 unw_local_addr_space 31: 00001981 60 FUNC GLOBAL DEFAULT 13 unw_set_fpreg 32: 000019bd 6 FUNC GLOBAL DEFAULT 13 unw_step 33: 000015a9 160 FUNC GLOBAL DEFAULT 13 _Unwind_RaiseException 34: 000012b9 172 FUNC GLOBAL DEFAULT 13 _Unwind_VRS_Get 35: 000019e5 20 FUNC GLOBAL DEFAULT 13 unw_resume 36: 00001841 18 FUNC GLOBAL DEFAULT 13 __gnu_unwind_frame 37: 00001885 72 FUNC GLOBAL DEFAULT 13 unw_init_local 38: 0000400c 0 NOTYPE GLOBAL DEFAULT ABS __bss_start 39: 00004011 0 NOTYPE GLOBAL DEFAULT ABS _end 40: 00001901 72 FUNC GLOBAL DEFAULT 13 unw_set_reg 41: 00000fd1 12 FUNC GLOBAL DEFAULT 13 _Z4testv 42: 000017cd 52 FUNC GLOBAL DEFAULT 13 _Unwind_GetLanguageSpecif 43: 00001949 56 FUNC GLOBAL DEFAULT 13 unw_get_fpreg 44: 00001365 172 FUNC GLOBAL DEFAULT 13 _Unwind_VRS_Set 45: 0000400c 0 NOTYPE GLOBAL DEFAULT ABS _edata 46: 00001835 12 FUNC GLOBAL DEFAULT 13 _Unwind_DeleteException 47: 00001a19 12 FUNC GLOBAL DEFAULT 13 unw_is_fpreg 48: 000018cd 52 FUNC GLOBAL DEFAULT 13 unw_get_reg 49: 00001a25 6 FUNC GLOBAL DEFAULT 13 unw_regname 50: 00000fc1 16 FUNC GLOBAL DEFAULT 13 _Z5func1i 51: 00001801 52 FUNC GLOBAL DEFAULT 13 _Unwind_GetRegionStart 52: 000019f9 32 FUNC GLOBAL DEFAULT 13 unw_get_proc_name 重定位表结构如果 ELF 文件中有需要被重定位的地方，例如“.text”段，那么会有一个相对应的“.rel.text”段保存“.text”段的重定位表。 重定位表的每一个元素使用 Elf32_Rel 结构体表示 1234struct Elf32_Rel { Elf32_Addr r_offset; Elf32_Word r_info;}; 成员 含义 r_offset 重定位入口的偏移。对于可重定位文件来说，这个值是该可重定位入口所要修正的位置的第一个字节相对于段起始的偏移；对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址。 r_info 重定位入口的类型和符号。这个成员的低 8 位表示重定位入口的类型，高 24 位表示重定位入口的符号在符号表中下标。因为各个处理器的指令格式不一样，所以重定位所修正的地址格式也不一样，每种处理器都有自己一套重定位入口的类型，对于可执行文件和共享对象文件来说，它们的重定位入口是动态链接类型的。 使用 readelf 工具查看 libfoo.so 中的 rel.dyn 和 rel.plt 重定位表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Relocation section '.rel.dyn' at offset 0xc48 contains 25 entries: Offset Info Type Sym.Value Sym. Name00003e08 00000017 R_ARM_RELATIVE00003e0c 00000017 R_ARM_RELATIVE00003e18 00000017 R_ARM_RELATIVE00003e1c 00000017 R_ARM_RELATIVE00003e20 00000017 R_ARM_RELATIVE00003e24 00000017 R_ARM_RELATIVE00003e28 00000017 R_ARM_RELATIVE00003e2c 00000017 R_ARM_RELATIVE00003e30 00000017 R_ARM_RELATIVE00003e34 00000017 R_ARM_RELATIVE00003e38 00000017 R_ARM_RELATIVE00003e3c 00000017 R_ARM_RELATIVE00003e40 00000017 R_ARM_RELATIVE00003e44 00000017 R_ARM_RELATIVE00003e48 00000017 R_ARM_RELATIVE00003e4c 00000017 R_ARM_RELATIVE00003e50 00000017 R_ARM_RELATIVE00003e54 00000017 R_ARM_RELATIVE00004000 00000017 R_ARM_RELATIVE00004008 00000017 R_ARM_RELATIVE00003f6c 00000615 R_ARM_GLOB_DAT 00000000 __sF@LIBC00003f68 00000815 R_ARM_GLOB_DAT 00000000 __stack_chk_guard@LIBC00003f74 00001115 R_ARM_GLOB_DAT 00001561 __aeabi_unwind_cpp_pr000003f70 00001315 R_ARM_GLOB_DAT 00001599 __aeabi_unwind_cpp_pr100003f78 00001515 R_ARM_GLOB_DAT 000015a1 __aeabi_unwind_cpp_pr2Relocation section '.rel.plt' at offset 0xd10 contains 30 entries: Offset Info Type Sym.Value Sym. Name00003f88 00000216 R_ARM_JUMP_SLOT 00000000 __cxa_finalize@LIBC00003f8c 00000116 R_ARM_JUMP_SLOT 00000000 __cxa_atexit@LIBC00003f90 00000516 R_ARM_JUMP_SLOT 00000000 printf@LIBC00003f94 00003216 R_ARM_JUMP_SLOT 00000fc1 _Z5func1i00003f98 00002916 R_ARM_JUMP_SLOT 00000fd1 _Z4testv00003f9c 00003016 R_ARM_JUMP_SLOT 000018cd unw_get_reg00003fa0 00001d16 R_ARM_JUMP_SLOT 00001411 _Unwind_VRS_Pop00003fa4 00002816 R_ARM_JUMP_SLOT 00001901 unw_set_reg00003fa8 00002216 R_ARM_JUMP_SLOT 000012b9 _Unwind_VRS_Get00003fac 00000716 R_ARM_JUMP_SLOT 00000000 __stack_chk_fail@LIBC00003fb0 00000f16 R_ARM_JUMP_SLOT 00001a37 unw_save_vfp_as_X00003fb4 00002b16 R_ARM_JUMP_SLOT 00001949 unw_get_fpreg00003fb8 00000b16 R_ARM_JUMP_SLOT 00000000 fprintf@LIBC00003fbc 00000a16 R_ARM_JUMP_SLOT 00000000 fflush@LIBC00003fc0 00000916 R_ARM_JUMP_SLOT 00000000 abort@LIBC00003fc4 00001f16 R_ARM_JUMP_SLOT 00001981 unw_set_fpreg00003fc8 00002c16 R_ARM_JUMP_SLOT 00001365 _Unwind_VRS_Set00003fcc 00002a16 R_ARM_JUMP_SLOT 000017cd _Unwind_GetLanguageSpe00003fd0 00002016 R_ARM_JUMP_SLOT 000019bd unw_step00003fd4 00001616 R_ARM_JUMP_SLOT 00001854 unw_getcontext00003fd8 00002516 R_ARM_JUMP_SLOT 00001885 unw_init_local00003fdc 00001a16 R_ARM_JUMP_SLOT 000019c3 unw_get_proc_info00003fe0 00002316 R_ARM_JUMP_SLOT 000019e5 unw_resume00003fe4 00000d16 R_ARM_JUMP_SLOT 00000000 __aeabi_memcpy00003fe8 00000c16 R_ARM_JUMP_SLOT 00000000 __aeabi_memclr800003fec 00001016 R_ARM_JUMP_SLOT 00000ffd decode_eht_entry00003ff0 00001816 R_ARM_JUMP_SLOT 0000104d _Unwind_VRS_Interpret00003ff4 00000316 R_ARM_JUMP_SLOT 00000000 dladdr@LIBC00003ff8 00000416 R_ARM_JUMP_SLOT 00000000 snprintf@LIBC00003ffc 00000e16 R_ARM_JUMP_SLOT 00000000 __gnu_Unwind_Find_exid 其他结构上面是 ELF 文件的标准段，它们具有标准的结构定义，下面是一些其他常见段的作用和内容。 .text 代码段，.text 段用于存放编译出来的机器代码指令。 下面是 libfoo.so 中 Java_io_l0neman_nativetproject_NativeHandler_getHello 函数在 .text 段中的内容： 12345678910111213地址 16 进制值 汇编指令.text:00000FDC D0 B5 PUSH {R4,R6,R7,LR}.text:00000FDE 02 AF ADD R7, SP, #8.text:00000FE0 04 46 MOV R4, R0.text:00000FE2 FF F7 30 EF BLX j__Z4testv ; test(void).text:00000FE6 20 68 LDR R0, [R4].text:00000FE8 03 49 LDR R1, =(aHello - 0xFF2).text:00000FEA D0 F8 9C 22 LDR.W R2, [R0,#0x29C].text:00000FEE 79 44 ADD R1, PC ; &quot;hello&quot;.text:00000FF0 20 46 MOV R0, R4.text:00000FF2 BD E8 D0 40 POP.W {R4,R6,R7,LR}.text:00000FF6 10 47 BX R2 .got GOT 是 ELF 文件中的全局偏移表（Global Offset Table，GOT），用于存放全局符号地址。 在动态链接的情况下，对于横跨不同模块的全局符号地址要等到模块装载时才能确认，为了实现地址无关代码（PIC，Position-independent Code），需要将符号地址放入数据段，建立一个存放这些全局符号的数组结构，就是 GOT 结构，代码中访问这些全局符号的地址将是在 GOT 结构中的偏移，等到装载完毕，这些符号地址被确认后会被填入 GOT 中，此时代码执行时通过 GOT 表中对应符号的偏移即可获取对应符号的地址，此时代码段可被多个进程共享，从而实现地址无关代码。 下面是截取 libfoo.so 文件 .got 段中的内容： 123456地址 16 进制值 符号 汇编指令.got:00003FB8 3C 40 00 00 fprintf_ptr DCD __imp_fprintf.got:00003FBC 38 40 00 00 fflush_ptr DCD __imp_fflush.got:00003FC0 34 40 00 00 abort_ptr DCD __imp_abort.got:00003FC4 81 19 00 00 unw_set_fpreg_ptr DCD unw_set_fpreg+1 .plt .plt 是用于存放 PLT 的代码项表，PLT（Procedure Linkage Table）是一种用于实现延迟绑定（Lazy Binding）的方法。 为了提高动态链接重定位的效率，避免将所有函数地址一次性重定位，ELF 采用了延迟绑定的做法，就是当函数第一次被用到时才进行绑定（符号查找和重定位），.plt 段就是为了存放每个全局函数处理延迟绑定的一段代码。 .got.plt ELF 将 GOT 拆分成了两个表，叫做 .got 和 .got.plt，其中 .got 用来保存全局变量引用的地址，.got.plt 用来保存全局函数的引用。 .got.plt 的前三项具有特殊含义： 第一项保存的是 .dynamic 段的地址，这个段描述了本模块动态链接相关的信息； 第二项保存的是本模块的 ID； 第三项保存的是 _dl_runtime_resolve() 的地址。 解析代码到这里完成了 ELF 文件结构的分析，下面使用 C++ 代码对上述主要结构进行手动解析。 定义 ElfParser 类，支持 32 位和 64 位的 ELF 文件解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class ElfParser{public: ElfParser(); explicit ElfParser(char const* elf_file); ~ElfParser(); void parse(); // 开始解析private: FILE* elf_file_; // ELF 文件指针 uint8_t elf_bit_; // 32 位或 64 位 Elf32_Ehdr elf_header32_{}; // ELF 头结构 Elf64_Ehdr elf_header64_{}; Elf32_Phdr* program_header32_list_; // ELF Program Header Table Elf64_Phdr* program_header64_list_; // （程序头表） Elf32_Shdr* section_header32_list_; // ELF Section Header Table Elf64_Shdr* section_header64_list_; // （段描述表） char* string_table_; // .shstrtab 字符串表 char* symbol_string_table_; // .dynstr 符号字符串表 Elf32_Sym* symbol32_list_; // ELF Symbol Table Elf64_Sym* symbol64_list_; // （符号表） Elf32_Rel* relocation32_list_; // ELF Relocation Table Elf64_Rel* relocation64_list_; // （重定位表） bool check_elf(); void parse_elf_header(); void parse_section_header_list(); void parse_string_table(); void print_section_header_list() const; void parse_symbol_string_table(); void parse_program_header_list(); void parse_section_list(); void parse_symbol_table(long offset, size_t size); void parse_relocation_table(long offset, size_t size); const char* get_string_from_string_table(size_t offset) const; const char* get_string_from_symbol_string_table(size_t offset) const;};#endif // ELF_PARSER_H 打开 ELF 文件首先打开 ELF 文件，将文件指针保存起来用于解析其他结构。 123456789ElfParser::ElfParser(char const* elf_file){ // ... const auto f = fopen_s(&amp;this-&gt;elf_file_, elf_file, &quot;rb&quot;); printf(&quot;open elf file: %s\\n\\n&quot;, elf_file); if (f != 0 || this-&gt;elf_file_ == nullptr) printf(&quot;open elf file error: %s\\n&quot;, elf_file);} 检查 ELF 文件通过对比 ELF 魔数，检查是否为 ELF 格式，同时了解 ELF 位数以及大小段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static constexpr char ElfMagic[] = { 0x7f, 'E', 'L', 'F', '\\0' };bool ElfParser::check_elf(){ unsigned char elf_ident[16] = { 0 }; if (0 == fread(elf_ident, sizeof(char), 16, this-&gt;elf_file_)) { printf(&quot;check elf error: read error&quot;); return false; } if (memcmp(elf_ident, ElfMagic, strlen(ElfMagic)) != 0) return false; char elf_type[10] = &quot;ERROR&quot;; // 确定 ELF 文件位数 switch (elf_ident[4]) { case ELFCLASSNONE: strcpy_s(elf_type, &quot;invalid&quot;); break; case ELFCLASS32: strcpy_s(elf_type, &quot;ELF32&quot;); this-&gt;elf_bit_ = 32; break; case ELFCLASS64: strcpy_s(elf_type, &quot;ELF64&quot;); this-&gt;elf_bit_ = 64; break; default: break; } printf(&quot;Class: \\t\\t%s\\n&quot;, elf_type); char elf_order[15] = &quot;ERROR&quot;; // ELF 文件大小端 switch (elf_ident[5]) { case ELFDATANONE: strcpy_s(elf_order, &quot;invalid&quot;); break; case ELFDATA2LSB: strcpy_s(elf_order, &quot;little endian&quot;); break; case ELFDATA2MSB: strcpy_s(elf_order, &quot;big endian&quot;); break; default: break; } printf(&quot;Order: \\t\\t%s\\n&quot;, elf_order); return true;} 解析 ELF 头部结构使用模板对 32 位和 64 位头 ELF 结构进行打印。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void ElfParser::parse_elf_header(){ if (0 != fseek(this-&gt;elf_file_, 0, 0)) { printf(&quot;#parse_elf_header - seek file error.\\n&quot;); return; } void* elf_header = nullptr; size_t elf_header_size = 0; if (this-&gt;elf_bit_ == 32) { elf_header = &amp;this-&gt;elf_header32_; elf_header_size = sizeof(Elf32_Ehdr); } else // this-&gt;elf_bit_ == 64 { elf_header = &amp;this-&gt;elf_header64_; elf_header_size = sizeof(Elf64_Ehdr); } if (0 == fread(elf_header, elf_header_size, 1, this-&gt;elf_file_)) { printf(&quot;parse elf header%d error.\\n&quot;, this-&gt;elf_bit_); return; } if (this-&gt;elf_bit_ == 32) print_elf_header(&amp;this-&gt;elf_header32_, 32); else // this-&gt;elf_bit_ == 64 print_elf_header(&amp;this-&gt;elf_header64_, 64);}template &lt;typename T = Elf32_Ehdr&gt;void print_elf_header(T* header, const uint8_t bit){ printf(&quot;ident: \\t\\t&quot;); Printer::print_char_array(header-&gt;e_ident, 16); printf(&quot;type: \\t\\t%u\\n&quot;, header-&gt;e_type); printf(&quot;machine: \\t%u\\n&quot;, header-&gt;e_machine); printf(&quot;version: \\t%u\\n&quot;, header-&gt;e_version); if (bit == 32) { printf(&quot;entry: \\t\\t%u\\n&quot;, header-&gt;e_entry); printf(&quot;phoff: \\t\\t%u\\n&quot;, header-&gt;e_phoff); printf(&quot;shoff: \\t\\t%u\\n&quot;, header-&gt;e_shoff); } else // bit == 64 { printf(&quot;entry: \\t\\t%llu\\n&quot;, header-&gt;e_entry); printf(&quot;phoff: \\t\\t%llu\\n&quot;, header-&gt;e_phoff); printf(&quot;shoff: \\t\\t%llu\\n&quot;, header-&gt;e_shoff); } printf(&quot;flags: \\t\\t0x%x\\n&quot;, header-&gt;e_flags); printf(&quot;ehsize: \\t%u\\n&quot;, header-&gt;e_ehsize); printf(&quot;phentsize: \\t%u\\n&quot;, header-&gt;e_phentsize); printf(&quot;phnum: \\t\\t%u\\n&quot;, header-&gt;e_phnum); printf(&quot;shentsize: \\t%u\\n&quot;, header-&gt;e_shentsize); printf(&quot;shnum: \\t\\t%u\\n&quot;, header-&gt;e_shnum); printf(&quot;shstrndx: \\t%u\\n&quot;, header-&gt;e_shstrndx);} 解析段描述表结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546void ElfParser::parse_section_header_list(){ printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse section header list &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); long section_header_offset = 0; size_t section_header_count = 0; size_t section_header_size = 0; void* section_header_list = nullptr; if (this-&gt;elf_bit_ == 32) { section_header_offset = this-&gt;elf_header32_.e_shoff; section_header_count = this-&gt;elf_header32_.e_shnum; section_header_size = sizeof(Elf32_Shdr); this-&gt;section_header32_list_ = new Elf32_Shdr[section_header_count]; section_header_list = this-&gt;section_header32_list_; printf(&quot;section header offset: \\t%u\\n&quot;, this-&gt;elf_header32_.e_shoff); printf(&quot;section header size: \\t%u\\n&quot;, this-&gt;elf_header32_.e_shnum); } else // this-&gt;elf_bit_ == 64 { section_header_offset = this-&gt;elf_header64_.e_shoff; section_header_count = this-&gt;elf_header64_.e_shnum; section_header_size = sizeof(Elf64_Shdr); this-&gt;section_header64_list_ = new Elf64_Shdr[section_header_count]; section_header_list = this-&gt;section_header64_list_; printf(&quot;section header offset: \\t%llu\\n&quot;, this-&gt;elf_header64_.e_shoff); printf(&quot;section header size: \\t%u\\n&quot;, this-&gt;elf_header64_.e_shnum); } if (0 != fseek(this-&gt;elf_file_, section_header_offset, 0)) { printf(&quot;#parse_section_header - seek file error.\\n&quot;); return; } if (0 == fread(section_header_list, section_header_size, section_header_count, this-&gt;elf_file_)) { printf(&quot;parse section header%d error.\\n&quot;, this-&gt;elf_bit_); return; }} 解析字符串表字符串表就是一段字节，直接存放起来，使用偏移进行访问即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void ElfParser::parse_string_table(){ printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse string table &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); // for .shstrtab; size_t offset; size_t size; if (this-&gt;elf_bit_ == 32) { // 字符串表下标 const auto str_table_index = this-&gt;elf_header32_.e_shstrndx; const auto&amp; section_header = this-&gt;section_header32_list_[str_table_index]; offset = section_header.sh_offset; size = section_header.sh_size; } else // this-&gt;elf_bit_ == 64 { const auto str_table_index = this-&gt;elf_header64_.e_shstrndx; const auto&amp; section_header = this-&gt;section_header64_list_[str_table_index]; offset = section_header.sh_offset; size = section_header.sh_size; } if (0 != fseek(this-&gt;elf_file_, offset, 0)) { printf(&quot;#parse_string_table - seek file error.\\n&quot;); return; } this-&gt;string_table_ = new char[size]; if (0 == fread(this-&gt;string_table_, size, 1, this-&gt;elf_file_)) { printf(&quot;parse string table%d error.\\n&quot;, this-&gt;elf_bit_); return; } size_t string_count = 0; for (size_t i = 0; i &lt; size; i++) { if (this-&gt;string_table_[i] == 0 &amp;&amp; i != (size - 1)) { const auto off = i + 1; const auto* str = get_string_from_string_table(off); const auto len = strlen(str); printf(&quot;str[%llu] \\tlen: %llu, s: %s\\n&quot;, off, len, str); string_count++; } } printf(&quot;string count: %llu\\n&quot;, string_count);} 字符串表解析后，其他结构中有字符串字段就可以使用偏移直接访问对应的字符串了。 1234const char* ElfParser::get_string_from_string_table(const size_t offset) const{ return &amp;this-&gt;string_table_[offset];} 打印段描述表结构段描述表这里放在解析完字符串表后进行打印，因为此时可以打印出段名，更直观。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void ElfParser::print_section_header_list() const{#ifdef _PRINT_SECTION_HEADER_LIST_ size_t section_header_count = 0; if (this-&gt;elf_bit_ == 32) section_header_count = this-&gt;elf_header32_.e_shnum; else // this-&gt;elf_bit_ == 64 section_header_count = this-&gt;elf_header64_.e_shnum; for (size_t i = 0; i &lt; section_header_count; i++) { printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse section header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); printf(&quot;index: \\t\\t%llu\\n&quot;, i); if (this-&gt;elf_bit_ == 32) { printf(&quot;name: \\t\\t%s\\n\\n&quot;, get_string_from_string_table(this-&gt;section_header32_list_[i].sh_name)); print_section_header(&amp;this-&gt;section_header32_list_[i], this-&gt;elf_bit_); } else // this-&gt;elf_bit_ == 64 { printf(&quot;name: \\t\\t%s\\n\\n&quot;, get_string_from_string_table(this-&gt;section_header64_list_[i].sh_name)); print_section_header(&amp;this-&gt;section_header64_list_[i], this-&gt;elf_bit_); } }#endif // _PRINT_SECTION_HEADER_LIST_}template &lt;typename T = Elf32_Shdr&gt;static void print_section_header(T* header, const uint8_t bit){#ifdef _PRINT_SECTION_HEADER_LIST_ printf(&quot;sh_name: \\t%u\\n&quot;, header-&gt;sh_name); printf(&quot;sh_type: \\t0x%x\\n&quot;, header-&gt;sh_type); printf(&quot;sh_link: \\t%u\\n&quot;, header-&gt;sh_link); printf(&quot;sh_info: \\t%u\\n&quot;, header-&gt;sh_info); if (bit == 32) { printf(&quot;sh_flags: \\t%u\\n&quot;, header-&gt;sh_flags); printf(&quot;sh_offset: \\t%u\\n&quot;, header-&gt;sh_offset); printf(&quot;sh_size: \\t%u\\n&quot;, header-&gt;sh_size); printf(&quot;sh_addr: \\t%u\\n&quot;, header-&gt;sh_addr); printf(&quot;sh_addralign: \\t%u\\n&quot;, header-&gt;sh_addralign); printf(&quot;sh_entsize: \\t%u\\n&quot;, header-&gt;sh_entsize); } else // bit == 64 { printf(&quot;sh_flags: \\t%llu\\n&quot;, header-&gt;sh_flags); printf(&quot;sh_offset: \\t%llu\\n&quot;, header-&gt;sh_offset); printf(&quot;sh_size: \\t%llu\\n&quot;, header-&gt;sh_size); printf(&quot;sh_addr: \\t%llu\\n&quot;, header-&gt;sh_addr); printf(&quot;sh_addralign: \\t%llu\\n&quot;, header-&gt;sh_addralign); printf(&quot;sh_entsize: %llu\\n&quot;, header-&gt;sh_entsize); }#endif // _PRINT_PROGRAM_HEADER_LIST_} 解析符号字符串表符号字符串表需要首先从段描述表中查询到 .dynstr 名字得到段偏移和段大小后进行解析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void ElfParser::parse_symbol_string_table(){ printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol string table &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); // for .dynstr size_t offset = 0; size_t size = 0; // 查询 `.dynstr` 段信息 if(this-&gt;elf_bit_ == 32) { for (size_t i = 0; i &lt; this-&gt;elf_header32_.e_shnum; i++) { auto&amp; section_header = this-&gt;section_header32_list_[i]; const auto* section_name = get_string_from_string_table(section_header.sh_name); if(section_header.sh_type == SHT_STRTAB &amp;&amp; strcmp(section_name, &quot;.dynstr&quot;) == 0) { offset = section_header.sh_offset; size = section_header.sh_size; break; } } } else // this-&gt;elf_bit_ == 32 { for (size_t i = 0; i &lt; this-&gt;elf_header64_.e_shnum; i++) { auto&amp; section_header = this-&gt;section_header64_list_[i]; const auto* section_name = get_string_from_string_table(section_header.sh_name); if (section_header.sh_type == SHT_STRTAB &amp;&amp; strcmp(section_name, &quot;.dynstr&quot;) == 0) { offset = section_header.sh_offset; size = section_header.sh_size; break; } } } if(offset == 0 || size == 0) { printf(&quot;error: not found section .dynstr\\n&quot;); return; } if (0 != fseek(this-&gt;elf_file_, offset, 0)) { printf(&quot;#parse_symbol_string_table - seek file error.\\n&quot;); return; } this-&gt;symbol_string_table_ = new char[size]; if (0 == fread(this-&gt;symbol_string_table_, size, 1, this-&gt;elf_file_)) { printf(&quot;parse symbol string table%d error.\\n&quot;, this-&gt;elf_bit_); return; } size_t string_count = 0; for (size_t i = 0; i &lt; size; i++) { if (this-&gt;symbol_string_table_[i] == 0 &amp;&amp; i != (size - 1)) { const auto off = i + 1; const auto* str = get_string_from_symbol_string_table(off); const auto len = strlen(str); printf(&quot;str[%llu] \\tlen: %llu, s: %s\\n&quot;, off, len, str); string_count++; } } printf(&quot;string count: %llu\\n&quot;, string_count);} 和上面字符串表一样，提供一个通过偏移访问的方法，那么符号表可通过此函数查询符号名： 1234const char* ElfParser::get_string_from_string_table(const size_t offset) const{ return &amp;this-&gt;string_table_[offset];} 解析程序头表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586void ElfParser::parse_program_header_list(){ printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse program list &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); long program_header_list_offset = 0; size_t program_header_count = 0; size_t program_header_size = 0; void* program_header_list = nullptr; if (this-&gt;elf_bit_ == 32) { program_header_list_offset = this-&gt;elf_header32_.e_phoff; program_header_count = this-&gt;elf_header32_.e_phnum; program_header_size = sizeof(Elf32_Phdr); this-&gt;program_header32_list_ = new Elf32_Phdr[program_header_count]; program_header_list = this-&gt;program_header32_list_; printf(&quot;program header offset: \\t%u\\n&quot;, this-&gt;elf_header32_.e_phoff); printf(&quot;program header size: \\t%u\\n&quot;, this-&gt;elf_header32_.e_phnum); } else // this-&gt;elf_bit_ == 64 { program_header_list_offset = this-&gt;elf_header64_.e_phoff; program_header_count = this-&gt;elf_header64_.e_phnum; program_header_size = sizeof(Elf64_Phdr); this-&gt;program_header64_list_ = new Elf64_Phdr[program_header_count]; program_header_list = this-&gt;program_header64_list_; printf(&quot;program header offset: \\t%llu\\n&quot;, this-&gt;elf_header64_.e_phoff); printf(&quot;program header size: \\t%u\\n&quot;, this-&gt;elf_header64_.e_phnum); } if (0 != fseek(this-&gt;elf_file_, program_header_list_offset, 0)) { printf(&quot;#parse_program_header_list - seek file error.\\n&quot;); return; } if (0 == fread(program_header_list, program_header_size, program_header_count, this-&gt;elf_file_)) { printf(&quot;parse program header%d error.\\n&quot;, this-&gt;elf_bit_); return; }#ifdef _PRINT_PROGRAM_HEADER_LIST_ for (size_t i = 0; i &lt; program_header_count; i++) { printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse program header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); printf(&quot;index: \\t\\t%llu\\n\\n&quot;, i); if (this-&gt;elf_bit_ == 32) print_program_header(&amp;this-&gt;program_header32_list_[i], this-&gt;elf_bit_); else // this-&gt;elf_bit_ == 64 print_program_header(&amp;this-&gt;program_header64_list_[i], this-&gt;elf_bit_); }#endif // _PRINT_PROGRAM_HEADER_LIST_}template &lt;typename T = Elf32_Phdr&gt;static void print_program_header(T* header, const uint8_t bit){#ifdef _PRINT_PROGRAM_HEADER_LIST_ printf(&quot;p_type: \\t0x%x\\n&quot;, header-&gt;p_type); printf(&quot;p_flags: \\t%u\\n&quot;, header-&gt;p_flags); if (bit == 32) { printf(&quot;p_offset: \\t%u\\n&quot;, header-&gt;p_offset); printf(&quot;p_vaddr: \\t%u\\n&quot;, header-&gt;p_vaddr); printf(&quot;p_paddr: \\t%u\\n&quot;, header-&gt;p_paddr); printf(&quot;p_filesz: \\t%u\\n&quot;, header-&gt;p_filesz); printf(&quot;p_memsz: \\t%u\\n&quot;, header-&gt;p_memsz); printf(&quot;p_align: \\t%u\\n&quot;, header-&gt;p_align); } else // bit == 64 { printf(&quot;p_offset: \\t0x%x\\n&quot;, header-&gt;p_offset); printf(&quot;p_vaddr: \\t%llu\\n&quot;, header-&gt;p_vaddr); printf(&quot;p_paddr: \\t%llu\\n&quot;, header-&gt;p_paddr); printf(&quot;p_filesz: \\t%llu\\n&quot;, header-&gt;p_filesz); printf(&quot;p_memsz: \\t%llu\\n&quot;, header-&gt;p_memsz); printf(&quot;p_align: \\t%llu\\n&quot;, header-&gt;p_align); }#endif // _PRINT_PROGRAM_HEADER_LIST_} 解析段遍历段描述表的过程中可以获取段名、段偏移和段大小信息从而解析 ELF 符号表和 ELF 重定位表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void ElfParser::parse_section_list(){ printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse section list &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); size_t list_len = 0; if (this-&gt;elf_bit_ == 32) list_len = this-&gt;elf_header32_.e_shnum; else // this-&gt;elf_bit_ == 64 list_len = this-&gt;elf_header64_.e_shnum; if (this-&gt;elf_bit_ == 32) { for (size_t i = 0; i &lt; list_len; i++) { auto&amp; section_header = this-&gt;section_header32_list_[i]; printf(&quot;parse section: %s\\n&quot;, get_string_from_string_table(section_header.sh_name)); switch (section_header.sh_type) { case SHT_SYMTAB: break; case SHT_DYNSYM: // 解析符号表 parse_symbol_table(section_header.sh_offset, section_header.sh_size); break; case SHT_REL: // 解析重定位表 parse_relocation_table(section_header.sh_offset, section_header.sh_size); break; default: printf(&quot;ignored.\\n&quot;); break; } } } else // this-&gt;elf_bit_ == 64 { for (size_t i = 0; i &lt; list_len; i++) { auto&amp; section_header = this-&gt;section_header64_list_[i]; printf(&quot;parse section: %s\\n&quot;, get_string_from_string_table(section_header.sh_name)); switch (section_header.sh_type) { case SHT_SYMTAB: break; case SHT_DYNSYM: parse_symbol_table(section_header.sh_offset, section_header.sh_size); break; default: printf(&quot;ignored.\\n&quot;); break; } } }} 解析符号表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void ElfParser::parse_symbol_table(const long offset, const size_t size){ printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol table &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); if (0 != fseek(this-&gt;elf_file_, offset, 0)) { printf(&quot;#parse_symbol_table - seek file error.\\n&quot;); return; } size_t sym_size = 0; size_t sym_count = 0; void* symbol_buffer = nullptr; if (this-&gt;elf_bit_ == 32) { sym_size = sizeof(Elf32_Sym); sym_count = size / sym_size; this-&gt;symbol32_list_ = new Elf32_Sym[sym_count]; symbol_buffer = this-&gt;symbol32_list_; } else // this-&gt;elf_bit_ == 64 { sym_size = sizeof(Elf64_Sym); sym_count = size / sym_size; this-&gt;symbol64_list_ = new Elf64_Sym[sym_count]; symbol_buffer = this-&gt;symbol64_list_; } printf(&quot;symbol count: %llu\\n&quot;, sym_count); if (0 == fread(symbol_buffer, sym_size, sym_count, this-&gt;elf_file_)) { printf(&quot;parse symbol table%d error.\\n&quot;, this-&gt;elf_bit_); return; }#ifdef _PRINT_SYMBOL_TABLE_ for (size_t i = 0; i &lt; sym_count; i++) { printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); printf(&quot;index: %llu\\n&quot;, i); if (this-&gt;elf_bit_ == 32) { auto&amp; symbol = this-&gt;symbol32_list_[i]; printf(&quot;symbol name: %s\\n\\n&quot;, get_string_from_symbol_string_table(symbol.st_name)); print_symbol(&amp;symbol, this-&gt;elf_bit_); } else // this-elf_bit_ == 64 { auto&amp; symbol = this-&gt;symbol64_list_[i]; printf(&quot;symbol name: %s\\n\\n&quot;, get_string_from_symbol_string_table(symbol.st_name)); print_symbol(&amp;symbol, this-&gt;elf_bit_); } }#endif // _PRINT_SYMBOL_TABLE_} 解析重定位表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void ElfParser::parse_relocation_table(const long offset, const size_t size){ printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation table &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); if (0 != fseek(this-&gt;elf_file_, offset, 0)) { printf(&quot;#parse_relocation_table - seek file error.\\n&quot;); return; } size_t rel_size = 0; size_t rel_count = 0; void* rel_buffer = nullptr; if (this-&gt;elf_bit_ == 32) { rel_size = sizeof(Elf32_Rel); rel_count = size / rel_size; this-&gt;relocation32_list_ = new Elf32_Rel[rel_count]; rel_buffer = this-&gt;relocation32_list_; } else // this-&gt;elf_bit_ == 64 { rel_size = sizeof(Elf64_Rel); rel_count = size / rel_size; this-&gt;relocation64_list_ = new Elf64_Rel[rel_count]; rel_buffer = this-&gt;relocation64_list_; } printf(&quot;relocation entries count: %llu\\n&quot;, rel_count); if (0 == fread(rel_buffer, rel_size, rel_count, this-&gt;elf_file_)) { printf(&quot;parse relocation table%d error.\\n&quot;, this-&gt;elf_bit_); return; }#ifdef _PRINT_RELOCATION_TABLE for (size_t i = 0; i &lt; rel_count; i++) { printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation entry &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n\\n&quot;); printf(&quot;index: %llu\\n\\n&quot;, i); if (this-&gt;elf_bit_ == 32) { auto&amp; relocation = this-&gt;relocation32_list_[i]; printf(&quot;r_offset: \\t%u\\n&quot;, relocation.r_offset); printf(&quot;r_info: \\t%u\\n&quot;, relocation.r_info); } else // this-elf_bit_ == 64 { auto&amp; relocation = this-&gt;relocation64_list_[i]; printf(&quot;r_offset: \\t%llu\\n&quot;, relocation.r_offset); printf(&quot;r_info: \\t%llu\\n&quot;, relocation.r_info); } }#endif // _PRINT_RELOCATION_TABLE} 测试对 armeabi-v7a 架构的 libfoo.so 文件进行解析： 1234567int main(){ cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl; ElfParser elf_parser(R&quot;(..\\..\\..\\file\\armeabi-v7a\\libfoo.so)&quot;); elf_parser.parse(); return 0;} 结果如下（省略部分过长内容）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398Hello World!open elf file: ..\\..\\..\\file\\armeabi-v7a\\libfoo.so&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse elf header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;Class: ELF32Order: little endianident: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00type: 3machine: 40version: 1entry: 0phoff: 52shoff: 12920flags: 0x5000200ehsize: 52phentsize: 32phnum: 8shentsize: 40shnum: 27shstrndx: 26&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse section header list &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;section header offset: 12920section header size: 27&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse string table &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;str[1] len: 9, s: .shstrtabstr[11] len: 19, s: .note.android.identstr[31] len: 18, s: .note.gnu.build-idstr[50] len: 7, s: .dynsymstr[58] len: 7, s: .dynstrstr[66] len: 9, s: .gnu.hashstr[76] len: 12, s: .gnu.versionstr[89] len: 14, s: .gnu.version_dstr[104] len: 14, s: .gnu.version_rstr[119] len: 8, s: .rel.dynstr[128] len: 8, s: .rel.pltstr[137] len: 5, s: .textstr[143] len: 10, s: .ARM.exidxstr[154] len: 10, s: .ARM.extabstr[165] len: 7, s: .rodatastr[173] len: 11, s: .fini_arraystr[185] len: 12, s: .data.rel.rostr[198] len: 8, s: .dynamicstr[207] len: 4, s: .gotstr[212] len: 5, s: .datastr[218] len: 4, s: .bssstr[223] len: 8, s: .commentstr[232] len: 22, s: .note.gnu.gold-versionstr[255] len: 15, s: .ARM.attributesstring count: 24&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse section header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 0name:sh_name: 0sh_type: 0x0sh_link: 0sh_info: 0sh_flags: 0sh_offset: 0sh_size: 0sh_addr: 0sh_addralign: 0sh_entsize: 0&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse section header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;省略（1~24）……&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse section header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 25name: .ARM.attributessh_name: 255sh_type: 0x70000003sh_link: 0sh_info: 0sh_flags: 0sh_offset: 12596sh_size: 52sh_addr: 0sh_addralign: 1sh_entsize: 0&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse section header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 26name: .shstrtabsh_name: 1sh_type: 0x3sh_link: 0sh_info: 0sh_flags: 0sh_offset: 12648sh_size: 271sh_addr: 0sh_addralign: 1sh_entsize: 0&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol string table &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;str[1] len: 12, s: __cxa_atexitstr[14] len: 4, s: LIBCstr[19] len: 7, s: libc.sostr[27] len: 9, s: libfoo.sostr[37] len: 14, s: __cxa_finalizestr[52] len: 53, s: Java_io_l0neman_nativetproject_NativeHandler_getHellostr[106] len: 6, s: dladdrstr[113] len: 8, s: libdl.sostr[122] len: 8, s: _Z4testvstr[131] len: 9, s: _Z5func1istr[141] len: 22, s: __aeabi_unwind_cpp_pr0str[164] len: 8, s: snprintfstr[173] len: 22, s: __aeabi_unwind_cpp_pr1str[196] len: 15, s: global_init_varstr[212] len: 17, s: global_uninit_varstr[230] len: 6, s: printfstr[237] len: 16, s: _Unwind_Completestr[254] len: 23, s: _Unwind_DeleteExceptionstr[278] len: 31, s: _Unwind_GetLanguageSpecificDatastr[310] len: 22, s: _Unwind_GetRegionStartstr[333] len: 22, s: _Unwind_RaiseExceptionstr[356] len: 14, s: _Unwind_Resumestr[371] len: 15, s: _Unwind_VRS_Getstr[387] len: 21, s: _Unwind_VRS_Interpretstr[409] len: 15, s: _Unwind_VRS_Popstr[425] len: 15, s: _Unwind_VRS_Setstr[441] len: 22, s: __aeabi_unwind_cpp_pr2str[464] len: 18, s: __gnu_unwind_framestr[483] len: 4, s: __sFstr[488] len: 16, s: __stack_chk_failstr[505] len: 17, s: __stack_chk_guardstr[523] len: 5, s: abortstr[529] len: 16, s: decode_eht_entrystr[546] len: 6, s: fflushstr[553] len: 7, s: fprintfstr[561] len: 13, s: unw_get_fpregstr[575] len: 17, s: unw_get_proc_infostr[593] len: 11, s: unw_get_regstr[605] len: 14, s: unw_getcontextstr[620] len: 14, s: unw_init_localstr[635] len: 10, s: unw_resumestr[646] len: 17, s: unw_save_vfp_as_Xstr[664] len: 13, s: unw_set_fpregstr[678] len: 11, s: unw_set_regstr[690] len: 8, s: unw_stepstr[699] len: 15, s: __aeabi_memclr8str[715] len: 14, s: __aeabi_memcpystr[730] len: 23, s: __gnu_Unwind_Find_exidxstr[754] len: 17, s: unw_get_proc_namestr[772] len: 12, s: unw_is_fpregstr[785] len: 19, s: unw_is_signal_framestr[805] len: 20, s: unw_local_addr_spacestr[826] len: 11, s: unw_regnamestr[838] len: 6, s: _edatastr[845] len: 11, s: __bss_startstr[857] len: 4, s: _endstr[862] len: 12, s: libstdc++.sostr[875] len: 7, s: libm.sostring count: 58&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse program list &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;program header offset: 52program header size: 8&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse program header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 0p_type: 0x6p_flags: 4p_offset: 52p_vaddr: 52p_paddr: 52p_filesz: 256p_memsz: 256p_align: 4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse program header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;省略（1~5）……&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse program header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 6p_type: 0x70000001p_flags: 4p_offset: 9776p_vaddr: 9776p_paddr: 9776p_filesz: 416p_memsz: 416p_align: 4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse program header &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 7p_type: 0x6474e552p_flags: 6p_offset: 11784p_vaddr: 15880p_paddr: 15880p_filesz: 504p_memsz: 504p_align: 4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse section list &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;parse section:ignoreparse section: .note.android.identignoreparse section: .note.gnu.build-idignoreparse section: .dynsym&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol table &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;symbol count: 53&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 0symbol name:st_name: 0st_value: 0st_size: 0st_info: 0st_other: 0st_shndx: 0&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;省略（1~17）……&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 18symbol name: Java_io_l0neman_nativetproject_NativeHandler_getHellost_name: 52st_value: 4061st_size: 32st_info: 18st_other: 0st_shndx: 13&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;省略（19~49）……&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 50symbol name: _Z5func1ist_name: 131st_value: 4033st_size: 16st_info: 18st_other: 0st_shndx: 13&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 51symbol name: _Unwind_GetRegionStartst_name: 310st_value: 6145st_size: 52st_info: 18st_other: 0st_shndx: 13&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse symbol &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 52symbol name: unw_get_proc_namest_name: 754st_value: 6649st_size: 32st_info: 18st_other: 0st_shndx: 13parse section: .dynstrignoreparse section: .gnu.hashignoreparse section: .hashignoreparse section: .gnu.versionignoreparse section: .gnu.version_dignoreparse section: .gnu.version_rignoreparse section: .rel.dyn&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation table &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;relocation entries count: 25&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation entry &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 0r_offset: 15880r_info: 23&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation entry &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;省略（1~22）……&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation entry &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 23r_offset: 16240r_info: 4885&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation entry &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 24r_offset: 16248r_info: 5397parse section: .rel.plt&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation table &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;relocation entries count: 30&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation entry &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 0r_offset: 16264r_info: 534&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation entry &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;省略（1~26）……&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation entry &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 27r_offset: 16372r_info: 790&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation entry &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 28r_offset: 16376r_info: 1046&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parse relocation entry &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;index: 29r_offset: 16380r_info: 3606parse section: .pltignoreparse section: .textignoreparse section: .ARM.exidxignoreparse section: .ARM.extabignoreparse section: .rodataignoreparse section: .fini_arrayignoreparse section: .data.rel.roignoreparse section: .dynamicignoreparse section: .gotignoreparse section: .dataignoreparse section: .bssignoreparse section: .commentignoreparse section: .note.gnu.gold-versionignoreparse section: .ARM.attributesignoreparse section: .shstrtabignore&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; release &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;close elf file.delete section header 32 array.delete program header 32 array.delete string table.delete symbol string table.delete symbol 32 list.delete relocation 32 list.F:\\L0neLabs\\AndroidLabs\\TProject\\Executable\\analysis\\ElfFileParser\\ElfFileParser\\out\\build\\x64-Debug (default)\\ElfFileParser.exe (process 16804) exited with code 0.To automatically close the console when debugging stops, enable Tools-&gt;Options-&gt;Debugging-&gt;Automatically close the console when debugging stops.Press any key to close this window . . . 解析源码 代码仓库：https://github.com/l0neman/ElfFileParser 参考 程序员的自我修养——链接、装载与库","link":"/2020/11/21/android-so-elf-%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"},{"title":"Xposed 实现原理分析","text":"前言Xposed 是 Android 平台上著名的 Java 层 Hook 框架，通过在 Android 设备上安装 Xposed 框架，编写 Xposed 模块，可实现对任意 Android 应用的 Java 方法的 Hook，以及应用资源的替换。 （Hook 是一种函数钩子技术，能够对函数进行接管，从而修改函数的返回值，改变函数的原始意图） 本文将基于 Xposed 最新的开源代码对 Xposed 的实现原理进行分析。Xposed 有两种实现版本，一个是基于 Dalvik 虚拟机的实现，它是针对早期的 Android 4.4 之前的 Android 设备设计的；另一个是基于 ART 虚拟机的实现，自 Android 5.0 系统开始，Android 系统正式采用了 ART 虚拟机模式运行，Dalvik 就成了历史，目前市面上几乎所有的手机都是以 ART 模式运行的，下面将主要对于 ART 上的 Xposed 实现进行详细分析，对于 Dalvik 上的 Xposed 的实现，进行必要性的分析。 通过了解 Xposed 的实现原理可以学到在 Android 平台上对于 Java 层代码的一种 Hook 机制的实现，同时复习 Android 系统的启动原理以及增加对于 Android ART 虚拟机运行原理的了解。 Xposed 使用方法在对 Xposed 进行分析之前，先回顾一下 Xposed 基本 API 的使用。 Xposed 的核心用法就是对一个 Java 方法进行 Hook，它的典型调用如下： 123456789101112131415XposedHelpers.findAndHookMethod(Application.class, &quot;onCreate&quot;, Context.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { Application app = (Application) param.thisObject; Context context = (Context) param.args[0]; Log.d(TAG, &quot;Application#onCreate(Context); this: &quot; + app + &quot; arg: &quot; + context); param.setResult(null); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); } }); 以上代码的意思是对 Application 这个类的 onCreate 方法进行 Hook，并使用 XC_MethodHook 对象提供一个 Hook 处理方法来接管原来方法的逻辑，当应用的 Application 类型的 onCreate 方法被调用时，beforeHookedMethod 将在被调用之前执行，同时 onCreate 的参数将会传递给 beforeHookedMethod 方法进行处理，上面的处理只是将参数打印了出来（一个 Context），同时还可以拿到被调用的 this 目标对象，也就是 Application 的对象，还可以使用 setResult 方法更改原始方法的返回值，不过这里的 Application#onCreate 方法是 void 返回类型的，setResult 不起作用，如果是其他类型，那么原方法的返回值将被更改。 这样就达到了修改一个 Java 方法的目的，即改变了原始方法的逻辑和意图。 12345public class App extends Application { @Override void onCreate(Context context) { // ... } } 可以看到，如果要使用 Xposed 对一个 Java 方法进行 Hook，需要提供要 Hook 方法的名字、参数列表类型和方法所在类，以及处理 Hook 的回调方法。 下面正式开始分析。 Xposed 原理概述首先概述 Xposed 原理，之后再对具体细节进行分析。 Xposed 是一个 Hook 框架，它提供了对任意 Android 应用的 Java 方法进行 Hook 的一种方法，通常它的使用方法如下： 首先按照 Xposed 官网提供的开发规范编写一个 Xposed 模块，它是一个普通的 Android 应用，包含一块开发者自己定义的代码，这块代码有能力通过 Xposed 框架提供的 Hook API 对任意应用的 Java 方法进行 Hook。 在要启用 Xposed 的 Android 设备上安装 Xposed 框架和这个 Xposed 模块，然后在 Xposed 框架应用中启用这个 Xposed 模块，重新启动设备后，Xposed 模块将被激活，当任意的应用运行起来后，Xposed 模块的 Hook 代码将会在这个应用进程中被加载，然后执行，从而对这个应用的 Java 方法进行指定 Hook 操作。 那么根据以上使用方法实现一个 Xposed 框架需要分成如下几个部分： 提供用于 Hook 操作的 API，为了让开发者进行模块开发。它通常是一个 jar 包； 提供一个具有界面的管理器应用，用于安装和管理 Xposed 本身和 Xposed 模块； 提供将代码加载到每一个应用进程中的能力，目的是支持 Xposed 模块的代码在进程中使用 Xposed API 进行 Hook 操作； 提供 Hook 任意 Java 方法的能力，为 Xposed 模块的调用提供支持，当 Xposed 模块在应用进程中执行时可对方法进行 Hook。 前两点对于我们开发者来说都很熟悉，没有什么难点，后面两点才是实现 Xposed 的核心。 首先是 Xposed 怎样实现的将代码加载到每一个应用进程中（Xposed 是基于 Root 权限实现的，所以有修改 Android 系统的能力）？ Xposed 是通过修改系统 zygote 进程的实现将代码注入应用进程中的。 为了知道 Xposed 是如何修改 Zygote 进程的，下面首先介绍 Android 系统 Zygote 相关内容。 Android zygote 进程zygote 进程是 Android 系统中第一个拥有 Java 运行环境的进程，它是由用户空间 1 号进程 init 进程通过解析 init.rc 文件创建出来的，从 init 进程 fork 而来。 zygote 进程是一个孵化器。Android 系统中所有运行在 Java 虚拟机中的系统服务以及应用均由 zygote 进程孵化而来。 zygote 通过克隆（fork）的方式创建子进程，fork 出来的子进程将继承父进程的所有资源，基于这个特性，zygote 进程在启动过程将创建 Java ART 虚拟机，预加载一个 Java 进程需要的所有系统资源，之后子进程被创建后，就可以直接使用这些资源运行了。 自 Android 5.0 系统开始，zygote 不再是一个进程，而是两个进程，一个是 32 位 zygote，负责孵化 32 位进程（为了兼容使用了 armeabi 和 armeabi-v7a 等 32 位架构的本地动态库的应用），另一个是 64 位 zygote 进程，负责孵化 64 位应用进程（可加载 arm64-v8a 等 64 位架构本地库）。 init 进程是 Android 系统中的 pid 为 1 的进程，是用户空间的第一个进程，它会在 Android 系统启动时被内核创建出来，之后会对 init.rc 文件进行解析，init.rc 文件是一个按照特定规则编写的脚本文件，init 进程通过解析它的规则来创建对应的服务进程。下面看一下 zygote 相关的 rc 文件的内容。 注：自 Android 5.0 开始，32 位 zygote 启动内容在 init.zygote32.rc 文件中，64 位 zygote 启动内容在 init.zygote64.rc 中。 注：自 Android 9.0 开始，两个 zygote 启动配置放在一个文件中 init.zygote64_32.rc。 这里看一下 Android 8.1 系统的 32 位 zygote 的 rc 文件内容： 12345678910# init.zygote32.rcservice zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasks 上面的含义是，创建一个名为 zygote 的服务进程，它的可执行文件在 /system/bin/app_process 中，后面的 -Xzygote、/system.bin 等是可执行文件的 main 函数将要接收的参数。 具体的 init 进程和 zygote 进程的启动细节，可以参考之前的文章： Android init 进程启动分析 Android zygote 进程启动分析 那么现在回到 Xposed，Xposed 对 zygote 进程的实现源码进行修改后，重新编译出 app_process 可执行文件，替换了系统的 app_process 文件（包括 64 位 zygote），并在其中加载了 XposedBridge.jar 这个 Dex 代码包，它包含 Xposed 的 Java 层实现代码和提供给 Xposed 模块的 API 代码，那么当 init 进程启动 zygote 服务进程时，将执行修改过的 app_process 文件，此时 zygote 进程就具有了 Xposed 的代码，Xposed 可以进行加载 Xposed 模块代码等任意操作了。 所有 Android 应用都是运行在 Java 虚拟机上的，所有的 Android 应用都是 zygote 的子进程，那么当 Android 应用进程启动后，将具备 zygote 进程加载的所有资源，从而将 Xposed 代码继承到了 Android 应用进程中，实现了将 Xposed 代码加载到每一个进程中的目的。 接下来是如何实现对应用中 Java 方法的 Hook。Hook 的基本原理如下，将 Java 方法的原始逻辑，转接到一个中间处理方法上，这个处理方法会对原始 Java 方法的参数进行转发，转发到一个用于处理 Hook 的方法上（即 XC_MethodHook 的实现），等处理 Hook 的方法执行自定义逻辑后（自定义逻辑可选择调用原始逻辑先获取原始返回值，再处理），再返回新的返回值。 下面分别是 Xposed 在 Dalvik 虚拟机和 ART 虚拟机下的 Hook 实现。 基于 Dalvik 的方法 Hook基于 Dalvik 的 Hook 方案是通过将被 Hook 方法修改为一个 JNI 方法，然后绑定一个 Xposed 自定义处理方法逻辑的函数上来实现的。 当需要 Hook 一个指定方法时，需要提供要 Hook 方法的名字、参数列表类型和方法所在类型，还要提供一个用于处理 Hook 的回调，回调方法用于修改原始方法的逻辑，它可以接收 Hook 方法的参数，然后返回一个新的返回值。 首先 Xposed 会取得这个方法的反射表示对象（例如通过 Class.getDeclaredMethod），它是一个 java.lang.reflect.Method 对象，然后取得这个对象的一个私有成员变量 slot 的值，将它和处理 Hook 的回调传递给 Xposed 的 Native 层代码，这个 slot 变量实际上是一个 Java 方法在虚拟机中的索引，使用这个索引可以从 Dalvik 中用于表示 Java 类的 ClassObject 映射类型的 directMethod 和 virtualMethods 数组中取出一个 Method 对象，它在虚拟机中表示一个 Java 方法，Xposed 的 Native 层代码接收到 Xposed Java 层传递过来的 slot 变量后，取出虚拟机中的 Method 对象，然后将这个 Method 对象的类型设置为 JNI 方法，即前面带有 native 修饰符的方法，然后将它的 nativeFunc 赋值给一个处理 Hook 逻辑的函数上，这个函数中将对这个 Method 的参数进行处理，传递给一开始提供的 Java 层中用于处理 Hook 的回调方法，让它来决定方法的新逻辑，从而返回新的返回值。此时便完成了 Hook。 那么调用一个被 Hook 的方法的过程是：当一个 Android 应用内的代码调用一个被 Hook 的方法时，Dalvik 将会进行代码的解释执行，Java 方法进入 Dalvik 虚拟机中会被转化为一个 Method 对象，然后虚拟机判断这个方法如果是一个 JNI 方法，就会直接调用它绑定的的 nativeFunc 函数，那么就走到了 Xposed 处理 Hook 的函数中，这个函数将这个被 Hook 方法的参数进行转发，让 Xposed 模块提供的处理 Hook 的回调方法来接管原来的逻辑，获得新的返回值返回给被 Hook 方法，即可完成整个 Hook 操作。 基于 ART 的方法 Hook基于 ART 的 Hook 方案相比 Dalvik 要复杂一些，需要重新修改编译 ART 虚拟机的源码，重新编译出 ART 虚拟机的可执行文件 libart.so，替换 Android 系统中的 ART 虚拟机实现。 它的核心原理就是直接修改一个方法对应的汇编代码的地址，让方法直接跳转到指定地址执行，然后就可以执行自定义的逻辑进行 Hook 处理了。 ART 虚拟机为了提高执行效率，采用了 AOT（Ahead Of Time，预编译） 模式运行，在应用运行之前先将整个 APK 包含的 Java 编译为二进制代码，然后应用运行时将执行每个方法对应的机器代码，比采用 JIT（Just In Time Compiler，即时编译） 的 Dalvik 虚拟机每次在运行时才编译代码执行的效率更高。 前面的过程和 Dalvik 一样，都需要在 Hook 一个指定方法时，提供要 Hook 方法的名字、参数列表类型和方法所在类型，和一个用于处理 Hook 的回调，这个回调用于修改原始方法的逻辑。 接下来 Xposed 取得这个方法的反射表示对象，它是一个 java.lang.reflect.Method 对象，然后和用于处理 Hook 的回调一起传递给 Xposed 的 Native 层代码，Native 层代码使用 ArtMethod 的一个静态转换方法，将 Java 层的反射对象 Method 转换为一个 ART 中用于表示一个 Java 方法的 ArtMethod 对象，获取这个表示被 Hook 的 Java 方法的 ArtMethod 对象后，会创建它的副本对象用于备份，备份目的是可以在可是的时候再调用原始方法，然后给这个 ArtMethod 对象重新设置汇编代码的地址，这个地址指向一段汇编代码，这个汇编代码是一段蹦床代码（Trampoline），会跳入原本用于处理 Java 动态代理的方法的函数，Xposed 对其进行了修改，在其中加入了处理 Hook 的逻辑，也就是转发被 Hook 方法的参数给处理 Hook 的回调方法，让 Hook 回调方法处理被 Hook 方法的逻辑，从而完成 Hook。至此就完成了 ART 中的 Hook 处理。 那么调用一个被 Hook 的方法的过程是：当一个 Android 应用内代码调用一个被 Hook 的方法时，ART 将会对方法代码进行执行，首先这个 Java 方法在 ART 虚拟机中将使用一个 ArtMethod 对象表示，然后进入 ART 的 Java 方法执行函数中，会跳入一段蹦床代码中进行执行，这段蹦床代码又会跳入这个 ArtMethod 对象设置的汇编代码地址处，从而执行到 Xposed 用于处理 Hook 的代码中，之后完成 Hook 逻辑。 上面使用书面语言分别概述了基于 Dalvik 和 ART 的方法 Hook 的实现，目的是对整个 Xposed 实现对方法的 Hook 原理进行概括，建立一个初步的印象。真正的细节还是在源代码中，为了分析最终源代码，下面进一步对 Xposed 进行分析。 Xposed 工作流程为了进一步分析 Xposed 的实现原理，先对 Xposed 的整体工作流程进行了解。 要使 Xposed 在 Android 设备上工作，首先需要安装 Xposed 框架。 首先获取 XposedInstaller 应用（去官方下载，或者通过 clone XposedInstaller 项目后自行编译），安装到已经 root 的设备上，然后打开 XposedInstaller。 XposedInstaller 主页会有“INSTALL/UPDATE” 的按钮，点击将会出现 Install 和 Install via recovery 两个选择，一个是直接进行安装；另一个是通过 recovery 进行刷入安装。不管选择哪个，都会首先从服务器下载相同的 xposed 补丁包。 XposedInstaller 会根据系统版本和 CPU 支持架构下载对应的系统补丁包。 在 ARM64 架构 CPU 的 Android 8.1 系统上，补丁包内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041xposed-v90-sdk27-arm64-beta3.zip +-META-INF │ +- CERT.RSA │ +- CERT.SF │ +- MANIFEST.MF │ +- com/google/android │ +- flash-script.sh │ +- update-binary │ +- updater-script │ +- system +- xposed.prop +- bin | +- app_process32_xposed | +- app_process64_xposed | +- dex2oat | +- dexdiag | +- dexlist | +- dexoptanalyzer | +- oatdump | +- patchoat | +- profman | +- framework | +- XposedBridge.jar | +- lib | +- libart-compiler.so | +- libart-dexlayout.so | +- libart.so | +- libopenjdkjvm.so | +- libsigchain.so | +- libxposed_art.so | +- lib64 +- libart-compiler.so +- libart-disassembler.so +- libart.so +- libopenjdkjvm.so +- libsigchain.so +- libxposed_art.so 压缩包名为 xposed-v90-sdk27-arm64-beta3.zip，文件名包含系统版本、CPU 架构和 Xposed 版本信息。 META-INF 目录存放文件签名信息，和 Xposed 刷机脚本 flash-script.sh 文件，update-binary 为刷入文件时执行的文件，它的源代码在 Android 源代码 bootable/recovery/updater/ 目录中。 system 目录为 Xposed 所需的文件，刷入时将会复制到系统 system 目录下，同名文件将进行覆盖，其中 xposed.prop 为 Xposed 的属性文件，里面会存放 Xposed 版本相关信息，如下： 12345version=90-beta3arch=arm64minsdk=27maxsdk=27requires:fbe_aware=1 bin 目录存放系统可执行文件；framwrok 目录存放 Xposed 的 Java 层 Dex 代码包，用于在 Zygote 进程中进行加载；lib、lib64 是 32 位和 64 位系统库，包括 ART 虚拟机库 libart.so 和依赖的库，还有 Xposed Native 层代码的实现 libxposed_art.so。 回到 XposedInstaller 中，如果选择了 Install，那么首先将压缩包中的 system 目录下的的可执行文件以及依赖库、配置文件等复制入系统 system 中覆盖相应系统文件，然后请求重启 Android 系统，重启后开机过程中，系统将会执行 app_process 可执行文件，从而启动 Xposed 修改过的 zygote 进程，其中会把 XposedBridge.jar 代码包加载起来，加载后其中的 Java 代码会加载已经安装的 Xposed 模块，当手机中的应用进程启动后，Xposed 模块代码将会被包含在应用进程中，开始工作； 如果是 Install via recovery，将创建文件 /cache/recovery/command 并写入指定刷机包路径的刷机命令，然后重启手机进入 recovery 模式，recovery 模式会自动执行 command 文件中的命令将 Xposed 文件刷入，然后正常重启至系统，启动过程和上面一致。 了解了 Xposed 的整体工作流程，下面开始着手进行源码分析。 Xposed 项目结构首先了解 Xposed 开源项目的结构，Xposed 包含如下几个开源项目： Xposed仓库地址：https://github.com/rovo89/Xposed Xposed Native 层代码的实现，主要修改了系统 app_process 的实现（即 zygote 服务进程的实现），为将 Hook 代码注入每个应用进程提供了入口。 XposedBridge仓库地址：https://github.com/rovo89/XposedBridge Xposed Java 层的代码，它将单独作为一个 jar 包的形式通过 zygote 的分裂（fork）注入到每一个应用进程中，内部会 Xposed 模块，并为 Xposed 模块中的 Hook 操作提供 API 支持。 XposedInstaller仓库地址：https://github.com/rovo89/XposedInstaller 统一管理 Xposed 框架的 Android 应用，也是一个 Xposed 框架安装器，用于安装更新 Xposed 框架核心以及作为统一管理 Xposed 模块安装的模块管理器。 android_art仓库地址：https://github.com/rovo89/android_art Xposed 修改后的 Android ART 虚拟机的实现，将编译出 libart.so 和其依赖库，替换系统的 ART 虚拟机实现。包含方法 Hook 的核心实现。 这个仓库最新分支是基于 Android Nougat MR2 源码修改的 ART 代码，目前 Xposed 最新版本支持到了 Android 8.1 系统，说明作者没有开源出最新代码，不过都是基于 ART 实现的 Hook，核心 Hook 实现是一致的，不影响分析。 XposedTools仓库地址：https://github.com/rovo89/XposedTools 用于编译 Xposed 框架的脚本工具。 目前只分析 Xposed 的实现，不需要对 Xposed 进行定制，所以先不关注 XposedTools 这个项目。 Xposed 源码分析可以对上面的项目进行 clone，然后用 Android Studio 和 VS Code 打开源代码，方便阅读。下面进入源码中分析具体实现。 Xposed 安装下载首先从 Xposed 的安装开始分析，这部分代码的实现在 XposedInstaller 中。 在一台 Root 过的设备上安装 XposedInstaller 后打开，点击主页的“INSTALL/UPDATE”，会弹出一个对话框，选择“Install”或“Install via recovery”安装 Xposed 框架，此时会首先进行框架核心文件的下载，进入 StatusInstallerFragment#download 方法中： 123456789101112131415161718192021// StatusInstallerFragment.javaprivate void download(Context context, String title, FrameworkZips.Type type, final RunnableWithParam&lt;File&gt; callback) { OnlineFrameworkZip zip = FrameworkZips.getOnline(title, type); new DownloadsUtil.Builder(context) .setTitle(zip.title)2 // 设置下载 url .setUrl(zip.url) .setDestinationFromUrl(DownloadsUtil.DOWNLOAD_FRAMEWORK) .setCallback(new DownloadFinishedCallback() { @Override public void onDownloadFinished(Context context, DownloadInfo info) { // 下载完成，触发回调 LOCAL_ZIP_LOADER.triggerReload(true); callback.run(new File(info.localFilename)); } }) .setMimeType(DownloadsUtil.MIME_TYPES.ZIP) .setDialog(true) .download();} 其中 zip.url 为 Xposed 框架压缩包的下载地址，我们重点关注安装，所以这里简要描述 zip 对象，zip 是 OnlineFrameworkZip 类的对象，表示一个 Xposed 框架包，它包含 title、type 和 url 三个成员，type 有两种，Installer 和 Uninstaller，即安装包和卸载包，都是包含刷机脚本的 Xposed 补丁包（就是上面工作流程中的压缩包），title 有三种，Xposed 测试版、Xposed 正式版、和 Uninstaller，用于界面显示。上面的 zip.url 在 Android 8.1 的 Pixel 手机上运行出来是 http://dl-xda.xposed.info/framework/sdk27/arm64/xposed-v90-sdk27-arm64-beta3.zip，这个 url 是根据设备支持的 CPU 架构、系统版本和 Xposed 当前最新版本组合出来的，组合规则由一个 framework.json 提供，它的本地路径是 /data/data/de.robv.android.xposed.installer/cache/framework.json，是从 http://dl-xda.xposed.info/framework.json 解析后得到的，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051{ &quot;zips&quot;: [ { &quot;title&quot;: &quot;Version 90-beta$(version)&quot;, &quot;url&quot;: &quot;http://dl-xda.xposed.info/framework/sdk$(sdk)/$(arch)/xposed-v90-sdk$(sdk)-$(arch)-beta$(version).zip&quot;, &quot;versions&quot;: [ { &quot;version&quot;: &quot;3&quot;, &quot;current&quot;: true }, { &quot;version&quot;: &quot;2&quot; }, { &quot;version&quot;: &quot;1&quot; } ], &quot;archs&quot;: [&quot;arm&quot;, &quot;arm64&quot;, &quot;x86&quot;], &quot;sdks&quot; : [26, 27] }, { &quot;title&quot;: &quot;Version $(version)&quot;, &quot;url&quot;: &quot;http://dl-xda.xposed.info/framework/sdk$(sdk)/$(arch)/xposed-v$(version)-sdk$(sdk)-$(arch).zip&quot;, &quot;versions&quot;: [ { &quot;version&quot;: &quot;89&quot;, &quot;current&quot;: true }, { &quot;version&quot;: &quot;88.2&quot; }, { &quot;version&quot;: &quot;88.1&quot; }, { &quot;version&quot;: &quot;88&quot; }, ... ], &quot;archs&quot;: [&quot;arm&quot;, &quot;arm64&quot;, &quot;x86&quot;], &quot;sdks&quot; : [21, 22, 23, 24, 25], &quot;exclude&quot;: [ { &quot;versions&quot;: [&quot;88.1&quot;], &quot;sdks&quot;: [21, 22, 23] }, { &quot;versions&quot;: [&quot;78&quot;, &quot;79&quot;, &quot;80&quot;, &quot;81&quot;, &quot;82&quot;, &quot;83&quot;, &quot;84&quot;, &quot;85&quot;, &quot;86&quot;, &quot;87&quot;], &quot;sdks&quot;: [24, 25] }, ... ] }, { &quot;title&quot;: &quot;Uninstaller ($(version))&quot;, &quot;url&quot;: &quot;http://dl-xda.xposed.info/framework/uninstaller/xposed-uninstaller-$(version)-$(arch).zip&quot;, &quot;type&quot;: &quot;uninstaller&quot;, &quot;versions&quot;: [ { &quot;version&quot;: &quot;20180117&quot;, &quot;current&quot;: true }, { &quot;version&quot;: &quot;20180108&quot; }, ... ], &quot;archs&quot;: [&quot;arm&quot;, &quot;arm64&quot;, &quot;x86&quot;], &quot;sdks&quot; : [21, 22, 23, 24, 25, 26, 27] } ]} 能看到，其中包含了 Xposed 测试版、Xposed 正式版、和 Xposed 的 Uninstaller 三种 title 的下载信息，每个下载信息中的 url 为下载地址的模板，versions 为可用的版本，根据系统信息和 Xposed 版本对 url 模板进行填充后组成下载地址。 回到上面的下载，下载成功后，将进入回调根据用户选择的安装类型进行安装，看一下回调的实现： 123456789101112131415161718192021222324252627// StatusInstallerFragment.javaif (action == ACTION_FLASH) { runAfterDownload = new RunnableWithParam&lt;File&gt;() { @Override public void run(File file) { // 直接刷入 flash(context, new FlashDirectly(file, type, title, false)); } };} else if (action == ACTION_FLASH_RECOVERY) { runAfterDownload = new RunnableWithParam&lt;File&gt;() { @Override public void run(File file) { // 依赖 recovery 模式进行刷入 flash(context, new FlashRecoveryAuto(file, type, title)); } };} else if (action == ACTION_SAVE) { runAfterDownload = new RunnableWithParam&lt;File&gt;() { @Override public void run(File file) { // 仅保存 saveTo(context, file); } };} 上面两个分支分别对应 Install 和 Install via recovery 两种安装方式的实现，flash 方法将会启动一个新的负责展示安装执行的界面，然后执行传入的 Flashable 对象的 flash 方法，执行成功后展示一个对话框，询问用户是否重启，重启后将激活 Xposed。分别看一下两种 Flashable 的实现。 直接刷入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// FlashDirectly.javapublic void flash(Context context, FlashCallback callback) { ZipCheckResult zipCheck = openAndCheckZip(callback); if (zipCheck == null) { return; } // 获取压缩包文件 ZipFile zip = zipCheck.getZip(); if (!zipCheck.isFlashableInApp()) { triggerError(callback, FlashCallback.ERROR_NOT_FLASHABLE_IN_APP); closeSilently(zip); return; } // 释放 update-binary 文件至 cache 目录中 ZipEntry entry = zip.getEntry(&quot;META-INF/com/google/android/update-binary&quot;); File updateBinaryFile = new File(XposedApp.getInstance().getCacheDir(), &quot;update-binary&quot;); try { AssetUtil.writeStreamToFile(zip.getInputStream(entry), updateBinaryFile, 0700); } catch (IOException e) { Log.e(XposedApp.TAG, &quot;Could not extract update-binary&quot;, e); triggerError(callback, FlashCallback.ERROR_INVALID_ZIP); return; } finally { closeSilently(zip); } // 使用 Root 身份执行刷入命令 RootUtil rootUtil = new RootUtil(); if (!rootUtil.startShell(callback)) { return; } callback.onStarted(); rootUtil.execute(&quot;export NO_UIPRINT=1&quot;, callback); if (mSystemless) { rootUtil.execute(&quot;export SYSTEMLESS=1&quot;, callback); } // 执行 update-binary 文件 int result = rootUtil.execute(getShellPath(updateBinaryFile) + &quot; 2 1 &quot; + getShellPath(mZipPath), callback); if (result != FlashCallback.OK) { triggerError(callback, result); return; } callback.onDone();} 直接刷入会直接使用 Root 身份执行 update-binary 可执行文件，其中会调用 flash-script.sh 文件，它将压缩包中的目录复制到对应的系统目录中，同名文件进行覆盖，在覆盖前会对原始系统文件进行备份，例如 libart.so.orig.gz，为了在卸载时恢复。 刷入后正常重启系统，系统在启动时将会加载自定义的 app_process 可执行文件，启动了带有 Xposed 框架代码的定制版 zygote 服务进程，为 Xposed 提供支持。 使用 recovery 刷入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// FlashRecoveryAuto.java@Overridepublic void flash(Context context, FlashCallback callback) { ZipCheckResult zipCheck = openAndCheckZip(callback); if (zipCheck == null) { return; } else { closeSilently(zipCheck.getZip()); } final String zipName = mZipPath.getName(); String cmd; // 执行刷入命令 RootUtil rootUtil = new RootUtil(); if (!rootUtil.startShell(callback)) { return; } callback.onStarted(); // 确认 /cache/recovery/ 目录存在 if (rootUtil.execute(&quot;ls /cache/recovery&quot;, null) != 0) { callback.onLine(context.getString(R.string.file_creating_directory, &quot;/cache/recovery&quot;)); if (rootUtil.executeWithBusybox(&quot;mkdir /cache/recovery&quot;, callback) != 0) { callback.onError(FlashCallback.ERROR_GENERIC, context.getString(R.string.file_create_directory_failed, &quot;/cache/recovery&quot;)); return; } } // 复制 zip 到 /cache/recovery/ 目录 callback.onLine(context.getString(R.string.file_copying, zipName)); cmd = &quot;cp -a &quot; + RootUtil.getShellPath(mZipPath) + &quot; /cache/recovery/&quot; + zipName; if (rootUtil.executeWithBusybox(cmd, callback) != 0) { callback.onError(FlashCallback.ERROR_GENERIC, context.getString(R.string.file_copy_failed, zipName, &quot;/cache/recovery&quot;)); return; } // 将刷机命令写入 /cache/recovery/command 文件中 callback.onLine(context.getString(R.string.file_writing_recovery_command)); cmd = &quot;echo --update_package=/cache/recovery/&quot; + zipName + &quot; &gt; /cache/recovery/command&quot;; if (rootUtil.execute(cmd, callback) != 0) { callback.onError(FlashCallback.ERROR_GENERIC, context.getString(R.string.file_writing_recovery_command_failed)); return; } callback.onLine(context.getString(R.string.auto_flash_note, zipName)); callback.onDone();} 通过 recovery 模式进行刷入就是首先复制压缩包到 /cache/recovery/ 中，然后向 /cache/recovery/command 文件中写入一条刷入压缩包的命令，然后询问用户是否重启至 recovery 模式，当系统处于 recovery 模式后将会自动检测 command 文件是否存在，如果存在将执行其中的指令，然后执行刷机包提供的脚本，过程和上面直接刷入一致，首先执行 update-binary 可执行文件，然后其中会调用 flash-script.sh 文件，将刷机包中的文件进行复制。此时，系统退出 reocvery 正常重启后将会加载成功 Xposed。 这里就分析完了安装，主要是通过刷入文件将系统关键组件替换为 Xposed 修改过的实现。 下面开始分析 Xposed 的启动，当系统启动后，init 进程将会通过解析 init.rc 文件后执行 app_process 创建 zygote 进程，此时就进入了 Xposed 重新编译修改过的 app_process 文件中。 Xposed 启动这部分的实现代码在项目 Xposed 中，是使用 C++ 代码编写的，如果这些代码出现崩溃，则会卡在开机界面，即 boot loop 情况。 Xposed 的 app_process 分为 Dalvik 和 ART 两种实现，这里只关注 ART 的实现，在 app_main2.cpp 中。 Native 层入口为 main 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// app_main2.cppint main(int argc, char* const argv[]){ if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) &lt; 0) { if (errno != EINVAL) { LOG_ALWAYS_FATAL(&quot;PR_SET_NO_NEW_PRIVS failed: %s&quot;, strerror(errno)); return 12; } } // 1. 处理 xposed 测试选项 if (xposed::handleOptions(argc, argv)) { return 0; } AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); argc--; argv++; int i; for (i = 0; i &lt; argc; i++) { if (argv[i][0] != '-') { break; } if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) { ++i; // Skip --. break; } runtime.addOption(strdup(argv[i])); } bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; ++i; while (i &lt; argc) { const char* arg = argv[i++]; if (strcmp(arg, &quot;--zygote&quot;) == 0) { zygote = true; niceName = ZYGOTE_NICE_NAME; } else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) { startSystemServer = true; } else if (strcmp(arg, &quot;--application&quot;) == 0) { application = true; } else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) { niceName.setTo(arg + 12); } else if (strncmp(arg, &quot;--&quot;, 2) != 0) { className.setTo(arg); break; } else { --i; break; } } Vector&lt;String8&gt; args; if (!className.isEmpty()) { args.add(application ? String8(&quot;application&quot;) : String8(&quot;tool&quot;)); runtime.setClassNameAndArgs(className, argc - i, argv + i); } else { maybeCreateDalvikCache(); if (startSystemServer) { args.add(String8(&quot;start-system-server&quot;)); } char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) { LOG_ALWAYS_FATAL(&quot;app_process: Unable to determine ABI list from property %s.&quot;, ABI_LIST_PROPERTY); return 11; } String8 abiFlag(&quot;--abi-list=&quot;); abiFlag.append(prop); args.add(abiFlag); for (; i &lt; argc; ++i) { args.add(String8(argv[i])); } } if (!niceName.isEmpty()) { runtime.setArgv0(niceName.string()); set_process_name(niceName.string()); } // 2. if (zygote) { // 初始化 xposed isXposedLoaded = xposed::initialize(true, startSystemServer, NULL, argc, argv); // #define XPOSED_CLASS_DOTS_ZYGOTE &quot;de.robv.android.xposed.XposedBridge&quot; // 初始化成功则会 XposedBridge 流程，否则进入系统的 ZygoteInit 中 runtimeStart(runtime, isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : &quot;com.android.internal.os.ZygoteInit&quot;, args, zygote); } else if (className) { // 非 zygote 进程流程，用于支持使用命令行启动自定义的类，这里先不关心这个流程 isXposedLoaded = xposed::initialize(false, false, className, argc, argv); runtimeStart(runtime, isXposedLoaded ? XPOSED_CLASS_DOTS_TOOLS : &quot;com.android.internal.os.RuntimeInit&quot;, args, zygote); } else { fprintf(stderr, &quot;Error: no class name or --zygote supplied.\\n&quot;); app_usage(); LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;); return 10; }} 通过对比原版的 ART 代码，发现 main 函数中只有 1 和 2 两处代码进行了修改，当 init 进程解析 init.rc 文件时，会启动 zygote 进程，此时就进入了 app_process 的 main 函数中，并将 init.rc 中附带的选项使用 argv 参数传递进来。 先看第一处 handleOptions： 1234567891011121314151617181920212223242526272829// xposed.cppbool handleOptions(int argc, char* const argv[]) { parseXposedProp(); if (argc == 2 &amp;&amp; strcmp(argv[1], &quot;--xposedversion&quot;) == 0) { printf(&quot;Xposed version: %s\\n&quot;, xposedVersion); return true; } if (argc == 2 &amp;&amp; strcmp(argv[1], &quot;--xposedtestsafemode&quot;) == 0) { printf(&quot;Testing Xposed safemode trigger\\n&quot;); if (detectSafemodeTrigger(shouldSkipSafemodeDelay())) { printf(&quot;Safemode triggered\\n&quot;); } else { printf(&quot;Safemode not triggered\\n&quot;); } return true; } argBlockStart = argv[0]; uintptr_t start = reinterpret_cast&lt;uintptr_t&gt;(argv[0]); uintptr_t end = reinterpret_cast&lt;uintptr_t&gt;(argv[argc - 1]); end += strlen(argv[argc - 1]) + 1; argBlockLength = end - start; return false;} 处理了 --xposedversion 和 --xposedtestsafemode 两个参数，不过查看 init.rc 文件中启动 zygote 的选项中并没有这两项： 12service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server... 所以应该是用于 Xposed 的测试代码，那么这里就不再关心。 继续下面第 2 部分，在 zygote 流程中，首先会初始化 Xposed，如果初始化成功就会传入 XposedBridge 的完整类名，用于进入 Java 层的 XposedBridge 入口。 首先看 xposed::initialize 函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768bool initialize(bool zygote, bool startSystemServer, const char* className, int argc, char* const argv[]) {#if !defined(XPOSED_ENABLE_FOR_TOOLS) if (!zygote) return false;#endif // 判断系统是否处于 minmal framework 模式，此时 /data 是 tmpfs 类型，无法加载 Xposed if (isMinimalFramework()) { ALOGI(&quot;Not loading Xposed for minimal framework (encrypted device)&quot;); return false; } // 保存相关参数 // xposed 是一个用于共享信息的对象，XposedShared* xposed = new XposedShared; xposed-&gt;zygote = zygote; xposed-&gt;startSystemServer = startSystemServer; xposed-&gt;startClassName = className; xposed-&gt;xposedVersionInt = xposedVersionInt;#if XPOSED_WITH_SELINUX xposed-&gt;isSELinuxEnabled = is_selinux_enabled() == 1; xposed-&gt;isSELinuxEnforcing = xposed-&gt;isSELinuxEnabled &amp;&amp; security_getenforce() == 1;#else xposed-&gt;isSELinuxEnabled = false; xposed-&gt;isSELinuxEnforcing = false;#endif // XPOSED_WITH_SELINUX if (startSystemServer) { xposed::logcat::printStartupMarker(); } else if (zygote) { // 给另一个架构的优先执行的 zygote 进程一些时间启动，从而避免同时打印日志，造成难以阅读 sleep(10); } // 打印 Xposed 版本和 Device、ROM 等信息，开机时可以在 logcat 中看到 printRomInfo(); if (startSystemServer) { // 确保 XposedInstaller uid 和 gid 存在，即表示安装了 XposedInstaller // 启动 XposedService 服务 if (!determineXposedInstallerUidGid() || !xposed::service::startAll()) { return false; } xposed::logcat::start();#if XPOSED_WITH_SELINUX } else if (xposed-&gt;isSELinuxEnabled) { if (!xposed::service::startMembased()) { return false; }#endif // XPOSED_WITH_SELINUX }#if XPOSED_WITH_SELINUX if (xposed-&gt;isSELinuxEnabled) { xposed::service::membased::restrictMemoryInheritance(); }#endif // XPOSED_WITH_SELINUX if (zygote &amp;&amp; !isSafemodeDisabled() &amp;&amp; detectSafemodeTrigger(shouldSkipSafemodeDelay())) disableXposed(); if (isDisabled() || (!zygote &amp;&amp; shouldIgnoreCommand(argc, argv))) return false; // 将 XposedBridge.jar 加入系统 CLASSPATH 变量，使其代码中的类可被加载 return addJarToClasspath();} 以上代码主要是保存了 app_process 的启动选项，设置一些 xposed 支持，最后使用 addJarToClasspath 将 XposedBridge.jar 加入系统路径。 12345678910111213141516// xposed.cppbool addJarToClasspath() { ALOGI(&quot;-----------------&quot;); // #define XPOSED_JAR &quot;/system/framework/XposedBridge.jar&quot; if (access(XPOSED_JAR, R_OK) == 0) { if (!addPathToEnv(&quot;CLASSPATH&quot;, XPOSED_JAR)) return false; ALOGI(&quot;Added Xposed (%s) to CLASSPATH&quot;, XPOSED_JAR); return true; } else { ALOGE(&quot;ERROR: Could not access Xposed jar '%s'&quot;, XPOSED_JAR); return false; }} 这里就初始化完成了，如果中间有一步执行失败，返回 false，那么 Xposed 就不能正常工作了，会通过传递 ZygoteInit 完整类名，进入系统正常的 zygote 流程。 现在回到 main 函数中，下面进入 runtimeStart： 1234567891011121314151617181920212223242526272829// app_main2.cppstatic void runtimeStart(AppRuntime&amp; runtime, const char *classname, const Vector&lt;String8&gt;&amp; options, bool zygote){#if PLATFORM_SDK_VERSION &gt;= 23 runtime.start(classname, options, zygote);#else // try newer variant (5.1.1_r19 and later) first void (*ptr1)(AppRuntime&amp;, const char*, const Vector&lt;String8&gt;&amp;, bool); *(void **) (&amp;ptr1) = dlsym(RTLD_DEFAULT, &quot;_ZN7android14AndroidRuntime5startEPKcRKNS_6VectorINS_7String8EEEb&quot;); if (ptr1 != NULL) { ptr1(runtime, classname, options, zygote); return; } // fall back to older variant void (*ptr2)(AppRuntime&amp;, const char*, const Vector&lt;String8&gt;&amp;); *(void **) (&amp;ptr2) = dlsym(RTLD_DEFAULT, &quot;_ZN7android14AndroidRuntime5startEPKcRKNS_6VectorINS_7String8EEE&quot;); if (ptr2 != NULL) { ptr2(runtime, classname, options); return; } // should not happen LOG_ALWAYS_FATAL(&quot;app_process: could not locate AndroidRuntime::start() method.&quot;);#endif} 其实就是直接调用系统 AppRuntime 的 start 函数，如果是 Android 5.1.1 之前需要通过通过获取 AppRuntime::start 函数符号句柄的方式调用，后面一长串字符串是函数被编译后的签名字符串。 调用 AppRuntime::start 后，内部会创建 Java 虚拟机，然后执行传入类的 main 函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// AndroidRuntime.cppvoid AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote){ ALOGD(&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n&quot;, className != NULL ? className : &quot;(unknown)&quot;, getuid()); static const String8 startSystemServer(&quot;start-system-server&quot;); // ... JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; // 创建虚拟机 if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) { return; } onVmCreated(env); // 注册系统类 JNI 方法 if (startReg(env) &lt; 0) { ALOGE(&quot;Unable to register all android natives\\n&quot;); return; } // ... // 转换为 JNI 格式类名：com/android/internal/os/XposedBridge char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) { ALOGE(&quot;JavaVM unable to locate class '%s'\\n&quot;, slashClassName); } else { jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); if (startMeth == NULL) { ALOGE(&quot;JavaVM unable to find main() in '%s'\\n&quot;, className); } else { // 调用 XposedBridge.main(); env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); } } // ...} Java 层下面就进入到了 Java 层的 XposedBridge#main 方法中： 1234567891011121314151617181920212223242526272829303132333435363738394041// XposedBridge.javaprotected static void main(String[] args) { // Initialize the Xposed framework and modules try { // 判断 native 加载成功 if (!hadInitErrors()) { // Xposed 相关初始化 initXResources(); // SELinux 相关支持 SELinuxHelper.initOnce(); SELinuxHelper.initForProcess(null); // runtime 表示 ART 还是 Dalivk runtime = getRuntime(); XPOSED_BRIDGE_VERSION = getXposedVersion(); if (isZygote) { // 为资源的 Hook 注册回调 XposedInit.hookResources(); // 为代码 Hook 注册回调，将会调用每个 Xposed 模块的入口 XposedInit.initForZygote(); } // 加载设备上的 Xposed 模块 XposedInit.loadModules(); } else { Log.e(TAG, &quot;Not initializing Xposed because of previous errors&quot;); } } catch (Throwable t) { Log.e(TAG, &quot;Errors during Xposed initialization&quot;, t); disableHooks = true; } // 调用系统正常流程 Java 层 if (isZygote) { ZygoteInit.main(args); } else { RuntimeInit.main(args); }} 重点关注 XposedInit.initForZygote(); 和 XposedInit.loadModules();： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*package*/ static void initForZygote() throws Throwable { // ... // system_server 初始化 if (Build.VERSION.SDK_INT &lt; 21) { findAndHookMethod(&quot;com.android.server.ServerThread&quot;, null, Build.VERSION.SDK_INT &lt; 19 ? &quot;run&quot; : &quot;initAndLoop&quot;, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { SELinuxHelper.initForProcess(&quot;android&quot;); loadedPackagesInProcess.add(&quot;android&quot;); XC_LoadPackage.LoadPackageParam lpparam = new XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks); lpparam.packageName = &quot;android&quot;; lpparam.processName = &quot;android&quot;; // it's actually system_server, but other functions return this as well lpparam.classLoader = XposedBridge.BOOTCLASSLOADER; lpparam.appInfo = null; lpparam.isFirstApplication = true; XC_LoadPackage.callAll(lpparam); } }); } // ... hookAllConstructors(LoadedApk.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { LoadedApk loadedApk = (LoadedApk) param.thisObject; String packageName = loadedApk.getPackageName(); XResources.setPackageNameForResDir(packageName, loadedApk.getResDir()); if (packageName.equals(&quot;android&quot;) || !loadedPackagesInProcess.add(packageName)) return; if (!getBooleanField(loadedApk, &quot;mIncludeCode&quot;)) return; XC_LoadPackage.LoadPackageParam lpparam = new XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks); lpparam.packageName = packageName; lpparam.processName = AndroidAppHelper.currentProcessName(); lpparam.classLoader = loadedApk.getClassLoader(); lpparam.appInfo = loadedApk.getApplicationInfo(); lpparam.isFirstApplication = false; XC_LoadPackage.callAll(lpparam); } }); // ...} 上面省略了一部分代码，上面的代码主要是通过 Hook 系统关键类的流程，为 Xposed 模块注册加载代码包的回调，当这些系统流程执行时，会通过 XC_LoadPackage.callAll(lpparm) 通知所有的 Xposed 模块。 上面创建了 XC_LoadPackage.LoadPackageParam 的对象，就是为了给 Xposed 模块的入口进行传递。 XposedBridge.sLoadedPackageCallbacks 是 Xposed 模块回调的集合，是一个 CopyOnWriteSortedSet&lt;XC_LoadPackage&gt; 类型。 XC_LoadPackage 有一个 call 方法，用于回调自己的 handleLoadPackage 方法。 1234567// XC_LoadPackage.java@Overrideprotected void call(Param param) throws Throwable { if (param instanceof LoadPackageParam) handleLoadPackage((LoadPackageParam) param);} XC_LoadPackage.callAll 将会调用每一个 XC_LoadPackage 的 call 方法，从而向 Xposed 模块传递 lpparm 参数。 123456789101112// XC_LoadPackage.javapublic static void callAll(Param param) { if (param.callbacks == null) throw new IllegalStateException(&quot;This object was not created for use with callAll&quot;); for (int i = 0; i &lt; param.callbacks.length; i++) { try { ((XCallback) param.callbacks[i]).call(param); } catch (Throwable t) { XposedBridge.log(t); } }} Xposed 模块加载再来看 XposedInit.loadModules();： 1234567891011121314151617181920212223242526// XposedInit.java/*package*/ static void loadModules() throws IOException { // 从 modules.list 文件读取 Xposde 模块列表 final String filename = BASE_DIR + &quot;conf/modules.list&quot;; BaseService service = SELinuxHelper.getAppDataFileService(); if (!service.checkFileExists(filename)) { Log.e(TAG, &quot;Cannot load any modules because &quot; + filename + &quot; was not found&quot;); return; } ClassLoader topClassLoader = XposedBridge.BOOTCLASSLOADER; ClassLoader parent; while ((parent = topClassLoader.getParent()) != null) { topClassLoader = parent; } InputStream stream = service.getFileInputStream(filename); BufferedReader apks = new BufferedReader(new InputStreamReader(stream)); String apk; while ((apk = apks.readLine()) != null) { // 加载每个 Xposed 模块 loadModule(apk, topClassLoader); } apks.close();} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// XposedInit.javaprivate static void loadModule(String apk, ClassLoader topClassLoader) { Log.i(TAG, &quot;Loading modules from &quot; + apk); // ... DexFile dexFile; try { dexFile = new DexFile(apk); } catch (IOException e) { Log.e(TAG, &quot; Cannot load module&quot;, e); return; } // ... ZipFile zipFile = null; InputStream is; try { zipFile = new ZipFile(apk); // 打开 Xposed 模块 apk 文件中的 xposed_init 文件， // 它的内容是 Xposed 模块入口类的全类名 ZipEntry zipEntry = zipFile.getEntry(&quot;assets/xposed_init&quot;); if (zipEntry == null) { Log.e(TAG, &quot; assets/xposed_init not found in the APK&quot;); closeSilently(zipFile); return; } is = zipFile.getInputStream(zipEntry); } catch (IOException e) { Log.e(TAG, &quot; Cannot read assets/xposed_init in the APK&quot;, e); closeSilently(zipFile); return; } ClassLoader mcl = new PathClassLoader(apk, XposedBridge.BOOTCLASSLOADER); BufferedReader moduleClassesReader = new BufferedReader(new InputStreamReader(is)); try { String moduleClassName; // 获取 Xposed 模块入口类名 while ((moduleClassName = moduleClassesReader.readLine()) != null) { moduleClassName = moduleClassName.trim(); if (moduleClassName.isEmpty() || moduleClassName.startsWith(&quot;#&quot;)) continue; try { Log.i(TAG, &quot; Loading class &quot; + moduleClassName); // 加载入口类 Class&lt;?&gt; moduleClass = mcl.loadClass(moduleClassName); // ... final Object moduleInstance = moduleClass.newInstance(); if (XposedBridge.isZygote) { if (moduleInstance instanceof IXposedHookZygoteInit) { IXposedHookZygoteInit.StartupParam param = new IXposedHookZygoteInit.StartupParam(); param.modulePath = apk; param.startsSystemServer = startsSystemServer; ((IXposedHookZygoteInit) moduleInstance).initZygote(param); } // 根据模块关心代码 Hook 还是资源 Hook 分别处理 if (moduleInstance instanceof IXposedHookLoadPackage) // 注册到 sLoadedPackageCallbacks 中 XposedBridge.hookLoadPackage(new IXposedHookLoadPackage.Wrapper((IXposedHookLoadPackage) moduleInstance)); if (moduleInstance instanceof IXposedHookInitPackageResources) // 注册资源的 Xposed 模块回调 XposedBridge.hookInitPackageResources(new IXposedHookInitPackageResources.Wrapper((IXposedHookInitPackageResources) moduleInstance)); } // ... } catch (Throwable t) { Log.e(TAG, &quot; Failed to load class &quot; + moduleClassName, t); } } } catch (IOException e) { Log.e(TAG, &quot; Failed to load module from &quot; + apk, e); } finally { closeSilently(is); closeSilently(zipFile); }} 上面代码首先从 conf/modules.list 文件加载所有 Xposed 模块的 APK 路径列表，然后通过读取每一个 Xposed 模块 APK 包中的 assets/xposed_init 文件获得 Xposed 模块的入口类名，最后将这个类通过 XposedBridge.hookLoadPackage 注册到前面的 XposedBridge.sLoadedPackageCallbacks 中。 1234567// XposedBridge.javapublic static void hookLoadPackage(XC_LoadPackage callback) { synchronized (sLoadedPackageCallbacks) { sLoadedPackageCallbacks.add(callback); }} 那么当前面 Hook 的系统关键类流程被触发后，将会通过 sLoadedPackageCallbacks 回调每个 Xposed 模块的入口。 到这里 Xposed 模块的启动的核心逻辑就分析完了，主要是通过 Xposed 定制版的 zygote 加载 XposedBridge.jar，然后调用 XposedBridge#main 方法加载所有的 Xposed 模块，当一个进程通过 zygote 进程 clone 出来时，就会携带 XposedBridge.jar 的代码，同时在进程启动时回调所有的 Xposed 模块的入口，XposedBridge.jar 中还包含 Hook API，那么 Xposed 模块就可以通过这些 API 对应用程序进行 Hook 操作了。 接下来就是 Xposed 的方法 Hook 的实现代码分析了。 Xposed 方法 Hook从 XposedHelpers.findAndHookMethod 方法开始，看 Xposed 是如何进行 Hook 的。 12345678910111213// XposedHelpers.javapublic static XC_MethodHook.Unhook findAndHookMethod(Class&lt;?&gt; clazz, String methodName, Object... parameterTypesAndCallback) { if (parameterTypesAndCallback.length == 0 || !(parameterTypesAndCallback[parameterTypesAndCallback.length-1] instanceof XC_MethodHook)) throw new IllegalArgumentException(&quot;no callback defined&quot;); XC_MethodHook callback = (XC_MethodHook) parameterTypesAndCallback[parameterTypesAndCallback.length-1]; // 获取方法的反射表示对象 Method m = findMethodExact(clazz, methodName, getParameterClasses(clazz.getClassLoader(), parameterTypesAndCallback)); // 下一步 return XposedBridge.hookMethod(m, callback);} 首先使用 findMethodExact 获取一个 Java 方法的反射表示对象 m： 123456789101112131415161718192021222324// XposedHelpers.javapublic static Method findMethodExact(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) { String fullMethodName = clazz.getName() + '#' + methodName + getParametersString(parameterTypes) + &quot;#exact&quot;; if (methodCache.containsKey(fullMethodName)) { // 首先从缓存中取 Method method = methodCache.get(fullMethodName); if (method == null) throw new NoSuchMethodError(fullMethodName); return method; } try { // 通过反射 API 取得 Method 对象 Method method = clazz.getDeclaredMethod(methodName, parameterTypes); method.setAccessible(true); methodCache.put(fullMethodName, method); return method; } catch (NoSuchMethodException e) { methodCache.put(fullMethodName, null); throw new NoSuchMethodError(fullMethodName); }} 这里也很简单，使用了缓存保存方法的反射对象，然后继续下一步，进入 XposedBridge#hookMethod 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// XposedBridge.javapublic static XC_MethodHook.Unhook hookMethod(Member hookMethod, XC_MethodHook callback) { // 只允许 Method 和 Constructor 类型，Constructor 类型为了支持 findAndHookConstructor if (!(hookMethod instanceof Method) &amp;&amp; !(hookMethod instanceof Constructor&lt;?&gt;)) { throw new IllegalArgumentException(&quot;Only methods and constructors can be hooked: &quot; + hookMethod.toString()); } else if (hookMethod.getDeclaringClass().isInterface()) { throw new IllegalArgumentException(&quot;Cannot hook interfaces: &quot; + hookMethod.toString()); } else if (Modifier.isAbstract(hookMethod.getModifiers())) { throw new IllegalArgumentException(&quot;Cannot hook abstract methods: &quot; + hookMethod.toString()); } boolean newMethod = false; CopyOnWriteSortedSet&lt;XC_MethodHook&gt; callbacks; synchronized (sHookedMethodCallbacks) { callbacks = sHookedMethodCallbacks.get(hookMethod); if (callbacks == null) { // 创建 method 与 hook 回调列表关联的映射表 callbacks = new CopyOnWriteSortedSet&lt;&gt;(); sHookedMethodCallbacks.put(hookMethod, callbacks); newMethod = true; } } // 添加 hook 回调到和这个 method 关联的 hook 回调列表 callbacks.add(callback); if (dnewMethod) { Clss&lt;?&gt; declaringClass = hookMethod.getDeclaringClass(); int slot; Class&lt;?&gt;[] parameterTypes; Class&lt;?&gt; returnType; if (runtime == RUNTIME_ART) { slot = 0; parameterTypes = null; returnType = null; } else if (hookMethod instanceof Method) { // slot 在 Android 5.0 以下的系统，java.reflect.Method 类中的成员， // 它是 Dralvik 虚拟机中这个 Method 在虚拟机中的地址。 // Android 5.0 开始正式使用了 ART 虚拟机，所以不存在这个成员 slot = getIntField(hookMethod, &quot;slot&quot;); parameterTypes = ((Method) hookMethod).getParameterTypes(); returnType = ((Method) hookMethod).getReturnType(); } else { // 处理 Constructor slot = getIntField(hookMethod, &quot;slot&quot;); parameterTypes = ((Constructor&lt;?&gt;) hookMethod).getParameterTypes(); returnType = null; } // 打包 Hook 回调相关信息，准备进入 Native 层 AdditionalHookInfo additionalInfo = new AdditionalHookInfo(callbacks, parameterTypes, returnType); // 进入 Native 层代码，传入 method、class、slot、hook 回调等信息 hookMethodNative(hookMethod, declaringClass, slot, additionalInfo); } return callback.new Unhook(hookMethod);} 上面主要是添加了 XC_MethodHook 类型的 Hook 回调，然后将相关信息全部传入了 Xposed native 层代码中。 最后返回一个 Unhook 对象，是为了取消 Hook，它的 unhook 方法如下： 12345// XC_MethodHook.java - class Unhookpublic void unhook() { XposedBridge.unhookMethod(hookMethod, XC_MethodHook.this);} 1234567891011// XposedBridge.javapublic static void unhookMethod(Member hookMethod, XC_MethodHook callback) { CopyOnWriteSortedSet&lt;XC_MethodHook&gt; callbacks; synchronized (sHookedMethodCallbacks) { callbacks = sHookedMethodCallbacks.get(hookMethod); if (callbacks == null) return; } callbacks.remove(callback);} 就是直接移除与这个 Java 方法相关的 Hook 处理回调。 下面查看 hookMethodNative 函数的实现，发现它是一个 JNI 方法： 1private native synchronized static void hookMethodNative(Member method, Class&lt;?&gt; declaringClass, int slot, Object additionalInfo); 它的实现在 libxposed_art.so 中，源代码在 Xposed 项目中。 首先需要解决一个问题，这个动态库是什么时候加载的，它的 JNI 方法和 Java 层是什么时候关联的？ 它是在 Java 虚拟机中创建时加载的，同时关联的 JNI 方法。 在 app_main2.cpp 中，Xposed 除了改写 app_process 的 main 函数，还改写了 AppRuntime::onVmCreated 函数： 123456789101112131415161718192021222324252627282930// app_main2.cppnamespace android {class AppRuntime : public AndroidRuntime{public: // ... virtual void onVmCreated(JNIEnv* env) { if (isXposedLoaded) xposed::onVmCreated(env); if (mClassName.isEmpty()) { return; } char* slashClassName = toSlashClassName(mClassName.string()); mClass = env-&gt;FindClass(slashClassName); if (mClass == NULL) { ALOGE(&quot;ERROR: could not find class '%s'\\n&quot;, mClassName.string()); env-&gt;ExceptionDescribe(); } free(slashClassName); mClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(mClass)); } // ...};} 回顾前面的内容，这个函数将在 Java 虚拟机创建后被回调： 12345678910111213141516// AndroidRuntime.cppvoid AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote){ // ... if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) { return; } // 回调 Java 虚拟机创建 onVmCreated(env); if (startReg(env) &lt; 0) { ALOGE(&quot;Unable to register all android natives\\n&quot;); return; } // ... } 进入 xposed::onVmCreated 函数： 1234567891011121314151617181920212223242526272829303132333435363738// xposed.cppvoid onVmCreated(JNIEnv* env) { const char* xposedLibPath = NULL; // 首先确认 Xposed 库的路径是 ART 还是 Dalvik if (!determineRuntime(&amp;xposedLibPath)) { ALOGE(&quot;Could not determine runtime, not loading Xposed&quot;); return; } // 打开 Xposed 动态库 void* xposedLibHandle = dlopen(xposedLibPath, RTLD_NOW); if (!xposedLibHandle) { ALOGE(&quot;Could not load libxposed: %s&quot;, dlerror()); return; } dlerror(); // 调用初始化方法 bool (*xposedInitLib)(XposedShared* shared) = NULL; *(void **) (&amp;xposedInitLib) = dlsym(xposedLibHandle, &quot;xposedInitLib&quot;); if (!xposedInitLib) { ALOGE(&quot;Could not find function xposedInitLib&quot;); return; }#if XPOSED_WITH_SELINUX xposed-&gt;zygoteservice_accessFile = &amp;service::membased::accessFile; xposed-&gt;zygoteservice_statFile = &amp;service::membased::statFile; xposed-&gt;zygoteservice_readFile = &amp;service::membased::readFile;#endif // XPOSED_WITH_SELINUX if (xposedInitLib(xposed)) { // 调用绑定的 onVmCreated 回调函数 xposed-&gt;onVmCreated(env); }} 首先是 determineRuntime 确认 Xposed 的库路径： 123456789101112131415161718192021222324252627282930313233343536// xposed.cppstatic bool determineRuntime(const char** xposedLibPath) { FILE *fp = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;); if (fp == NULL) { ALOGE(&quot;Could not open /proc/self/maps: %s&quot;, strerror(errno)); return false; } bool success = false; char line[256]; while (fgets(line, sizeof(line), fp) != NULL) { char* libname = strrchr(line, '/'); if (!libname) continue; libname++; if (strcmp(&quot;libdvm.so\\n&quot;, libname) == 0) { ALOGI(&quot;Detected Dalvik runtime&quot;); // #define XPOSED_LIB_DALVIK POSED_LIB_DIR &quot;libxposed_dalvik.so&quot; *xposedLibPath = XPOSED_LIB_DALVIK; success = true; break; } else if (strcmp(&quot;libart.so\\n&quot;, libname) == 0) { ALOGI(&quot;Detected ART runtime&quot;); // #define XPOSED_LIB_ART XPOSED_LIB_DIR &quot;libxposed_art.so&quot; *xposedLibPath = XPOSED_LIB_ART; success = true; break; } } fclose(fp); return success;} 根据系统中是否存在 libdvm.so 或 libart.so，确认加载支持 ART 还是 Dalvik 版本的 Xposed 库，在 ART 上加载 libxposed_art.so。 然后使用 dlopen 加载链接了这个动态库，那么它的符号就可以被正常访问了。 后面又调用了 xposedInitLib 函数： 1234567// libxposed_art.cppbool xposedInitLib(XposedShared* shared) { xposed = shared; xposed-&gt;onVmCreated = &amp;onVmCreatedCommon; return true;} 指定了一个 xposed-&gt;onVmCreated 为 onVmCreatedCommon，看一下它的实现。 1234567891011121314// libxposed_common.cppvoid onVmCreatedCommon(JNIEnv* env) { if (!initXposedBridge(env) || !initZygoteService(env)) { return; } if (!onVmCreated(env)) { return; } xposedLoadedSuccessfully = true; return;} 这里主要关注 initXposedBridge，它会进行 JNI 方法的注册。 12345678910111213141516171819202122232425262728293031323334// libxposed_common.cppbool initXposedBridge(JNIEnv* env) { // #define CLASS_XPOSED_BRIDGE &quot;de/robv/android/xposed/XposedBridge&quot; classXposedBridge = env-&gt;FindClass(CLASS_XPOSED_BRIDGE); if (classXposedBridge == NULL) { ALOGE(&quot;Error while loading Xposed class '%s':&quot;, CLASS_XPOSED_BRIDGE); logExceptionStackTrace(); env-&gt;ExceptionClear(); return false; } classXposedBridge = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(classXposedBridge)); ALOGI(&quot;Found Xposed class '%s', now initializing&quot;, CLASS_XPOSED_BRIDGE); // 注册 XposedBridge 关联的 JNI 方法 if (register_natives_XposedBridge(env, classXposedBridge) != JNI_OK) { ALOGE(&quot;Could not register natives for '%s'&quot;, CLASS_XPOSED_BRIDGE); logExceptionStackTrace(); env-&gt;ExceptionClear(); return false; } // 缓存 XposedBridge 的 handleHookedMethod 方法的 jmethodID methodXposedBridgeHandleHookedMethod = env-&gt;GetStaticMethodID(classXposedBridge, &quot;handleHookedMethod&quot;, &quot;(Ljava/lang/reflect/Member;ILjava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;); if (methodXposedBridgeHandleHookedMethod == NULL) { ALOGE(&quot;ERROR: could not find method %s.handleHookedMethod(Member, int, Object, Object, Object[])&quot;, CLASS_XPOSED_BRIDGE); logExceptionStackTrace(); env-&gt;ExceptionClear(); return false; } return true;} 12345678910111213141516// libxposed_common.cppint register_natives_XposedBridge(JNIEnv* env, jclass clazz) { const JNINativeMethod methods[] = { NATIVE_METHOD(XposedBridge, hadInitErrors, &quot;()Z&quot;), NATIVE_METHOD(XposedBridge, getStartClassName, &quot;()Ljava/lang/String;&quot;), NATIVE_METHOD(XposedBridge, getRuntime, &quot;()I&quot;), NATIVE_METHOD(XposedBridge, startsSystemServer, &quot;()Z&quot;), NATIVE_METHOD(XposedBridge, getXposedVersion, &quot;()I&quot;), NATIVE_METHOD(XposedBridge, initXResourcesNative, &quot;()Z&quot;), // 注册 hookMethodNative 方法 NATIVE_METHOD(XposedBridge, hookMethodNative, &quot;(Ljava/lang/reflect/Member;Ljava/lang/Class;ILjava/lang/Object;)V&quot;), // ... }; return env-&gt;RegisterNatives(clazz, methods, NELEM(methods));} 其中 NATIVE_METHOD 是一个宏，方便注册 JNI 方法： 123456// libxposed_common.h#ifndef NATIVE_METHOD#define NATIVE_METHOD(className, functionName, signature) \\ { #functionName, signature, reinterpret_cast&lt;void*&gt;(className ## _ ## functionName) }#endif 现在回去，对 hookMethodNative 的具体实现进行分析，从这里开始就是真正开始实现方法 Hook 了。 由于这里是 Xposed 方法 Hook 的核心实现，所以同时分析一下基于 Dalvik 的实现。 Dalvik Hook 实现首先看一下 libxposed_dalvik.so 中的实现，验证一下本文开头基于 Dalvik 的方法 Hook 的描述。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// libxposed_dalvik.cppvoid XposedBridge_hookMethodNative(JNIEnv* env, jclass clazz, jobject reflectedMethodIndirect, jobject declaredClassIndirect, jint slot, jobject additionalInfoIndirect) { if (declaredClassIndirect == NULL || reflectedMethodIndirect == NULL) { dvmThrowIllegalArgumentException(&quot;method and declaredClass must not be null&quot;); return; } // 获取 Dalvik 中表示 Java 类的 ClassObject 对象 ClassObject* declaredClass = (ClassObject*) dvmDecodeIndirectRef(dvmThreadSelf(), declaredClassIndirect); // 利用 slot 变量从 ClassObject 中找到 Dalvik 中表示 Java 方法的 Method 对象 Method* method = dvmSlotToMethod(declaredClass, slot); if (method == NULL) { dvmThrowNoSuchMethodError(&quot;Could not get internal representation for method&quot;); return; } // inline bool isMethodHooked(const Method* method) { // return (method-&gt;nativeFunc == &amp;hookedMethodCallback); // } if (isMethodHooked(method)) { // 此方法已经被 Hook，直接返回 return; } // 保存原始方法的信息 XposedHookInfo* hookInfo = (XposedHookInfo*) calloc(1, sizeof(XposedHookInfo)); memcpy(hookInfo, method, sizeof(hookInfo-&gt;originalMethodStruct)); hookInfo-&gt;reflectedMethod = dvmDecodeIndirectRef(dvmThreadSelf(), env-&gt;NewGlobalRef(reflectedMethodIndirect)); hookInfo-&gt;additionalInfo = dvmDecodeIndirectRef(dvmThreadSelf(), env-&gt;NewGlobalRef(additionalInfoIndirect)); // 将此 Java 方法增加 native 描述符，即 JNI 方法 SET_METHOD_FLAG(method, ACC_NATIVE); // 设置 native 函数的处理函数，那么 Dalvik 解释执行这个方法时， // 首先判断会它是 JNI 方法，然后会跳转至 nativeFunc 进行执行 method-&gt;nativeFunc = &amp;hookedMethodCallback; method-&gt;insns = (const u2*) hookInfo; method-&gt;registersSize = method-&gt;insSize; method-&gt;outsSize = 0; if (PTR_gDvmJit != NULL) { char currentValue = *((char*)PTR_gDvmJit + MEMBER_OFFSET_VAR(DvmJitGlobals,codeCacheFull)); if (currentValue == 0 || currentValue == 1) { MEMBER_VAL(PTR_gDvmJit, DvmJitGlobals, codeCacheFull) = true; } else { ALOGE(&quot;Unexpected current value for codeCacheFull: %d&quot;, currentValue); } }} 这里 Xposed 基于 Dalvik 实现的方法 Hook 处理比较简单，就是先将这个 Java 方法修改为 native 方法，然后给它绑定一个 nativeFunc，当 Java 代码调用这个方法时，由于它是 JNI 方法，虚拟机就会跳转到 nativeFunc 进行执行。 Dalvik 虚拟机执行 Java 方法的实现如下： 123456789101112131415// Stack.cppvoid dvmCallMethodV(Thread* self, const Method* method, Object* obj, bool fromJni, JValue* pResult, va_list args){ // ... if (dvmIsNativeMethod(method)) { TRACE_METHOD_ENTER(self, method); // 如果是 native 方法，则跳转 nativeFunc 进行执行 (*method-&gt;nativeFunc)((u4*)self-&gt;interpSave.curFrame, pResult, method, self); TRACE_METHOD_EXIT(self, method); } else { dvmInterpret(self, method, pResult); } // ...} 12345// Object.hINLINE bool dvmIsNativeMethod(const Method* method) { return (method-&gt;accessFlags &amp; ACC_NATIVE) != 0;} 可以看到，如果一个方法是 JNI 方法，那么 Dalvik 虚拟机就会调用它绑定的 nativeFunc 函数。 前面设置的 hookedMethodCallback 函数将会把被调用的 Java 方法的参数进行转发，最终会调用 Java 层 XposedBridge 的 handleHookedMethod 方法进行处理，就能够达到 Hook 的目的了，至于 hookedMethodCallback 函数的实现，这里不再详细分析，可以自己看一下。Java 层 handleHookedMethod 方法的实现和 ART 没有区别，都是在 XposedBridge.jar 中，在下面 ART 部分中会进行分析。 下面进入 libxposed_art.so 中的 hookMethodNative 函数实现： ART Hook 实现接下来关注 libxposed_art.so 中的实现。 1234567891011121314151617181920// libxposed_art.cppvoid XposedBridge_hookMethodNative(JNIEnv* env, jclass, jobject javaReflectedMethod, jobject, jint, jobject javaAdditionalInfo) { ScopedObjectAccess soa(env); if (javaReflectedMethod == nullptr) {#if PLATFORM_SDK_VERSION &gt;= 23 ThrowIllegalArgumentException(&quot;method must not be null&quot;);#else ThrowIllegalArgumentException(nullptr, &quot;method must not be null&quot;);#endif return; } // ART 虚拟机中表示 Java 方法的 artMethod 对象 ArtMethod* artMethod = ArtMethod::FromReflectedMethod(soa, javaReflectedMethod); // fHook 这个方法 artMethod-&gt;EnableXposedHook(soa, javaAdditionalInfo);} 上面使用 Java 层方法的反射表示对象 javaReflectedMethod，获取了一个 ART 虚拟机中用来表示 Java 方法的 ArtMethod 对象，然后就直接进入 ArtMethod 的 EnableXposedHook 函数中了。 其中 FromReflectedMethod 是 ART 虚拟机本来就有的方法；ScopedObjectAccess 是一个工具类，需要借助 env 进行操作。 下面进入 ArtMethod 的 EnableXposedHook 函数中，从这里开始就进入 Xposed 修改过的 ART 虚拟机的项目 android_art 中了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// art_method.ccvoid ArtMethod::EnableXposedHook(ScopedObjectAccess&amp; soa, jobject additional_info) { if (UNLIKELY(IsXposedHookedMethod())) { // 已被 Hook return; } else if (UNLIKELY(IsXposedOriginalMethod())) { // 是用于备份的 ArtMethod 对象，通常不应该走到这 ThrowIllegalArgumentException(StringPrintf(&quot;Cannot hook the method backup: %s&quot;, PrettyMethod(this).c_str()).c_str()); return; } // 获取 ClassLinker，它是链接器 auto* cl = Runtime::Current()-&gt;GetClassLinker(); // 获取线性分配器，用于分配内存，类似于 malloc auto* linear_alloc = cl-&gt;GetAllocatorForClassLoader(GetClassLoader()); // 创建一个新的 ArtMethod 对象，用于备份原始方法 ArtMethod* backup_method = cl-&gt;CreateRuntimeMethod(linear_alloc); // 复制当前 ArtMethod 至 backup_method backup_method-&gt;CopyFrom(this, cl-&gt;GetImagePointerSize()); // 添加 kAccXposedOriginalMethod 标记，说明是备份的方法 backup_method-&gt;SetAccessFlags(backup_method-&gt;GetAccessFlags() | kAccXposedOriginalMethod); // 创建备份方法对应的反射对象 mirror::AbstractMethod* reflected_method; if (IsConstructor()) { reflected_method = mirror::Constructor::CreateFromArtMethod(soa.Self(), backup_method); } else { reflected_method = mirror::Method::CreateFromArtMethod(soa.Self(), backup_method); } reflected_method-&gt;SetAccessible&lt;false&gt;(true); // 将备份的方法和一路从 Java 层传过来的 additional_info（包含处理 Hook 的回调）装到 XposedHookInfo 对象中 XposedHookInfo* hook_info = reinterpret_cast&lt;XposedHookInfo*&gt;(linear_alloc-&gt;Alloc(soa.Self(), sizeof(XposedHookInfo))); hook_info-&gt;reflected_method = soa.Vm()-&gt;AddGlobalRef(soa.Self(), reflected_method); hook_info-&gt;additional_info = soa.Env()-&gt;NewGlobalRef(additional_info); hook_info-&gt;original_method = backup_method; ScopedThreadSuspension sts(soa.Self(), kSuspended); jit::ScopedJitSuspend sjs; gc::ScopedGCCriticalSection gcs(soa.Self(), gc::kGcCauseXposed, gc::kCollectorTypeXposed); ScopedSuspendAll ssa(__FUNCTION__); // 清除本方法的调用者信息 cl-&gt;InvalidateCallersForMethod(soa.Self(), this); jit::Jit* jit = art::Runtime::Current()-&gt;GetJit(); if (jit != nullptr) { // 将本方法的 CodeCache 中的内容移动到备份方法对象中 // CodeCache 就是从 Dex 文件中解析到的类和方法的相关信息， // 缓存起来，方便直接取用，而不是每次都解析 Dex 文件 jit-&gt;GetCodeCache()-&gt;MoveObsoleteMethod(this, backup_method); } // 将 hook_info 保存在用于原本用于存储 JNI 方法的内存地址上 SetEntryPointFromJniPtrSize(reinterpret_cast&lt;uint8_t*&gt;(hook_info), sizeof(void*)); // 设置此方法对应的汇编代码的地址，一个 Java 方法经过编译器编译后会对应一段汇编代码， // 当虚拟机执行这个 Java 方法时，如果处于 AOT 模式，就会直接跳转到汇编代码执行机器指令 SetEntryPointFromQuickCompiledCode(GetQuickProxyInvokeHandler()); // 设置 dex 中此方法的偏移为 0，表示它是 native 或 abstract 方法，没有具体代码 SetCodeItemOffset(0); // 清除以下标志 const uint32_t kRemoveFlags = kAccNative | kAccSynchronized | kAccAbstract | kAccDefault | kAccDefaultConflict; // 添加 Xposed 自定义的 kAccXposedHookedMethod 标志，用来标识它是被 Hook 的方法 // 添加后，IsXposedHookedMethod 函数就会返回 true SetAccessFlags((GetAccessFlags() &amp; ~kRemoveFlags) | kAccXposedHookedMethod); MutexLock mu(soa.Self(), *Locks::thread_list_lock_); Runtime::Current()-&gt;GetThreadList()-&gt;ForEach(StackReplaceMethodAndInstallInstrumentation, this);} 上面代码的主要工作是备份当前需要被 Hook 的方法，然后设置当前方法的汇编代码地址为 GetQuickProxyInvokeHandler()，此时就完成了 Hook 目的。 当这个 Java 方法被调用时，会跳转到上面设置的汇编代码地址处，Xposed 将会对这个 Java 方法的参数进行转发等处理，修改方法返回值，实现最终 Hook。 不过没有看到最终的处理，并不知道是怎么做的，下面继续分析。 首先看 GetQuickProxyInvokeHandler() 的返回值： 1234extern &quot;C&quot; void art_quick_proxy_invoke_handler();static inline const void* GetQuickProxyInvokeHandler() { return reinterpret_cast&lt;const void*&gt;(art_quick_proxy_invoke_handler);} 它是一个 art_quick_proxy_invoke_handler 函数的地址，这个函数是在其他地方实现的（有 extern 声明），经过了解，发现它是由汇编代码实现的，有 arm、arm64、mips、mips64、x86、x86_64 这几个指令集的实现，这里看一下 arm 上的实现： 1234567891011121314151617181920// quick_entrypoints_arm.S.extern artQuickProxyInvokeHandlerENTRY art_quick_proxy_invoke_handler SETUP_REFS_AND_ARGS_CALLEE_SAVE_FRAME_WITH_METHOD_IN_R0 // 传递相关参数 mov r2, r9 @ pass Thread::Current mov r3, sp @ pass SP // 跳转至 artQuickProxyInvokeHandler 函数 blx artQuickProxyInvokeHandler @ (Method* proxy method, receiver, Thread*, SP) ldr r2, [r9, #THREAD_EXCEPTION_OFFSET] @ load Thread::Current()-&gt;exception_ add sp, #(FRAME_SIZE_REFS_AND_ARGS_CALLEE_SAVE - FRAME_SIZE_REFS_ONLY_CALLEE_SAVE) .cfi_adjust_cfa_offset -(FRAME_SIZE_REFS_AND_ARGS_CALLEE_SAVE - FRAME_SIZE_REFS_ONLY_CALLEE_SAVE) RESTORE_REFS_ONLY_CALLEE_SAVE_FRAME cbnz r2, 1f @ success if no exception is pending vmov d0, r0, r1 @ store into fpr, for when it's a fpr return... bx lr @ return on success1: DELIVER_PENDING_EXCEPTIONEND art_quick_proxy_invoke_handler art_quick_proxy_invoke_handler 跳转至了 artQuickProxyInvokeHandler 函数中，那么继续跟进。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// qucik_trampoline_entrypoints.ccextern &quot;C&quot; uint64_t artQuickProxyInvokeHandler( ArtMethod* proxy_method, mirror::Object* receiver, Thread* self, ArtMethod** sp) SHARED_REQUIRES(Locks::mutator_lock_) { // bool IsXposedHookedMethod() { // return (GetAccessFlags() &amp; kAccXposedHookedMethod) != 0; // } const bool is_xposed = proxy_method-&gt;IsXposedHookedMethod(); if (!is_xposed) { DCHECK(proxy_method-&gt;IsRealProxyMethod()) &lt;&lt; PrettyMethod(proxy_method); DCHECK(receiver-&gt;GetClass()-&gt;IsProxyClass()) &lt;&lt; PrettyMethod(proxy_method); } const char* old_cause = self-&gt;StartAssertNoThreadSuspension(&quot;Adding to IRT proxy object arguments&quot;); DCHECK_EQ((*sp), proxy_method) &lt;&lt; PrettyMethod(proxy_method); self-&gt;VerifyStack(); JNIEnvExt* env = self-&gt;GetJniEnv(); ScopedObjectAccessUnchecked soa(env); ScopedJniEnvLocalRefState env_state(env); const bool is_static = proxy_method-&gt;IsStatic(); jobject rcvr_jobj = is_static ? nullptr : soa.AddLocalReference&lt;jobject&gt;(receiver); ArtMethod* non_proxy_method = proxy_method-&gt;GetInterfaceMethodIfProxy(sizeof(void*)); CHECK(is_xposed || !non_proxy_method-&gt;IsStatic()) &lt;&lt; PrettyMethod(proxy_method) &lt;&lt; &quot; &quot; &lt;&lt; PrettyMethod(non_proxy_method); std::vector&lt;jvalue&gt; args; uint32_t shorty_len = 0; const char* shorty = non_proxy_method-&gt;GetShorty(&amp;shorty_len); BuildQuickArgumentVisitor local_ref_visitor(sp, is_static, shorty, shorty_len, &amp;soa, &amp;args); local_ref_visitor.VisitArguments(); if (!is_static) { DCHECK_GT(args.size(), 0U) &lt;&lt; PrettyMethod(proxy_method); args.erase(args.begin()); } if (is_xposed) { jmethodID proxy_methodid = soa.EncodeMethod(proxy_method); self-&gt;EndAssertNoThreadSuspension(old_cause); // 处理 Hook 方法 JValue result = InvokeXposedHandleHookedMethod(soa, shorty, rcvr_jobj, proxy_methodid, args); local_ref_visitor.FixupReferences(); // 返回 Java 方法的返回值 return result.GetJ(); } // ...} 可以大概看出来 artQuickProxyInvokeHandler 函数是用于处理动态代理方法的，不过 Xposed 对这个方法进行了修改，使其能够处理被 Hook 的方法，重点关注下面判断语句中的代码，如果是被 Xposed Hook 的方法，那么进入 InvokeXposedHandleHookedMethod 进行处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// entrypoint_utils.ccJValue InvokeXposedHandleHookedMethod(ScopedObjectAccessAlreadyRunnable&amp; soa, const char* shorty, jobject rcvr_jobj, jmethodID method, std::vector&lt;jvalue&gt;&amp; args) { soa.Self()-&gt;AssertThreadSuspensionIsAllowable(); jobjectArray args_jobj = nullptr; const JValue zero; int32_t target_sdk_version = Runtime::Current()-&gt;GetTargetSdkVersion(); // ... // 取出 hook_info const XposedHookInfo* hook_info = soa.DecodeMethod(method)-&gt;GetXposedHookInfo(); // 调用 Java 层的 XposedBridge.handleHookedMethod 方法 jvalue invocation_args[5]; invocation_args[0].l = hook_info-&gt;reflected_method; invocation_args[1].i = 1; invocation_args[2].l = hook_info-&gt;additional_info; // 方法的目标作用对象 this invocation_args[3].l = rcvr_jobj; // 参数保存传给方法的参数 invocation_args[4].l = args_jobj; jobject result = soa.Env()-&gt;CallStaticObjectMethodA(ArtMethod::xposed_callback_class, ArtMethod::xposed_callback_method, invocation_args); if (UNLIKELY(soa.Self()-&gt;IsExceptionPending())) { return zero; } else { if (shorty[0] == 'V' || (shorty[0] == 'L' &amp;&amp; result == nullptr)) { return zero; } size_t pointer_size = Runtime::Current()-&gt;GetClassLinker()-&gt;GetImagePointerSize(); mirror::Class* result_type = soa.DecodeMethod(method)-&gt;GetReturnType(true /* resolve */, pointer_size); mirror::Object* result_ref = soa.Decode&lt;mirror::Object*&gt;(result); JValue result_unboxed; if (!UnboxPrimitiveForResult(result_ref, result_type, &amp;result_unboxed)) { DCHECK(soa.Self()-&gt;IsExceptionPending()); return zero; } return result_unboxed; }} 这里就调用到了 Java 层 XposedBridge 的 handleHookedMethod 方法中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// XposedBridge.javaprivate static Object handleHookedMethod(Member method, int originalMethodId, Object additionalInfoObj, Object thisObject, Object[] args) throws Throwable { // 取出 Hook 处理回调等信息 AdditionalHookInfo additionalInfo = (AdditionalHookInfo) additionalInfoObj; if (disableHooks) { try { // 如果关闭 Hook，那么调用原始方法 return invokeOriginalMethodNative(method, originalMethodId, additionalInfo.parameterTypes, additionalInfo.returnType, thisObject, args); } catch (InvocationTargetException e) { throw e.getCause(); } } Object[] callbacksSnapshot = additionalInfo.callbacks.getSnapshot(); final int callbacksLength = callbacksSnapshot.length; if (callbacksLength == 0) { try { // 没有处理 Hook 的回调，则调用原始方法 return invokeOriginalMethodNative(method, originalMethodId, additionalInfo.parameterTypes, additionalInfo.returnType, thisObject, args); } catch (InvocationTargetException e) { throw e.getCause(); } } MethodHookParam param = new MethodHookParam(); param.method = method; param.thisObject = thisObject; param.args = args; int beforeIdx = 0; do { try { // 回调 beforeHookedMethod 方法，表示在 Hook 之前 ((XC_MethodHook) callbacksSnapshot[beforeIdx]).beforeHookedMethod(param); } catch (Throwable t) { XposedBridge.log(t); param.setResult(null); param.returnEarly = false; continue; } if (param.returnEarly) { beforeIdx++; break; } } while (++beforeIdx &lt; callbacksLength); // Hook 回调没有处理，则调用原始方法 if (!param.returnEarly) { try { param.setResult(invokeOriginalMethodNative(method, originalMethodId, additionalInfo.parameterTypes, additionalInfo.returnType, param.thisObject, param.args)); } catch (InvocationTargetException e) { param.setThrowable(e.getCause()); } } int afterIdx = beforeIdx - 1; do { Object lastResult = param.getResult(); Throwable lastThrowable = param.getThrowable(); try { // 调用 afterHookedMethod 方法，表示 Hook 之后 ((XC_MethodHook) callbacksSnapshot[afterIdx]).afterHookedMethod(param); } catch (Throwable t) { XposedBridge.log(t); if (lastThrowable == null) param.setResult(lastResult); else param.setThrowable(lastThrowable); } } while (--afterIdx &gt;= 0); // 如果有异常，则抛出异常，否则返回处理后的结果 if (param.hasThrowable()) throw param.getThrowable(); else return param.getResult();} 这里就能清晰的看到 Hook 最终处理了，至此就完成了 Hook。其中 invokeOriginalMethodNative 的实现如下： 12345678910111213141516171819// libxposed_art.cppjobject XposedBridge_invokeOriginalMethodNative(JNIEnv* env, jclass, jobject javaMethod, jint isResolved, jobjectArray, jclass, jobject javaReceiver, jobjectArray javaArgs) { ScopedFastNativeObjectAccess soa(env); if (UNLIKELY(!isResolved)) { // 从备份的方法中取得原始方法 ArtMethod* artMethod = ArtMethod::FromReflectedMethod(soa, javaMethod); if (LIKELY(artMethod-&gt;IsXposedHookedMethod())) { javaMethod = artMethod-&gt;GetXposedHookInfo()-&gt;reflected_method; } }#if PLATFORM_SDK_VERSION &gt;= 23 // 调用虚拟机的执行方法调用原始方法逻辑 return InvokeMethod(soa, javaMethod, javaReceiver, javaArgs);#else return InvokeMethod(soa, javaMethod, javaReceiver, javaArgs, true);#endif} 还有最后一个问题，就是一个被 Hook 的方法的调用过程，上面只分析了处理过程，而没有正向的调用，下面开始分析。 调用过程分析一个 Java 方法的调用，可以从 AndroidRuntime.start 中开始，Java 虚拟机执行的第一个类是 ZygoteInit 从此就进入了 Java 层，它使用的是 JNIEnv 提供的 CallStaticVoidMethod 方法，看一下它的实现。 12345678910// jni_internal.ccstatic void CallStaticVoidMethod(JNIEnv* env, jclass, jmethodID mid, ...) { va_list ap; va_start(ap, mid); CHECK_NON_NULL_ARGUMENT_RETURN_VOID(mid); ScopedObjectAccess soa(env); InvokeWithVarArgs(soa, nullptr, mid, ap); va_end(ap);} 调用了 InvokeWithVarArgs 函数： 12345678910111213141516171819202122232425// reflection.ccJValue InvokeWithVarArgs(const ScopedObjectAccessAlreadyRunnable&amp; soa, jobject obj, jmethodID mid, va_list args) SHARED_REQUIRES(Locks::mutator_lock_) { // ... ArtMethod* method = soa.DecodeMethod(mid); bool is_string_init = method-&gt;GetDeclaringClass()-&gt;IsStringClass() &amp;&amp; method-&gt;IsConstructor(); if (is_string_init) { method = soa.DecodeMethod(WellKnownClasses::StringInitToStringFactoryMethodID(mid)); } mirror::Object* receiver = method-&gt;IsStatic() ? nullptr : soa.Decode&lt;mirror::Object*&gt;(obj); uint32_t shorty_len = 0; const char* shorty = method-&gt;GetInterfaceMethodIfProxy(sizeof(void*))-&gt;GetShorty(&amp;shorty_len); JValue result; ArgArray arg_array(shorty, shorty_len); arg_array.BuildArgArrayFromVarArgs(soa, receiver, args); // 调用 InvokeWithArgArray InvokeWithArgArray(soa, method, &amp;arg_array, &amp;result, shorty); if (is_string_init) { UpdateReference(soa.Self(), obj, result.GetL()); } return result;} 继续看 InvokeWithArgArray： 123456789101112// reflection.ccstatic void InvokeWithArgArray(const ScopedObjectAccessAlreadyRunnable&amp; soa, ArtMethod* method, ArgArray* arg_array, JValue* result, const char* shorty) SHARED_REQUIRES(Locks::mutator_lock_) { uint32_t* args = arg_array-&gt;GetArray(); if (UNLIKELY(soa.Env()-&gt;check_jni)) { CheckMethodArguments(soa.Vm(), method-&gt;GetInterfaceMethodIfProxy(sizeof(void*)), args); } method-&gt;Invoke(soa.Self(), args, arg_array-&gt;GetNumBytes(), result, shorty);} 最终是调用到了 ArtMethod 的 Invoke 函数： 12345678910111213141516171819202122232425262728293031323334// reflection.ccvoid ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result, const char* shorty) { // ... ManagedStack fragment; self-&gt;PushManagedStackFragment(&amp;fragment); Runtime* runtime = Runtime::Current(); if (UNLIKELY(!runtime-&gt;IsStarted() || Dbg::IsForcedInterpreterNeededForCalling(self, this))) { // ... } else { DCHECK_EQ(runtime-&gt;GetClassLinker()-&gt;GetImagePointerSize(), sizeof(void*)); constexpr bool kLogInvocationStartAndReturn = false; bool have_quick_code = GetEntryPointFromQuickCompiledCode() != nullptr; if (LIKELY(have_quick_code)) { // ... if (!IsStatic()) { (*art_quick_invoke_stub)(this, args, args_size, self, result, shorty); } else { (*art_quick_invoke_static_stub)(this, args, args_size, self, result, shorty); } // ... } else { // ... } } self-&gt;PopManagedStackFragment(fragment);} 根据 Java 方法类型是非静态还是静态，跳入 art_quick_invoke_stub 或 art_quick_invoke_static_stub，看一下 art_quick_invoke_stub： 123456// reflection.ccextern &quot;C&quot; void art_quick_invoke_stub(ArtMethod* method, uint32_t* args, uint32_t args_size, Thread* self, JValue* result, const char* shorty) { quick_invoke_reg_setup&lt;false&gt;(method, args, args_size, self, result, shorty);} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// reflection.cctemplate &lt;bool kIsStatic&gt;static void quick_invoke_reg_setup(ArtMethod* method, uint32_t* args, uint32_t args_size, Thread* self, JValue* result, const char* shorty) { uint32_t core_reg_args[4]; uint32_t fp_reg_args[16]; uint32_t gpr_index = 1; uint32_t fpr_index = 0; uint32_t fpr_double_index = 0; uint32_t arg_index = 0; const uint32_t result_in_float = kArm32QuickCodeUseSoftFloat ? 0 : (shorty[0] == 'F' || shorty[0] == 'D') ? 1 : 0; if (!kIsStatic) { core_reg_args[gpr_index++] = args[arg_index++]; } for (uint32_t shorty_index = 1; shorty[shorty_index] != '\\0'; ++shorty_index, ++arg_index) { char arg_type = shorty[shorty_index]; if (kArm32QuickCodeUseSoftFloat) { arg_type = (arg_type == 'D') ? 'J' : arg_type; arg_type = (arg_type == 'F') ? 'I' : arg_type; } switch (arg_type) { case 'D': { fpr_double_index = std::max(fpr_double_index, RoundUp(fpr_index, 2)); if (fpr_double_index &lt; arraysize(fp_reg_args)) { fp_reg_args[fpr_double_index++] = args[arg_index]; fp_reg_args[fpr_double_index++] = args[arg_index + 1]; } ++arg_index; break; } case 'F': if (fpr_index % 2 == 0) { fpr_index = std::max(fpr_double_index, fpr_index); } if (fpr_index &lt; arraysize(fp_reg_args)) { fp_reg_args[fpr_index++] = args[arg_index]; } break; // ... } } // 进入下一步 art_quick_invoke_stub_internal(method, args, args_size, self, result, result_in_float, core_reg_args, fp_reg_args);} 最后是调用了 art_quick_invoke_stub_internal，它是汇编代码实现的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// quick_entrypoints_arm.SENTRY art_quick_invoke_stub_internal SPILL_ALL_CALLEE_SAVE_GPRS @ spill regs (9) mov r11, sp @ save the stack pointer .cfi_def_cfa_register r11 mov r9, r3 @ move managed thread pointer into r9 add r4, r2, #4 @ create space for method pointer in frame sub r4, sp, r4 @ reserve &amp; align *stack* to 16 bytes: native calling and r4, #0xFFFFFFF0 @ convention only aligns to 8B, so we have to ensure ART mov sp, r4 @ 16B alignment ourselves. mov r4, r0 @ save method* add r0, sp, #4 @ pass stack pointer + method ptr as dest for memcpy bl memcpy @ memcpy (dest, src, bytes) mov ip, #0 @ set ip to 0 str ip, [sp] @ store null for method* at bottom of frame ldr ip, [r11, #48] @ load fp register argument array pointer vldm ip, {s0-s15} @ copy s0 - s15 ldr ip, [r11, #44] @ load core register argument array pointer mov r0, r4 @ restore method* add ip, ip, #4 @ skip r0 ldm ip, {r1-r3} @ copy r1 - r3#ifdef ARM_R4_SUSPEND_FLAG mov r4, #SUSPEND_CHECK_INTERVAL @ reset r4 to suspend check interval#endif ldr ip, [r0, #ART_METHOD_QUICK_CODE_OFFSET_32] @ get pointer to the code blx ip @ call the method mov sp, r11 @ restore the stack pointer .cfi_def_cfa_register sp ldr r4, [sp, #40] @ load result_is_float ldr r9, [sp, #36] @ load the result pointer cmp r4, #0 ite eq strdeq r0, [r9] @ store r0/r1 into result pointer vstrne d0, [r9] @ store s0-s1/d0 into result pointer pop {r4, r5, r6, r7, r8, r9, r10, r11, pc} @ restore spill regsEND art_quick_invoke_stub_internal 其中中间部分一行代码使用 ldr 指令设置 ip 寄存器的位置来指示指令地址，使用到了 ART_METHOD_QUICK_CODE_OFFSET_32 这个宏，它是 32，表示 EntryPointFromQuickCompiledCodeOffset 这个函数返回的成员的偏移，也就是 entry_point_from_quick_compiled_code_。 12345// asm_support.h#define ART_METHOD_QUICK_CODE_OFFSET_32 32ADD_TEST_EQ(ART_METHOD_QUICK_CODE_OFFSET_32, art::ArtMethod::EntryPointFromQuickCompiledCodeOffset(4).Int32Value()) 123456// art_method.hstatic MemberOffset EntryPointFromQuickCompiledCodeOffset(size_t pointer_size) { return MemberOffset(PtrSizedFieldsOffset(pointer_size) + OFFSETOF_MEMBER( PtrSizedFields, entry_point_from_quick_compiled_code_) / sizeof(void*) * pointer_size);} 回到前面 Hook 时，使用了 SetEntryPointFromQuickCompiledCode，其实就是设置这个变量。 123456789101112// art_method.hvoid SetEntryPointFromQuickCompiledCode(const void* entry_point_from_quick_compiled_code) { SetEntryPointFromQuickCompiledCodePtrSize(entry_point_from_quick_compiled_code, sizeof(void*)); } ALWAYS_INLINE void SetEntryPointFromQuickCompiledCodePtrSize( const void* entry_point_from_quick_compiled_code, size_t pointer_size) { DCHECK(Runtime::Current()-&gt;IsAotCompiler() || !IsXposedHookedMethod()); SetNativePointer(EntryPointFromQuickCompiledCodeOffset(pointer_size), entry_point_from_quick_compiled_code, pointer_size); } 那么下一步使用了 blx 跳转指令，代码就会跳转到这个地址上执行，进入 GetQuickProxyInvokeHandler 返回的地址 art_quick_proxy_invoke_handler 中， 最后执行 artQuickProxyInvokeHandler 函数，Xposed 在这个函数里面处理了 Hook，完成 Hook。 到这里就分析完了 Xposed 的实现，其实还有很多细节没有去分析，通过对比 ART 虚拟机的原始代码和 Xposed 修改后的代码，发现 Xposed 修改的地方还是很多的，大概有几百处，虽然每个文件修改的代码不多，但是足以说明 Xposed 作者对于 Android 系统原理和 ART 虚拟机的了解的深入程度。 总结通过分析 Xposed 的实现原理，对于 Java 方法的 Hook 原理有了一些了解，同时回顾了 Android zygote 进程相关的内容，对于 ART 虚拟机执行方法的过程也有了一个大概的认识。 参考 https://bbs.pediy.com/thread-257844.htm https://blog.csdn.net/Innost/article/details/50461783 https://blog.csdn.net/Luoshengyang/article/details/39256813 https://blog.csdn.net/Luoshengyang/article/details/8914953","link":"/2020/10/11/xposed-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Android","slug":"android","link":"/tags/android/"},{"name":"Activity","slug":"activity","link":"/tags/activity/"},{"name":"Assembly","slug":"assembly","link":"/tags/assembly/"},{"name":"Xposed","slug":"xposed","link":"/tags/xposed/"},{"name":"Git","slug":"git","link":"/tags/git/"},{"name":"Regex","slug":"regex","link":"/tags/regex/"},{"name":"ClassLoader","slug":"classloader","link":"/tags/classloader/"},{"name":"热更新","slug":"热更新","link":"/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"热修复","slug":"热修复","link":"/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"},{"name":"Java","slug":"java","link":"/tags/java/"},{"name":"MarkDown","slug":"markdown","link":"/tags/markdown/"},{"name":"Computer","slug":"computer","link":"/tags/computer/"},{"name":"Emulator","slug":"emulator","link":"/tags/emulator/"},{"name":"AVD","slug":"avd","link":"/tags/avd/"},{"name":"SSH","slug":"ssh","link":"/tags/ssh/"},{"name":"ARM","slug":"arm","link":"/tags/arm/"},{"name":"Metrial","slug":"metrial","link":"/tags/metrial/"},{"name":"Log","slug":"log","link":"/tags/log/"},{"name":"Binder","slug":"binder","link":"/tags/binder/"},{"name":"Touch","slug":"touch","link":"/tags/touch/"},{"name":"View","slug":"view","link":"/tags/view/"},{"name":"aapt","slug":"aapt","link":"/tags/aapt/"},{"name":"NDK","slug":"ndk","link":"/tags/ndk/"},{"name":"JNI","slug":"jni","link":"/tags/jni/"},{"name":"Zygote","slug":"zygote","link":"/tags/zygote/"},{"name":"Theme","slug":"theme","link":"/tags/theme/"},{"name":"Makefile","slug":"makefile","link":"/tags/makefile/"},{"name":"Make","slug":"make","link":"/tags/make/"},{"name":"Dex","slug":"dex","link":"/tags/dex/"},{"name":"ELF","slug":"elf","link":"/tags/elf/"}],"categories":[{"name":"Android 应用开发","slug":"android-应用开发","link":"/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"编程基础","slug":"编程基础","link":"/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"Android 逆向工程","slug":"android-逆向工程","link":"/categories/android-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"参考文档","slug":"参考文档","link":"/categories/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/"},{"name":"实用工具","slug":"实用工具","link":"/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"Android 实用工具","slug":"android-实用工具","link":"/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"Android 系统原理","slug":"android-系统原理","link":"/categories/android-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]}
{"pages":[{"title":"关于","text":"Android 程序员Like a robote-mail: l0neman@foxmail.com青春短文 青春——塞缪尔·厄尔曼 ​ 青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的恋情；青春是生命的深泉在涌流。 ​ 青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，方堕暮年。 ​ 岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。 ​ 无论年届花甲，拟或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。 ​ 一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。","link":"/about/index.html"}],"posts":[{"title":"Android Binder 设计分析","text":"前言以下 Binder 设计部分整理至 universus 的博客 Android Bander设计与实现 - 设计篇。 Binder 的优势简介Binder 是 Android 系统中的进程间通信方式之一，它是基于 Client-Server 的通信方式。相较于 Linux 系统中的其他进程间通信方式而言，它具有传输效率高、开销小的特点。 Linux IPCLinux 的进程间通信方式包括管道、system V IPC、socket、消息队列等。 Socket 是一个通用的进程间通信接口，传输效率低，开销大，主要用在跨网络的进程间通信和本机的进程间通信。 管道和消息队列采用存储-转发的方式，首先将数据从发送方复制到内核缓冲区，然后再复制到接收方。 共享内存无需拷贝数据，但是需要复制的控制，难以使用。 IPC 对比各个 IPC 方式的拷贝次数： 通信方式 拷贝次数 共享内存 0 Binder 1 Socker/管道/消息队列 2 Binder 特点相较于以上 Linux 进程间通信方式，针对 Android 设计的 Binder 通信具有如下特点： Binder 采用共享内存的方式，将数据缓存同时映射到接收方和内核空间，发送方只需要拷贝一次数据即可完成通信。 Binder 驱动在转发数据的过程中在通过内核向数据中写入进程的 UID 和 PID，使接收端可验证发送端身份，保证通信安全性，而传统的 Linux IPC 方式则无法通过这种方式鉴别发送方身份。 Binder 使用了面向对象的思想来描述 Server 端的访问接入点和 Client 端的入口，Binder 是一个实体位于 Server 端的对象，它提供了一套访问 Server 端的方法，类似于类的成员方法，Client 端的入口则作为这个 Binder 对象的“句柄”，此时 Client 端访问 Server 端就像调用对象的方法一样容易，同时 Client 端的本地“句柄”对象也可以在进程间相互传递，使各处都可访问同一个 Server，Binder 弱化了进程间通信过程，使整个系统仿佛运行在面向对象的程序中。 总结Binder 作为 Android 系统的主要的进程间通信方式，保证性能的同时，还兼顾了通信安全性和使用的便捷性。 基于 Client-Server 的方式，支持实名和匿名通信，是一种非常适合于便携式和嵌入式设备通信的 IPC 方式 。 Binder 通信模型Binder 通信框架定义了 4 个组件角色，Server，Client，ServiceManager 和 Binder 驱动。 其中 Binder 驱动运行于内核层，它负责实现进程间通信的核心功能，管理每个 Server 端的 Binder 实体对象，以及 Client 中的 Binder 引用，Client 表示向 Server 端发起请求的客户端，Server 作为服务端负责处理 Client 端的请求，ServiceManager 负责管理 Server 的注册和申请，类似 DNS 服务器中注册服务器的域名，和浏览器向 DNS 服务器请求网站真实的 IP 地址的过程。 Binder 驱动 Binder 驱动是一个运行在内核态的标准设备驱动，但是和硬件没有关系，它的实现遵循标准驱动的实现。 Binder 驱动提供了 open()，mmap()，poll()，ioctl() 等标准文件操作，它以字符驱动设备中的 misc 设备注册在 /dev/ 下，用户通过/dev/binder 访问该它。 Binder 驱动负责进程之间 Binder 通信的建立，Binder 在进程间的建立，Binder 在进程间的传递，Binder 引用技术管理，数据包在进程间的传递等底层支持。 Binder 驱动使用 ioctl() 接口实现，它可实现一次调用，读写操作依次同时执行，相较于 read() 和 write() 更加灵活方便。 ServiceManager 和 Server ServiceManager 建立 Binder 名字和 Binder 实体的映射，Client 可通过字符形式的 Binder 名字请求 Binder 的引用。 Server 创建 Binder 实体后，通过驱动将 Binder 名字及实体通过 Binder 驱动发至 ServiceManager 请求注册，驱动在内核中创建对应此 Server 进程中 Binder 实体的对应节点，以及 ServiceManager 中对此 Binder 的引用，然后将 Binder 名字和引用通过数据包传送给 ServiceManager，此时 ServiceManager 将名字和 Binder 引用存入查找表中。 当 Server 向 ServiceManager 请求注册时，这个过程本身就需要进程间通信，需要获取 ServiceManager 中 Binder 实体的引用，由于 ServiceManager 本身负责管理 Binder 的注册和引用的分配，所以在此之前，ServiceManager 通过向驱动发送 BINDER_SET_CONTEXT_MGR 命令请求注册自身为 ServiceManager，当 Server 需要请求 ServiceManager 的 Binder 引用时，只要向驱动请求 0 号引用即可获得，所有 Server 都可通过 0 号引用通过驱动向 ServiceManager 发送注册请求。 对于 ServiceManager 来说，所有的 Server 都是 Client，只不过任务很单一，知识为了注册 Server。 ClientClient 使用 0 号引用通过驱动向 ServiceManager 发送 Binder 名字请求获取 Server 端 Binder 的引用，ServiceManager 此时将会从表中查询 Binder 引用然后通过驱动回复给 Client。此时 Binder 引用在 Client 和 ServiceManager 各存在一个。 BinderBinder 可分为实名 Binder 和匿名 Binder。 实名 Binder 所有将名字和引用注册到 ServiceManager 的 Binder 实体都是实名 Binder。 匿名 Binder 匿名 Binder 指没有在 ServiceManager 中注册名字的 Binder，当 Client 与 Server 建立连接时可将新创建的 Binder 传递给 Client，此时 Client 将和匿名 Binder 实现私密通道，第三方进程无法通过穷举获取匿名 Binder 的引用。 Binder 协议ioctlBinder 协议使用 ioctl(fd, cmd, arg) 函数实现，fd 为驱动的文件描述符，cmd 参数为命令，arg 为参数，每种 cmd 对应的 arg 结构也不同。当通过驱动进行通信时，首先使用 open 打开驱动文件，然后使用返回的文件描述符调用 ioctl 进行通信。 cmd 解释 参数 BINDER_WRITE_READ 向 Binder 发送读写命令，参数分为写和读两部分，如果 write_size 不为 0 则首先将 write_buffer 里的数据写入 Binder，其次 read_size 不为 0 再从 Binder 中读取数据存入 read_buffer 中，write_consumed 和 read_consumed 表示操作完成时 Binder 驱动实际发送的 struct binder_write_read{signed long write_size;signed long write_consumed;unsigned long write_buffer;signed long read_size;signed long read_consumed;unsigned long read_buffer;}; BINDER_SET_MAX_THREADS 告知 Binder 驱动接收方（Server 端）线程池的最大线程数，Client 告知 Server 端需要开辟多大的线程池为并发请求提供服务，为了让驱动发现线程数达到该值时不要再命令接收端启动新的线程。 int max_threads; BINDER_SET_CONTEXT_MGR 注册当前进程为 ServiceManager，直到当前 ServiceManager 调用 close()，系统中只能存在一个 ServiceManager。 - BINDER_THREAD_EXIT 通知 Binder 驱动当前线程退出，驱动会释放为参与 Binder 通信的相应线程建立的结构。 - BINDER_VERSION 获取 Binder 驱动的版本号。 - BINDER_WRITE_READ 写入BINDER_WRITE_READ 命令的数据写入格式为命令+数据，多条命令可连续存放，对应的命令后面写入对应的数据结构，最后将这段内存的指针赋给 binder_write_read 结构体的 write_buffer。 命令 解释 数据 BC_TRANSACTIONBC_REPLY 1. BC_TRANSACTION 用于 Client 端向 Server 端发送请求。2. BC_REPLY 用于 Server 端向 Client 回复数据。3. 命令后面接 binder_transaction_data 用于存放数据。 struct bindertransaction_data BC_ACQUIRE_RESULTBC_ATTEMPT_ACQUIRE 暂未实现 - BC_FREE_BUFFER 释放映射的内存空间，Binder 接收方通过 mmap 方法映射了一块内存，Binder 驱动使用这块内存，采用佳匹配算法实现接收数据缓存的动态分配和释放，满足并发请求对接收缓存区的需求。应用程序处理完这片数据后需要使用该命令释放缓存区，避免因为缓存区耗尽而无法接收新数据。 指向需要释放的缓存区的指针；指针位于收到的 Binder数据包中。 BC_INCREFS BC_ACQUIREBC_RELEASEBC_DECREFS 这组命令增加或减少 Binder 的引用计数，用以实现强指针或弱指针的功能。 32 位 Binder引用号。 BC_INCREFS_DONE BC_ACQUIRE_DONE 1. 第一次增加 Binder 实体引用计数时，驱动向 Binder 实体所在的进程发送 BR_INCREFS, BR_ACQUIRE 消息。2. Binder 实体所在的进程处理完毕回复 BC_INCREFS_DONE，BC_ACQUIRE_DONE。 1. void *ptr：Binder实体在用户空间中的指针。2. void *cookie：与该实体相关的附加数据。 BC_REGISTER_LOOPER BC_ENTER_LOOPERBC_EXIT_LOOPER 1. 与 BINDER_SET_MAX_THREADS 共同实现 Binder 驱动对接收方线程池管理。2. BC_REGISTER_LOOPER 通知驱动线程池中的一个线程已经创建了。3. BC_ENTER_LOOPER 通知驱动该线程已经进入主循环，可以接受数据。4. BC_EXIT_LOOPER 通知驱动该线程退出主循环，不再接受数据。 - BC_REQUEST_DEATH_NOTIFICATION 已经获得 Binder 引用的进程通过此命令请求驱动在 Binder 实体销毁时得到通知。虽然强指针可以确保引用存在时实体不会被销毁，但没人能保证是否由于实体所在的 Server 关闭 Binder 驱动或者异常退出而消失，引用者能做的就是要求 Server 在此时给出通知。 1. uint32 *ptr 需要得到死亡通知的 Binder 引用。2. void **cookie 与死亡通知相关的信息，驱动会在发出死亡通知时返回给发出请求的进程。 BC_DEAD_BINDER_DONE 收到 Binder 实体通知的进程在删除 Binder 引用后使用本命令告知驱动。 void **cookie BINDER_WRITE_READ 读取从 Binder 读取的格式与写入数据格式一致，使用（消息 ID+数据）的形式，多条可连续存放。 命令 解释 参数 BR_ERROR 发生内部错误（如内存分配失败） - BR_OKBR_NOOP 操作完成 - BR_SPAWN_LOOPER 用于接收方线程管理，当驱动发现接收方所有线程都处于忙碌状态且线程池里的线程总数没有 BINDER_SET_MAX_THREADS 设置的最大线程数时，向接收方发送该命令要求创建更多线程以备接受数据。 - BR_TRANSACTIONBR_REPLY 对应发送方的 BC_TRANSCATION 和 BC_REPLY binder_transcation_data BR_ACQUIRE_RESULTBR_ATTEMPT_ACQUIREBR_FINISHED 尚未实现 - BR_DEAD_REPLY 交互过程中如果发现对方进程或线程已经死亡则返回该消息。 - BR_TRANSACTION_COMPLETE 发送方通过 BC_TRANSACTION 或 BC_REPLY 发送完一个数据包后，都能收到该消息作为成功的反馈。无论异步或同步。 - BR_INCREFSBR_ACQUIREBR_RELEASEBR_DECREFS 用于管理强/弱指针的引用计数，只有提供 Binder 实体的进程才能收到该组消息。 1. void *ptr Binder 实体在用户空间的指针。2. void *cookie 与该实体相关的附加数据。 BR_DEAD_BINDERBR_CLEAR_DEATH_NOTIFICATION_DONE 1. 向获得 Binder 引用的进程发送Binder 实体死亡通知书。2. 收到死亡通知书的进程接下来会返回 BC_DEAD_BINDER_DONE 做确认。 void **cookie 在使用BC_REQUEST_DEATH_NOTIFICATION 注册死亡通知时的附加参数。 BR_FAILED_REPLY 如果发送非法引用号则返回该消息。 - binder_transaction_data 结构binder_transaction_data 表示收发数据包结构，使用时将它接在 TRANSACTION 和 RELPY 命令后面。 成员 解释 union {size_t handle;void *ptr;} target; 1. 对于发送数据包的一方，该成员指定发送目的地。由于目的地在远端，所以这里填入的是对 Binder 实体的引用，存放在 target.handle 中。2. 当数据包到达接收方时，驱动将该成员转换成 Binder 实体，即指向 Binder 对象内存的指针，使用 target.ptr 来保存。3. target.ptr 指针是接收方在将 Binder 实体传输给其他进程时提交给驱动的，驱动能够自动将发送方填入的引用转换成接收方 Binder 对象的指针，接收方可直接作为对象指针使用。（通常使用 reinterpret_cast 转换）。 void *cookie 1. 发送方忽略该成员。2. 接收方收到数据包时，该成员存放的是创建 Binder 实体时由该接收方自定义的任意数值，作为与 Binder 指针相关的额外信息存放在驱动中，驱动基本不关心该数据。 unsigned int code; 该成员存放收发双方约定的命令码，驱动完全不关心该成员的内容。一般为 Server 端定义的公共接口函数的编号。 unsigned int flags; 1. 交互相关的标志位2. 当为 TF_ONE_WAY 表示这次交互为异步的，Server 端不会返回数据。驱动利用该位来决定是否建立与返回有关的数据结构。3. 当为 TF_ACCEPT_FDS 是处于安全考虑，如果发起请求的一方不希望再收到回复中接受文件形式的 Binder，当收到一个文件形式的 Binder 会自动为数据接收方打开一个文件，这时可以使用该位避免打开文件过多。 pid_t sender_pid;uid_t sender_euid; 1. 该成员存放发送方的进程 ID 和用户 ID，由驱动负责填入。2. 接收方可以读取该成员获知发送方的身份。 size_t data_size; 1. 该成员表示 data.buffer 指向的缓冲区存放的数据长度。发送数据时由发送方填入，表示即将发送的数据长度。2. 在接收方用来告知接收到数据的长度。 size_t offsets_size; Binder 驱动通常不关心 data.buffer 里存放的数据，但如果有 Binder 在其中传输则需要将其相对 data.buffer 的偏移位置指出来让驱动知道。可能存在多个 Binder 同时在数据中传递，所以须用数组表示所有偏移位置。本成员表示该数组的大小。 union {struct {const void *buffer;const void *offsets;} ptr;uint8_t buf[8];} data; 1. data.buffer 存放要发送或接收到的数据。2. data.offsets 指向 Binder 偏移位置数组，该数组可以位于 data.buffer 中，也可以在另外的内存空间中，并无限制。buf[8] 是为了无论保证 32 位还是 64 位平台，成员 data 的大小都是 8 个字节。 下图说明了 BINDER_WRITE_READ 通信的数据包示例： Binder 层次概述Binder 位于系统以下几个部分： 应用层：位于 Server 进程和 Client 进程中。 Binder 驱动层：分别管理 Server 端的 Binder 实体和 Client 端的引用。 Binder 传输结构：跨进程传递 Binder，使用数据结构描述。 Binder 应用层Binder 使用面向对象的思想设计，但不限于必须使用面向对象的语言实现通信，Native 层的 ServiceManager 就是使用 C 语言实现的。 存在于 Android 应用层的 Server 端通常使用面向对象实现，首先 Server 端为了给 Client 端提供服务，需要实现一套提供服务的接口函数，这时通常采用 Proxy 设计模式，将功能函数抽象成一个接口，Server 和 Client 端同时实现这个接口，Server 实现对应函数的功能，而 Client 则实现对 Server 端对应功能的请求，及代理，此时 Client 端使用 Server 端服务就像直接使用本地方法一样简单。 如何将 Binder 通信和 Proxy 设计模式结合起来是应用程序实现面向对象Binder通信的根本问题。 Binder Server 端 Binder 实体是 Binder 在 Server 端的表述 使用 Binder 通信首先定义包含功能函数的接口，然后 Server 端和 Client 端的 Proxy 类各自实现该接口，由于功能函数需要跨进程调用，所以需要使用数字一一编号，Server 端接收到编号即可决定调用哪个功能函数。此时需要引入 Binder，Server 端定义另一个 Binder 抽象类处理来自 Client 端的 Binder 请求数据包，其中核心成员为 onTransact() 方法，该方法负责接收数据包，然后根据分析数据包处理不同请求。 Binder 数据包的接收 使用继承方式构建一个同时实现功能函数接口和 Binder 抽象类的 Server 端 Binder 实体，并实现所有函数，包括数据包处理函数 onTransact()，它的输入来自 Client 端发出的 binder_transaction_data 结构的数据包。其中有一个 code 成员即为约定的函数调用编号，onTransact() 方法将 case-by-case 解析 code 值，并从数据包中提取函数参数，请求调用相应的功能函数，并将函数执行完毕的数据写回一个新构建的 binder_transaction_data 数据包中返回。 Binder 数据包的分发 Binder 实体必须以 Binder 传输结构 flat_binder_object 的形式发送给其他进程才能建立进程间通信，其中 Binder 实体的引用号存在于其 handle 成员中，Binder 驱动根据 Binder 实体的位置从传输数据结构中获取该 Binder 的传输结构，并创建对应的 Binder 在内核中的节点，当有其他进程向该 Binder 发送数据时，驱动会根据内核节点中记录的信息将 Binder 实体指针填入 binder_transaction_data 中的 target.ptr 成员中返回给接收线程。接收线程中数据包中解析出该指针，使用 reinterpret_cast 将 Binder 转换成 Binder 抽象类，并调用其 onTransact() 函数，即可调用到不同的 Binder 实体的对应的 onTransact() 函数的实现。 Binder Client 端 Binder 引用是 Binder 在 Client 端的表述 Client 端的 Binder 也需要实现和服务的相同的功能函数的接口，但并不是实现功能，而是作为代理实现对远程功能函数的包装，将函数的参数通过 Binder 打包发送至 Server 端，此时 Client 还需要知道 Binder 实体相关的信息，即对实体 Binder 的引用，该引用由 ServiceManager 返回，或者是另一种由另一个进程直接发送过来的对匿名 Binder 的引用。 发送 Binder 请求 由于 Client 端 Binder 实现了和 Server 端相同的功能函数接口，所以 Client 端使用起来就像使用本地的功能函数一样，对用户无感知。对远端功能函数的包装方法为：创建一个 binder_transaction_data 数据包，将对应的功能函数编码填入 code 成员中，将函数参数填入 data.buffer 成员中，并将目标 Binder 的引用填入数据包的 target.handle 成员中，target 本身是一个联合体，有 ptr 和 handle 两个成员，前者用于 Server 端，其中存放了指向 Binder 实体对应的内存空间的指针，后者用于 Client 端，存放 Binder 实体的引用号，告知驱动需要发送的目标 Binder 实体，数据包打包完成后，通过 Binder 驱动的方法通过 BC_TRANSACTION/BC_REPLY 指令完成和远程功能函数的调用交互。 Binder 传输结构 Binder 通过 flat_binder_object 结构在数据包中进行跨进程传输 成员 解释 unsigned long type 表明 Binder 的类型，有如下几种：BINDER_TYPE_BINDER：表示传递的是 Binder 实体，并且指向该实体的引用都是强类型。BINDER_TYPE_WEAK_BINDER：表示传递的是 Binder 实体，并且指向该实体的引用都是弱引用。BINDER_TYPE_HANDLE：表示传递的是 Binder 强引用类型。BINDER_TYPE_WEAK_HANDLE，表示传递的是 Binder 弱引用类型。BINDER_TYPE_FD 表示传递的是文件形式的 Binder。 unsigned long flags 此成员只对首次传递 Binder 有效，因为首次传递，Binder 驱动将在内核中创建 Binder 对应的实体节点，需要从此成员获取值。0-7 位，使用 FLAT_BINDER_FLAG_PRIORITY_MASK 取出值，表示处理本实体请求数据包的线程的最低优先级。当一个应用程序提供多个实体时，可以通过该参数调整分配给各个实体的处理能力。第 8 位：代码中用 FLAT_BINDER_FLAG_ACCEPTS_FDS 取出值，值为 1 表示该实体可以接收其它进程发过来的文件形式的 Binder，由于接收文件形式的Binder会在本进程中自动打开文件，有些Server可以用该标志禁止该功能，以防打开过多文件。 union {void *binder;signed long handle;} 当传递的是 Binder 实体时使用 binder 域，指向 Binder 实体在应用程序中的地址。当传递的是 Binder 引用时使用 handle 域，存放 Binder 在进程中的引用号。 void *cookie 该域只对 Binder 实体有效，存放与该 Binder 有关的附加信息。 Binder 传输结构的传输 不管是 Binder 实体还是其引用，都可能属于任意一个进程，所以 Binder 传输结构不能透明的在进程间传递，其中的信息必须经过驱动的翻译转换，才能让每个进程正确的使用 Binder 进程通信，例如在 Server 端将 Binder 实体传递给 Client 时，通过 flat_binder_object 结构进程传递，此时其中的 type 成员是 BINDER_TYPE_BINDER 类型，Binder 指向的是 Server 端的用户空间的内存地址，对 Client 端无用，驱动此时必须对 Binder 进行转换，将 type 改成 BINDER_TYPE_HANDLE ，为这个 Binder 在接收进程中创建位于内核中的引用，并将 Binder 实体的引用号填入 handle 中，对于 Binder 传输结构中发送的 Binder 引用类型也要做相同的转换，经过驱动翻译处理后的 Binder 引用才是可用的，此时才能填入 flat_binder_object 中的 handle 成员，向 Binder 实体发送请求。 Binder 验证 由于 Binder 在进程间的传输需要驱动的翻译，所以进程不能随意猜测一个 Binder 引用号就能向 Server 端请求服务，必须是由驱动在内核中创建对应的合法引用才行，需要使用由驱动注册相应的 Binder 节点亲自授予的引用号,必须经过驱动进行合法的验证，通过后才能进行通信，否则将被拒绝。 驱动对 flat_binder_object 结构的转换 Binder 类型（type 成员） 发送方的操作 接收方的操作 BINDER_TYPE_BINDERBINDER_TYPE_WEAK_BINDER 1. 只有实体所在的进程能发送该类型的Binder。2. 如果是第一次发送驱动将创建实体在内核中的节点，并保存binder，cookie 和 flag 成员。 1. 如果是第一次接收该 Binder 则创建实体在内核中的引用；将 handle 成员替换为新建的引用号；将 type 成员替换为 BINDER_TYPE_HANDLE 或 BINDER_TYPE_WEAK_HANDLE。 BINDER_TYPE_HANDLEBINDER_TYPE_WEAK_HANDLE 1. 获得 Binder 引用的进程都能发送该类型 Binder。2. 驱动根据 handle 域提供的引用号查找建立在内核的引用，如果找到说明引用号合法，否则拒绝该发送请求。 1. 如果收到的 Binder 实体位于接收进程中：将 ptr 成员替换为保存在节点中的 binder 值；cookie 替换为保存在节点中的 cookie 值；type 替换为 BINDER_TYPE_BINDER 或 BINDER_TYPE_WEAK_BINDER。2. 如果收到的 Binder 实体不在接收进程中：如果是第一次接收则创建实体在内核中的引用；将 handle 域替换为新建的引用号。 BINDER_TYPE_FD 验证 handle 成员中提供的打开文件号是否有效，无效则拒绝该发送请求。 在接收方创建新的打开文件号并将其与提供的打开文件描述结构绑定。 文件形式的 Binder 文件形式的 Binder 是一种特殊的 Binder，将文件看作一个 Binder 实体，进程打开的文件号看作 Binder 的引用，一个进程可将打开文件的文件号传递给另一个进程，从而另一个进程也打开了同一个文件。 一个进程打开一个文件，获得与之对应的文件号，从 Binder 角度，Linux 在内核创建的对应的文件描述结构 struct file 做为 Binder 实体，这时可通过 flat_binder_object 结构在进程间进行传递，type 成员此时为 BINDER_TYPE_FD，表示此 Binder 为文件 Binder，驱动将会对发送者的文件号做转换，在接收进程创建一个新的文件号与内核中的文件描述结构对应，然后替换 flat_binder_object 结构中的文件号传递给接收进程。 通过 Binder 发送的文件与多个进程打开同一个文件的意义不同，通过 Binder 打开的文件共享 Linux 虚拟文件系统中的 struct file，struct dentry，struct inode 结构，当一个进程使用 read()/write()/seek() 改变文件指针，另一个进程的文件指针也会同时改变。 Binder 驱动层Binder 驱动式实现 Binder 进程间通信的核心，它记录了所有 Binder 实体以及每个实体在各个进程中的引用；它能够通过 Binder 引用查询对应的 Binder 实体；它为 Binder 实体创建以及查找对应引用，它记录 Binder 实体所在进程；管理 Binder 强/弱引用，创建/销毁 Binder 实体等。 驱动中的第一个 Binder 是 ServiceManager，它用于管理实名 Binder 的 Binder 实体的注册，负责实名 Binder 注册过程中的进程间通信。驱动将所有进程中的 0 号 Binder 引用都指向 ServiceManager，那么索引进程将很方便的统一使用 0 号引用访问 ServiceManager，各个进程通过 flat_binder_object 结构穿过驱动进程进程间通信，Binder 驱动将会监听 binder_transaction_data 中的 data.offset 数组，所有 Binder 都在驱动的检查下传递，驱动通过 type 成员检查，如果为 BINDER_TYPE_BINDER 或 BINDER_TYPE_WEAK_BINDRE 则创建对应的 Binder 实体，如果为 BINDER_TYPE_HANDLE或 BINDER_TYPE_WEAK_HANDLE 则创建 Binder 引用，内核中的 Binder 实体和 Binder 引用将随着 Binder 通信过程逐渐增加，整个过程对用户透明。 Binder 实体在驱动中的表述 Binder 实体在驱动中以树的节点的形式存在，使用 struct binder_node 结构表示。 成员 解释 int debug_id; 用于调试 struct binder_work work; 当本节点的引用计数发生改变时，需要通知所属进程，通过该成员挂入所属进程的 to-do 队列里，唤醒所属进程执行 Binder 实体引用计数的修改。 union {struct rb_node rb_node;struct hlist_node_dead_node;} 每个进程都维护一棵红黑树，以 ptr 成员为索引存放该进程所有的 Binder 实体，它是 Binder 实体在用户空间的指针，这样 Binder 驱动就可以根据 ptr 指针找到位于内核的 Binder 节点。rb_node 用于将该节点链接到红黑树中，节点被销毁时需要将 rb_node 从树中移除，如果本节点引用还没有断开，就将节点使用 dead_node 记录到独立的链表中，直到通知所有进程切断与该节点的引用后，该节点才能被销毁。 struct binder_proc *proc; 本成员指向节点所属的进程，即提供该节点的进程。 struct hlist_strong_refs; 本成员是队列头，所有指向本节点的引用都链接在该队列里。这些引用可能隶属于不同的进程。通过该队列可以遍历指向该节点的所有引用。 int internal_strong_refs; 用以实现强指针的计数器：产生一个指向本节点的强引用该计数就会加 1。 int local_weak_refs; 驱动为传输中的 Binder 设置的弱引用计数。如果一个 Binder 通过数据包从一个进程发送到另一个进程，驱动会为该 Binder 增加引用计数，直到接收进程通过 BC_FREE_BUFFER 通知驱动释放该数据包的数据区为止。 int local_strong_refs; 驱动为传输中的 Binder 设置的强引用计数，同上。 void __user *ptr; 指向用户空间 Binder 实体的指针，来自于 flat_binder_object 的 Binder 成员。 void __user *cookie; 向用户空间的附加指针，来自于 flat_binder_object 的 cookie 成员。 unsigned has_strong_ref;unsigned pedning_strong_ref;unsigned has_weak_ref;unsigned pending_weak_ref; 用于控制驱动与 Binder 实体所在进程交互式修改引用计数 unsigned has_async_transaction; 该成员表明该节点在 to-do 队列中有异步交互尚未完成。驱动将所有发送往接收端的数据包暂存在接收进程或线程开辟的 to-do 队列里。对于异步交互，驱动做了适当流控：如果 to-do 队列里有异步交互尚待处理则该成员置 1，这将导致新到的异步交互存放在本结构成员 – asynch_todo 队列中，而不直接送到 to-do 队列里。目的是为同步交互让路，避免长时间阻塞发送端。 unsigned accept_fds; 表明节点是否同意接受文件方式的 Binder，来自 flat_binder_object 中 flags 成员的 FLAT_BINDER_FLAG_ACCEPTS_FDS 位。由于接收文件 Binder 会为进程自动打开一个文件，占用有限的文件描述符，节点可以设置该位拒绝这种行为。 int min_priority; 设置处理 Binder 请求的线程的最低优先级。发送线程将数据提交给接收线程处理时，驱动会将发送线程的优先级也赋予接收线程，使得数据即使跨了进程也能以同样优先级得到处理。不过如果发送线程优先级过低，接收线程将以预设的最小值运行。 struct list_head_async_todo; 该域的值来自于 flat_binder_object 中 flags 成员。异步交互等待队列；用于分流发往本节点的异步交互包。 Binder 引用在驱动中的表述 Binder 引用使用 binder_ref 结构表示。 成员 含义 int debug_id 用于调试 struct rb_node rb_node_desc; 每个进程有一棵红黑树，进程所有引用以引用号（即本结构的 desc 成员）为索引添入该树中。本成员用做链接到该树的一个节点。 struct rb_node rb_node_node; 每个进程又有一棵红黑树，进程所有引用以节点实体在驱动中的内存地址（即本结构的 node 成员）为所引添入该树中。本成员用做链接到该树的一个节点。 struct hlist_node node_entry; 将本引用做为节点链入所指向的 Binder 实体结构 binder_node 中的 refs 队列。 struct binder_proc *proc; 本引用所属的进程。 struct binder_node *node; 本引用所指向的 Binder 实体节点。 uint32_t desc; 本结构的引用号 int strong; 强引用计数 int weak; 弱引用计数 struct binder_ref_death *death; 应用程序向驱动发送 BC_REQUEST_DEATH_NOTIFICATION 或 BC_CLEAR_DEATH_NOTIFICATION 命令从而当 Binder 实体销毁时能够收到来自驱动的提醒。该成员不为空表明用户订阅了对应实体销毁的“讣告”。 同一个 Binder 实体可能存在多个 Binder 引用，而这些引用分布在不同的进程中，和实体一样，每个进程维护一颗红黑树存放 Binder 引用，Binder 引用可通过两个键索引： 对应 Binder 实体在内核中的地址。它是内核中 binder_node 结构的地址，它的地址在内核中具有唯一性，Binder 实体在不同用户进程地址可能重合，所以不能用来做索引，Binder 驱动利用红黑树在进程中快速查找 Binder 实体对应的引用（一个实体在进程中之间里一个引用）。 引用号。它是驱动为 Binder 引用分配的一个 32 位标识，在一个进程中具有唯一性，多个进程中引用号可能相同，引用号可做为 Binder 引用在用户进程的句柄，由驱动动态分配，0 号为特殊引用号，固定指向 ServiceManager。当向 Binder 发送数据包时，应用程序将 Binder 引用号填入 binder_transaction_data 结构中的 target.handle 成员中，表明该数据包的目的 Binder，驱动根据引用号在红黑树中找到对应的 binder_ref 结构，然后可通过其 node 成员获取对应的 Binder 实体所在的进程及相关信息，实现数据包的发送。 Binder 驱动实现Binder 内存映射和接收缓存区实现 传统的 IPC 通信方式 在传统的 IPC 通信中，通常发送方发送数据时，首先将数据放入缓存区，然后通过 system call 陷入内核，内核服务在内核分配内存，将发送方数据拷贝到内核缓冲区，同时接收方需要分配同样的缓存区，然后内核将数据从内核缓存区拷贝到接收方并唤醒接收线程，完成数据的发送，这种方式具有两个缺陷： 效率低下，需要两次数据复制过程，Linux 通过 copy_from_user()/copy_to_user() 实现跨内核复制数据，如果此过程中使用了高端内存，需要临时建立和取消页映射，会造成性能损失。 接收方需要提供数据缓存，而缓存大小未知，只能尽量开辟足够的空间，或者提前调用 API 获取大小，两种方式都会造成时间或空间的浪费。 Binder IPC 实现 Binder 采用与通常 IPC 方式不同的内存管理策略，Binder 驱动负责数据接收缓存的管理，它实现了 mmap() 系统调用，mmap() 通常用于具有物理介质的文件系统上，而 Binder 驱动做为字符设备支持 mmap() 并不是为了在物理介质和用户空间做映射，而是用来创建用于接收数据的缓存空间。 创建接收缓存区的方法如下： 12fd = open(\"/dev/binder\", O_RDWR); // 打开 Binder 驱动。mmap(NULL, MAP_SIZE, PROT_READ, MAP_PRIVATE, fd, 0); 以上操作为接受方创建了一片大小为 MAP_SIZE 的接收缓存区，mmap() 返回内存映射在用户空间的地址，这段空间由驱动管理，用户不能直接访问（类型为 PROT_READ 只读映射）。 Binder 接收线程实现Binder 通信的最终形态其实是不同进程中的线程之间的通信，Client 端中的线程 1 通过 Binder 引用向 Server 端发送请求，Server 将启动线程 2 来处理 Client 端的请求，此时 Client 端中的线程 1 将等待回应，Server 端的线程 2 处理完毕返回结果，然后 Client 端中的线程 1 被唤醒并接收数据，在此过程中，Server 端中的线程 2 仿佛 Client 端线程 1 的影子，这个影子穿越进程执行任务后再回到线程 1 中，就像同一个线程执行一个任务一样，驱动会帮助此行为，为线程 2 设置与线程 1 相同的线程优先级，为了使 Server 端线程 2 的执行时间接近 Client 端线程 1 的执行时间，减小环境之间的差异。不过除了线程优先级类似，两个线程从的身份，打开的文件，栈大小，私有数据等并无相同之处。 Binder 线程池管理 考虑多个 Client 端同时向一个 Server 端发起请求的情况，对于 Socket 处理方式而言，每当它监听到 Client 端的请求后，它就会对每一个 Client 启动一个线程来单独处理 Client 端发出的请求。对于 Binder 来说则不是这样。 Binder 会提前创建好若干线程，同时每个线程使用 BINDER_WRITE_READ 命令读取 Binder 请求，此时这些线程将处于阻塞状态，并存放于队列中，当有 Client 端请求时，Binder 驱动将从队列中唤醒一个线程用于处理 Client 请求，由于需要提前创建一定数量的线程，为避免浪费资源，Binder 协议提供了如下命令控制线程池： 12345BINDER_SET_MAX_THREADSBC_REGISTER_LOOPBC_ENTER_LOOPBC_EXIT_LOOPBC_SPAWN_LOOPER 应用程序 Client 端通过 BINDER_SET_MAX_THREADS 通知 Binder 驱动最多可以创建线程的数量，在每个线程创建，进入循环，退出循环时会调用 BC_REGISTER_LOOP BC_ENTER_LOOP BC_EXIT_LOOP 通知 Binder 驱动，驱动会收集线程相关信息，在每次驱动接收到 Client 端数据包并后返回给线程时，都会检查十是否还有闲置线程，如果没有了，则 Binder 驱动会在数据包中附加 BC_SPAWN_LOOPER 命令通知 Client 端，线程将不足以响应请求，希望能够再创建若干线程。这样就构成一个持续的处理和响应的过程。 线程启动优化 当 Client 端进程中的线程 1 向 Server 端进程发送请求时，Binder 驱动会首先查看线程 1 是否也在等待处理 Server 端进程的某个线程的响应（两个进程间互相发送消息时），如果 Server 端存在一个这样个线程 2，那么驱动将要求线程 2 来处理这个请求，因为可以确定的是线程 1 在等待线程 2 的响应，线程 2 也阻塞在读取返回包的过程，这样可以有效利用线程资源，避免线程 2 的空闲，同时避免了创建额外的线程。 数据包接收队列与（线程）等待队列实现数据接收端通常存在两个队列，数据包接收队列和线程等待队列，数据包接收队列负责接收数据包并缓存，之后会分发给线程处理，而线程等待队列则为等待处理请求的线程，在 Binder 驱动中，每个进程都具有一个全局接收队列，称为 to-do 队列，负责存放不是发往特定线程的数据包，相应的有一个全局等待队列，等待处理全局接受队列中的数据包，同时每个线程有自己私有的 to-do 队列，存放发送给自己的数据包，对应的私有等待队列用于接收私有 to-do 队列中的数据包，其中只有一个线程，就是这个线程自身。 数据包接收规则 Binder 驱动将根据以下规则确定数据包存放在全局或私有队列中： Client 端发送至 Server 端的数据包全部提交到进程全局的 to-do 队列，除了前面线程启动优化中的情况，Client 端的线程 1 发送的数据包将存放在满足条件的 Server 端的线程 2 的私有 to-do 队列中。 对于同步请求的返回数据包，都放入发起请求的线程的私有 to-do 队列中。 根据以上规则得到了线程进入全局等待队列的规则，即如果一个线程不接收返回数据包则应该在等待队列中等待接收新任务，否则就应该在其私有的队列中等待 Server 端的返回数据包。 驱动为 Binder 通信所加的这些规则，在应用程序的同步交互中体现出了线程一致性原则： Client 端发送数据包的线程必须和等待返回包的线程是同一个，否则将无法接收到返回包。 Server 端发送返回包的线程必须和接收到请求的线程是同一个，否则将数据包返回至请求的线程。（返回数据包的 Binder 由驱动记录在接收请求数据包的线程中，所以发送数据包的线程也需要是它） 同步异步交互 在 Binder 通信中，同步交互和异步交互的区别在于，同步交互时 Client 端需要等待 Server 端的响应数据包，而异步交互则由于没有返回数据需要接收，所以 Client 端发出请求后可立即结束。Binder 驱动对于两种交互的处理并不是把它们直接加入对应的 to-do 队列中，而是定义了异步为同步请求让步的策略： 对于 Binder 实体，如果存在一个异步交互未被线程处理完时，那么后来的发送给该 Binder 实体的异步请求将不再加入 to-do 队列中，而是阻塞在 Binder 驱动为该 Binder 实体开辟的异步交互队列中（Binder 节点的 async_node 成员中），在此期间同步交互依旧不受限制直接进入 to-do 队列接受处理，直到该异步交互处理完毕，下一个异步交互方可以脱离异步交互队列进入 to-do 队列中。这样做是因为同步交互的请求端需要等待返回包，必须迅速处理完毕以免影响请求端的响应速度，而异步交互属于‘发射后不管“，即使延时一些不会阻塞其它线程，所以使用专用队列将过多的异步交互暂存起来，避免突发大量异步交互挤占 Server 端的处理能力或耗尽线程池里的线程，进而阻塞同步交互。 结语以上”Binder 设计“部分是阅读博客所做的记录，由于可能出现理解偏差，所以里面可能会存在错误的论述，需要我在后期学习过程中去确认修正。","link":"/2020/07/14/android-binder-%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/"},{"title":"Android NDK 指南","text":"前言编写此文档的用意： 作为搭建基础 NDK 工程的教程； 作为入门 NDK 工程的参考手册。 NDK 工程构建可采用三种方式进行 NDK 工程的构建： 基于 Make 的 ndk-build，这是传统的 ndk-build 构建方式，使用 Makefile 方式进行构建，简洁高效； CMake 是新型的构建方式，CMake 具有跨平台的特性，通过 CMake 生成 Makefile 后再进行构建，CMake 的配置文件可读性更高； 其他编译系统，通过引入其他编译系统可对编译过程进行定制，例如引入 obfuscator-llvm 对源码进行混淆和压缩，增强源代码安全性。 下面是每种构建方式的基础示例，使用 Android Studio 4.0 和 NDK 21 进行如下构建。 Android.mk基于 Android.mk 的产物为 libfoo.so 的 NDK 基本工程搭建。 在 Android 工程的 src/main 下建立 jni 目录（Android.mk 工程的默认文件目录为 jni，也可指定其他目录进行构建，使用命令 ndk-build -C 目录），工程结构如下： 包含两个 .mk 文件用来描述 NDK 工程，和两个基本的 C++ 语言源文件，结构如下： 123456789src/main | +-- java +-- jni | +-- Android.mk +-- Application.mk +-- libfoo.h +-- libfoo.cpp 在 Android Studio 的当前 Module 配置中指明 Android.mk 文件路径: 12345678910// app-build.gradleandroid { ... externalNativeBuild { ndkBuild { path 'src/main/jni/Android.mk' } }} 编写 Android.mk 文件用于向 NDK 构建系统描述工程的 C/C++ 源文件以及共享库的属性。 123456789101112# Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)# 指定共享库名字，产出物为 libfoo.soLOCAL_MODULE := foo# 指定源代码文件，多个源代码文件使用空格分隔，换行在行尾使用 \\LOCAL_SRC_FILES := main.cppinclude $(BUILD_SHARED_LIBRARY) 添加 Application.mk 用于描述 NDK 工程概要设置。 12345# Application.mk# 指定生成特定 ABI 的代码APP_ABI := armeabi-v7a arm64-v8aAPP_OPTIM := debug 在 java 目录创建 Java 类，用于声明 JNI 方法，提供给其他类调用。 12345678910// class io.l0neman.mkexample.NativeHandlerpublic class NativeHandler { static { // 加载 libfoo.so 库 System.loadLibrary(\"foo\"); } public static native String getHello();} 源代码： 12345678910111213141516// libfoo.hextern \"C\" {#ifndef NDKTPROJECT_LIBFOO_H#define NDKTPROJECT_LIBFOO_H#include &lt;jni.h&gt;// 注册指定 Java 层的 JNI 方法JNIEXPORT jstring JNICALLJava_io_l0neman_mkexample_NativeHandler_getHello(JNIEnv *env, jclass clazz);};#endif //NDKTPROJECT_LIBFOO_H 123456// libfoo.cpp#include \"libfoo.h\"jstring Java_io_l0neman_mkexample_NativeHandler_getHello(JNIEnv *env, jclass clazz) { return env-&gt;NewStringUTF(\"Hello-jni\");} 这样的话就完成了一个基本的 NDK 工程搭建，编译后调用代码即可得到 java 字符串 &quot;Hello-jni&quot;。 123// MainActivity.javaString hello = NativeHandler.getHello(); 提示 Android.mk 和 Application.mk 中可使用的系统变量请参考下文。 Android.mk 只是 Makefile 的片段，对于 Makefile 本身的熟悉有助于深入理解和编写 Android.mk，可参考 Makfile 指南 CMake使用 CMake 和 Android.mk 在 Android Studio 中的构建步骤类似，如下： 基于 CMake 的产出物为 libfoo.so 的 NDK 基本工程搭建。 在 Android 工程的 src/main 下建立 cpp 目录，工程结构如下： 包含一个 CMakeLists.txt 文件来描述 NDK 工程，和两个基本的 C++ 语言文件。 12345678src/main | +-- java jni | +-- CMakeLists.txt +-- libfoo.h +-- libfoo.cpp 在 Android Studio 的当前 Module 配置中指明 CMakeLists.txt 文件路径: 12345678910// app/build.gradleandroid { ... externalNativeBuild { cmake { path 'src/main/cpp/CMakeLists.txt' } }} 编写 CMakeLists.txt 文件用于向 NDK 构建系统描述工程的 C/C++ 源文件以及共享库的属性。 123456789101112# CMakeLists.txtcmake_minimum_required(VERSION 3.4.3)add_library( # 共享库名字，生产物为 libfoo.so foo # 编译为共享库 .so SHARED # 源代码文件，多个文件使用空格分隔或换行 main.cpp) 此时将 Android.mk 工程中的 Java 源文件 NativeHandler.java 复制过来，将 libfoo.cpp 和 libfoo.h 内容填入中即可直接编译测试。 独立工具链有时编译 NDK 工程有一些特殊需求，例如对代码进行混淆，加入第三方编译器 obfuscator-llvm 对 NDK 工程进行编译。这时就需要搭建第三方工具链的编译环境，将它加入 NDK 的一般构建过程中。 下面是一个引入 obfuscator-llvm 编译器编译代码的示例。 obfuscator-llvm 构建环境：android-ndk-r14b，目前已知此版本可支持 obfuscator-llvm 的编译配置 ndk r14b 下载地址：https://developer.android.google.cn/ndk/downloads/older_releases 首先下载编译器，指定最新版本的 obfuscator-llvm 分支，将仓库克隆至本地 1git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git 编译出编译器的可执行文件 过程如下，以下命令 Windows DOS 和 Linux Shell 中可通用： 进入编译器仓库目录中 cd obfuscator； 创建临时文件目录 mkdir build； 进入临时文件目录 cd build； 使用 CMake 生成 Makefile 或者 Vs 解决方案： 如果没有按照 CMake，可去 CMake 官网下载安装。 1cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ../ CMake 将会自动检测电脑上的编译器环境，如果是 Linux，生成 Makefile，如果 Windows 上安装了 Visual Studio，将生成解决方案文件。 编译编译器源代码： Linux 上执行： 1make -j4 Windows 平台建议使用 Visual Studio 进行编译，直接打开 build 中的 LLVM.sln，然后生成解决方案（Build Solution）。 编译过程需要持续 30 分钟或更长时间，取决于电脑配置 CPU 性能。 编译过程中有可能出现错误，需要自己解决出现的不同情况，编译完成后将生成所需的 bin 和 lib 目录（Release 中）。 配置 NDK 环境 设原始 NDK 工具链根目录为 android-ndk-r14b。 进入 android-ndk-r14b/toolchains 目录中，复制已存在的 llvm 目录到 ollvm-4.0，Linux 使用 cp llvm ollvm-4.0，Windows 复制文件出现 llvm-副本 后重命名为 ollvm-4.0。 Windows 平台将上面编译出来的 bin 和 lib 放入 ollvm-4.0/prebuilt/windows-x86_64 中，Linux 平台放入 ollvm-4.0/prebuilt/linux-x86_64 中，macOS 为 ollvm-4.0/prebuilt/darwin-x86_64。 进入 android-ndk-r14b/build/core/toolchains 中，在当前目录复制出如下目录： 1234arm-linux-androideabi-clang -&gt; arm-linux-androideabi-clang-ollvm4.0aarch64-linux-android-clang -&gt; aarch64-linux-android-clang-ollvm4.0x86-clang -&gt; x86-clang-ollvm4.0x86_64-clang -&gt; x86_64-clang-ollvm4.0 修改复制后的两个目录中的 setup.mk 文件： 1234android-ndk-r14b/build/core/toolchains/arm-linux-androideabi-clang-ollvm4.0/setup.mkandroid-ndk-r14b/build/core/toolchains/aarch64-linux-android-clang-ollvm4.0/setup.mkandroid-ndk-r14b/build/core/toolchains/arm-linux-androideabi-clang-ollvm4.0/setup.mkandroid-ndk-r14b/build/core/toolchains/x86_64-clang-ollvm4.0/setup.mk 将每个 setup.mk 中的如下内容： 1LLVM_TOOLCHAIN_PREBUILT_ROOT := $(call get-toolchain-root,llvm) 替换为： 12OLLVM_NAME := ollvm-4.0LLVM_TOOLCHAIN_PREBUILT_ROOT := $(call get-toolchain-root,$(OLLVM_NAME)) 此时使用 ndk-build 将可以识别编译器。复制 4 个目录的原因是为了支持编译出每种 ABI，（armeabi、armeabi-v7a、arm64-v8a，x86、x86_64）。 编译代码测试 进入 NDK 工程中，修改 Application.mk 和 Android.mk 如下： 12345# Application.mkAPP_ABI := armeabi-v7a arm64-v8a# 主要是此句指定编译器NDK_TOOLCHAIN_VERSION := clang-ollvm4.0 123456789101112131415# Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := libfoo.cpp# 添加 obfuscator-llvm 支持的各种参数，伪控制流、控制流展开、指令替换LOCAL_CFLAGS += -mllvm -bcf -mllvm -bcf_loop=3 \\ -mllvm -fla -mllvm -split \\ -mllvm -sub -mllvm -sub_loop=3include $(BUILD_SHARED_LIBRARY) 在包含源代码的 jni 目录下执行配置好的 NDK r14b 中的 ndk-build 编译即可。 验证结果 编译后，在 libs 中将出现 ABI 目录，使用 IDA Pro 打开 libfoo.so，左侧 Functions windos 中找一个简单函数（例如 JNI_OnLoad）打开，发现程序逻辑流程已被混淆的面目全非。 左下角的 Graph overview 可以直观的看到整个函数的逻辑流程，非常复杂，无法直接了解到原始逻辑。 构建技巧独立构建通常 NDK 构建过程需要依赖于 Android Studio 进行清理，构建等工作。 有时需要脱离 Android Studio，例如在无界面的服务器上独立构建，那么可以直接使用 ndk-build 命令行进行构建。 首先确认 NDK 的环境变量（将 NDK 工具链的根路径加入系统 PATH 变量）。然后直接在 jni 目录下打开终端（Windows 为 cmd），输入 ndk-build clean，将自动清理产生的 obj 文件和 libs 文件。 然后执行 ndk-build 即可构建出所需要的 so 文件，例如 libs/arm64-v8a/libfoo.so。 如果不想在 jni 目录中构建，可使用 -C 选项指定路径构建 ndk-build -C jni_new。 其他参数可参考官方文档：https://developer.android.google.cn/ndk/guides/ndk-build 提示 对于普通 Android Studio 中的工程，也可以使用这种方法构建。 首先把 gradle 中 Android.mk 路径配置去除。在默认的依赖配置里面可以看到，libs 目录已被加入依赖，就是说如果 libs 目录中有 so 文件，那么会被自动加入 apk 中。 12345// app/build.gradledependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) ...} 那么经过 ndk-build 构建后，可以直接运行 apk 工程，新的 libfoo.so 将被加入 apk 的 libs 目录中。 此时 Android Studio 构建和清理均不会影响 libs 中的 .so 文件，Java 代码和 NDK 开发代码可分别独立构建。 快速部署对于一个主要由 native 代码构成的应用来说，修改 native 代码的动作较为频繁，如果每次都 clean 然后重新 build，再依赖于 Android studio 的运行安装会可能会比较麻烦。有时也需要依赖于其他 IDE 来构建 NDK 工程（例如使用 Visual Studio），那么可以采用如下方法： 首次构建 NDK 工程后安装运行到手机上，然后后面每次构建出 so，使用 adb 命令直接将 so 文件 push 到应用的沙盒目录下，重新启动应用进程即可使用新版的 so 文件。 1adb push libfoo.so /data/data/io.l0neman.mkexample/lib/ 注意 so 文件的架构应与当前应用采用的 ABI 对应。 不过这样做的前提是设备拥有 root 权限，也可直接使用官方的 Android 模拟器，选择下载带有 GoogleApis 的模拟器 ROM，输入如下命令即可获取 root 权限： 12adb rootadb remount 之后 adb 将以 root 用户的身份运行。 Android.mk 变量参考变量命名规范NDK 构建系统保留了如下变量名称，在定义自己的变量时尽量避免这些规则： 以 LOCAL_ 开头的名称，例如 LOCAL_MODULE； 以 PRIVATE_、NDK_ 或 APP 开头的名称，构建系统内部使用了这些变量名； 小写名称，例如 my-dir，构建系统内部使用了这些变量名。 最好以 MY_ 附加在自己的变量开头。 NDK 定义的 include 变量 CLEAR_VARS 此变量指向一个用于清理变量的脚本，当包含它时，会清理几乎所有的 LOCAL_XXX 变量，不包含 LOCAL_PATH 变量，一般在描述新模块之前包含。 1include $(CLEAR_VARS) BUILD_EXECUTABLE 指明构建的产出物是一个可执行文件（无文件后缀名），需要在源代码中包含一个 main 函数。通常构建可执行文件用来测试或用于其他调试工具。 12345// foo.cppint main(int argv, char **args) { printf(\"Hello World!\\n\"); return 0;} 1include $(BUILD_EXECUTABLE) BUILD_SHARED_LIBRARY 指明构建的产出物是一个共享库（文件后缀为 .so），它会随着应用代码打包至 apk 中。 1include $(BUILD_SHARED_LIBRARY) BUILD_STATIC_LIBRARY 指明构建的产出物是一个静态库（文件后缀为 .a），它不会被打包至 apk 中，只是为了被其他 native 模块引用。 PREBUILT_SHARED_LIBRARY 用于描述预编译共享库的构建，此时 LOCAL_SRC_FILES 变量指向预编译库的路径。 12LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.soinclude $(PREBUILT_SHARED_LIBRARY) PREBUILT_STATIC_LIBRARY 用于描述预编译静态库的构建，此时 LOCAL_SRC_FILES 变量指向预编译库的路径。 12LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.ainclude $(PREBUILT_STATIC_LIBRARY) 目标信息变量构建系统会根据 APP_ABI 变量（在 Application.mk 中定义）指定的每个 ABI 分别解析一次 Android.mk，如下变量将在构建系统每次解析时被重新定义值。 TARGET_ARCH 对应 CPU 系列，为 arm、arm64、x86、x86_64。 TARGET_PLATFORM 指向 Android API 级别号，例如 Android 5.1 对应 22。可以这样使用： 123ifeq ($(TARGET_PLATFORM),android-22) # ... do something ...endif TARGET_ARCH_ABI 对应每种 CPU 对应架构的 ABI。 CPU and architecture Setting ARMv7 armeabi-v7a ARMv8 AArch64 arm64-v8a i6686 x86 x86-64 x86_64 检查 ABI： 123ifeq ($(TARGET_ARCH_ABI),arm64-v8a) # ... do something ...endif TARGET_ABI 目标 Android API 级别与 ABI 的串联值。检查在 Android API 级别 22 上运行的 64 位 ARM 设备： 123ifeq ($(TARGET_ABI),android-22-arm64-v8a) # ... do something ...endif 模块描述变量下面的变量用于向构建系统描述如可构建一个模块，每个模块都应遵守如下流程： 使用 CLEAR_VARS 变量清理与上一个模块相关的变量； 为用于描述模块的变量赋值； 包含 BUILD_XXX 变量以适当的构建脚本用于该模块的构建。 LOCAL_PATH 用于指定当前文件的路径，必须在 Android.mk 文件开头定义此变量。 CLEAR_VARS 指向的脚本不会清除此变量。 12# my-dir 是一个宏函数，返回当前 Android.mk 文件路径LOCAL_PATH := $(call my-dir) LOCAL_MODULE 用于向构建系统描述模块名称，对于 .so 和 .a 文件，系统会自动给名称添加 lib 前缀和文件扩展名。 12# 产出 libfoo.so 或 libfoo.aLOCAL_MODULE := foo LOCAL_MODULE_FILENAME 向构建系统描述模块的自定义名称，覆盖 LOCAL_MODULE 的名称。 123LOCAL_MODULE := foo# 产出 libnewfoo.so，但无法改变扩展名LOCAL_MODULE_FILENAME := libnewfoo LOCAL_SRC_FILES 向构建系统描述生成模块时所用的源文件列表，务必使用 Unix 样式的正斜杠 (/) 来描述路径，且避免使用绝对路径。 LOCAL_CPP_EXTENSION 为 C++ 源文件指定除 .cpp 外的扩展名。 1LOCAL_CPP_EXTENSION := .cxx 或指定多个： 1LOCAL_CPP_EXTENSION := .cxx .cpp .cc LOCAL_CPP_FEATURES 向构建系统指明代码所依赖于的特定 C++ 功能。避免使用 LOCAL_CPPFLAGS 声明，它会导致编译器将所有指定的标记用于所有模块。 12# 使用运行时信息LOCAL_CPP_FEATURES := rtti 12# 使用 C++ 异常LOCAL_CPP_FEATURES := exceptions 指定多个： 1LOCAL_CPP_FEATURES := rtti features LOCAL_C_INCLUDES 指定路径列表，以便在编译时添加到 include 搜索路径。搜索路径同时影响 ndk-gdb 调试路径。 1LOCAL_C_INCLUDES := sources/foo 通过 LOCAL_CFLAGS 或 LOCAL_CPPFLAGS 设置任何对应的包含标记前定义此变量。 LOCAL_CFLAGS 构建 C 和 C++ 源文件时构建系统要传递的编译器标记，LOCAL_CPPFLAGS 可仅为 C++ 源文件指定标记。 相关：GCC 编译器选项参考 https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html#C_002b_002b-Dialect-Options 12# 指定额外 include 路径，推荐用 LOCAL_C_INCLUDESLOCAL_CFLAGS += -I&lt;path&gt;, LOCAL_CPPFLAGS 只构建 C++ 源文件传递的一组编译器标记，放在 LOCAL_CFLAGS 变量定义的后面。 LOCAL_STATIC_LIBRARIES 存储当前模块依赖的静态库模块列表 如果当前模块是共享库或可执行文件，此变量强制这些库链接到生成的二进制文件； 如果当前模块是静态库，此变量指出依赖于当前模块的其他模块也会依赖于其列出的库。 LOCAL_SHARED_LIBRARIES 此变量列出此模块在运行时依赖的共享库模块。用于将相应的连链接信息嵌入到生成的文件中。 LOCAL_WHOLE_STATIC_LIBRARIES LOCAL_STATIC_LIBRARIES 的变体形式，表示链接器应将相关的库模块视为完整归档（链接所有符号，而不只是用到的），可参考 ld 链接器的 --whole-archive 选项。 LOCAL_LDLIBS 列出在构建共享库或可执行文件时使用的额外链接器标记，使用 -l 前缀来指明连接到特定系统库（一般用于链接 NDK 提供的公开系统库，例如 liblog）。 12# 链接 /system/lib/libz.so 模块LOCAL_LDLIBS := -lz LOCAL_LDFLAGS 列出构建系统在构建共享库或可执行文件时使用的其他链接器标记。 12# 在 ARM/X86 上使用 ld.bfd 链接器LOCAL_LDFLAGS += -fuse-ld=bfd 定义静态库时，构建系统会忽略此变量，ndk-build 会打印警告。 LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下，构建系统在尝试构建共享库时遇到未定义的引用，将会抛出“未定义的符号”错误，指定此变量为 true，将停用此检查（可能会导致运行时加载）。 定义静态库时，构建系统会忽略此变量，ndk-build 会打印警告。 LOCAL_ARM_MODE 默认情况下，构建系统会以 thumb 模式生成 ARM 目标二进制文件，其中每条指令都是 16 位宽，并与 thumb/ 目录中的 STL 库链接。将此变量定义为 arm 会强制构建系统以 32 位 arm 模式生成模块的对象文件。 1LOCAL_ARM_MODE := arm 或者对源文件名附加 .arm 后缀，指示构建系统仅以 arm 模式构建特定的源文件。 12# 以 ARM 模式编译 bar.c，但根据 LOCAL_ARM_MODE 的值构建 foo.cLOCAL_SRC_FILES := foo.c bar.c.arm 也可以在 Application.mk 文件中将 APP_OPTIM 设置为 debug，强制构建系统生成 ARM 二进制文件。指定 debug 会强制构建 ARM，因为工具链调试程序无法正确处理 Thumb 代码。 LOCAL_ARM_NEON 此变量仅在以 armeabi-v7a ABI 为目标时才有意义。它允许在 C 和 C++ 源文件中使用 ARM Advanced SIMD (NEON) 编译器固有特性，以及在 Assembly 文件中使用 NEON 指令 并非所有基于 ARMv7 的 CPU 都支持 NEON 扩展指令集。因此，必须执行运行时检测，以便在运行时安全地使用此代码。 12# 以 Thumb 和 NEON 支持编译 foo.c，以 Thumb 支持编译 bar.c，并以 ARM 和 NEON 支持编译 zoo.cLOCAL_SRC_FILES = foo.c.neon bar.c zoo.c.arm.neon 同时使用这两个后缀时，.arm 必须在 .neon 前面。 LOCAL_DISABLE_FORMAT_STRING_CHECKS 默认情况下，构建系统会在编译代码时保护格式字符串。这样的话，如果 printf 样式的函数中使用了非常量格式的字符串，就会强制引发编译器错误。 可通过将此变量的值设置为 true 将其停用，不建议停用。 LOCAL_EXPORT_CFLAGS 记录一组 C/C++ 编译器标记，这些标记将被添加到使用通过 LOCAL_STATIC_LIBRARIES 或 LOCAL_SHARED_LIBRARIES 变量所描述模块的其他模块的 LOCAL_CFLAGS 定义中。 如下，foo 模块被 bar 模块依赖，那么标记 -DFOO=1 将在 bar 模块构建时和 -DBAR=2 一起传递至编译器。 123456789101112include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := foo/foo.cLOCAL_EXPORT_CFLAGS := -DFOO=1include $(BUILD_STATIC_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := barLOCAL_SRC_FILES := bar.cLOCAL_CFLAGS := -DBAR=2LOCAL_STATIC_LIBRARIES := fooinclude $(BUILD_SHARED_LIBRARY) 构建系统单独编译 foo 模块时，不会将 -DFoo 标记传递至编译器。 如果有其他模块例如 zoo 依赖于 bar，那么标记将被传递。 LOCAL_EXPORT_CPPFLAGS 与 LOCAL_EXPORT_CFLAGS 相同，但仅适用于 C++ 标记。 LOCAL_EXPORT_C_INCLUDES 与 LOCAL_EXPORT_CFLAGS 相同，但适用于 C include 路径。 LOCAL_EXPORT_LDFLAGS 与 LOCAL_EXPORT_CFLAGS 相同，但适用于链接器标记。 LOCAL_EXPORT_LDLIBS 此变量与 LOCAL_EXPORT_CFLAGS 相同，用于指示构建系统将特定系统库的名称传递到编译器。请在您指定的每个库名称前附加 -l 构建系统会将导入的链接器标记附加到模块的 LOCAL_LDLIBS 变量值上。其原因在于 Unix 链接器的工作方式 对于静态库会很有用： 1234567891011include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := foo/foo.cLOCAL_EXPORT_LDLIBS := -lloginclude $(BUILD_STATIC_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := barLOCAL_SRC_FILES := bar.cLOCAL_STATIC_LIBRARIES := fooinclude $(BUILD_SHARED_LIBRARY) 那么构建系统在构建 libbar.so 时，将在链接器命令的末尾指定 -llog。告知链接器，由于 libbar.so 依赖于 foo，所以它也依赖于系统日志记录库。 LOCAL_SHORT_COMMANDS 当模块有很多源文件和/或依赖的静态或共享库时，请将此变量设置为 true，这样会强制构建系统将 @ 语法用于包含中间对象文件或链接库的归档。 此功能在 Windows 上可能很有用，在 Windows 上，命令行最多只接受 8191 个字符，这对于复杂的项目来说可能太少。它还会影响个别源文件的编译，而且将几乎所有编译器标记都放在列表文件内。 此功能会减慢构建速度。 LOCAL_THIN_ARCHIVE 构建静态库时，请设置为 true。这样会生成一个瘦归档，即一个库文件，其中不含对象文件，而只包含它通常包含的实际对象的文件路径。 在非静态库模块或预构建的静态库模块中，将会忽略此变量。 LOCAL_FILTER_ASM 请将此变量定义为一个 shell 命令，供构建系统用于过滤根据您为 LOCAL_SRC_FILES 指定的文件提取或生成的汇编文件。定义此变量会导致发生以下情况： 构建系统从任何 C 或 C++ 源文件生成临时汇编文件，而不是将它们编译到对象文件中； 构建系统在任何临时汇编文件以及 LOCAL_SRC_FILES 中所列任何汇编文件的 LOCAL_FILTER_ASM 中执行 shell 命令，因此会生成另一个临时汇编文件； 构建系统将这些过滤的汇编文件编译到对象文件中。 12345LOCAL_SRC_FILES := foo.c bar.SLOCAL_FILTER_ASM :=foo.c --1--&gt; $OBJS_DIR/foo.S.original --2--&gt; $OBJS_DIR/foo.S --3--&gt; $OBJS_DIR/foo.obar.S “1”对应于编译器，“2”对应于过滤器，“3”对应于汇编程序。过滤器必须是一个独立的 shell 命令，它接受输入文件名作为第一个参数，接受输出文件名作为第二个参数。例如： 12myasmfilter $OBJS_DIR/foo.S.original $OBJS_DIR/foo.Smyasmfilter bar.S $OBJS_DIR/bar.S NDK 提供的函数宏NDK 提供了一些 GNU Make 的函数宏，使用 $(call &lt;function&gt;) 调用求值，返回相应文本信息。 my-dir 返回最后包括的 makefile 的路径，通常是当前 Android.mk 的目录。 由于 GNU Make 的工作方式，这个宏实际返回的是构建系统解析构建脚本时包含的最后一个 makefile 的路径。因此，包括其他文件后就不应调用 my-dir，可以提前把返回值保存起来，避免受影响。 1234567891011MY_LOCAL_PATH := $(call my-dir)LOCAL_PATH := $(MY_LOCAL_PATH)# ... declare one moduleinclude $(LOCAL_PATH)/foo/`Android.mk`LOCAL_PATH := $(MY_LOCAL_PATH)# ... declare another module all-subdir-makefiles 返回位于当前 my-dir 路径所有子目录中的 Android.mk 文件列表 利用此函数，您可以为构建系统提供深度嵌套的源目录层次结构。默认情况下，NDK 只在 Android.mk 文件所在的目录中查找文件。 this-makefile 返回当前 makefile（构建系统从中调用函数）的路径。 parent-makefile 返回包含树中父 makefile 的路径（包含当前 makefile 的 makefile 的路径）。 grand-parent-makefile 返回包含树中祖父 makefile 的路径（包含当前父 makefile 的 makefile 的路径）。 import-module 此函数用于按模块名称来查找和包含模块的 Android.mk 文件： 1$(call import-module,&lt;name&gt;) 构建系统在 NDK_MODULE_PATH 环境变量所引用的目录列表中查找具有 &lt;name&gt; 标记的模块，并且自动包括其 Android.mk 文件 Application.mk 变量参考Application.mk 指定 NDK 工程的项目级设置。 许多参数具有模块等效项，例如，APP_CFLAGS 对应于 LOCAL_CFLAGS，基于特定模块的选项优于项目级的选项。 对于标记来说，如果两者都使用，那么特定于模块的标记将后出现在命令行中，因此它们会替换项目级设置。 APP_ABI 默认情况下，NDK 构建系统会为所有有效的 ABI 生成代码。可以使用 APP_ABI 设置为特定 ABI 生成代码。 Instruction set Value 32-bit ARMv7 APP_ABI := armeabi-v7a 64-bit ARMv8 (AArch64) APP_ABI := arm64-v8a x86 APP_ABI := X86 x86-64 APP_ABI := x86_64 All supported ABIs (default) APP_ABI：= all 可指定多个值： 1APP_ABI := armeabi-v7a arm64-v8a x86 Gradle 中的 externalNativeBuild 设置会忽略 APP_ABI。需要在 splits 块内部使用 abiFilters 块或 abi 块。 APP_ASFLAGS 要传递给项目中每个汇编源文件（.s 和 .S 文件）的编译器的标记。 ASFLAGS 与 ASMFLAGS 不同。后者专用于 YASM 源文件。 APP_BUILD_SCRIPT 如需从其他位置加载 Android.mk 文件，将 APP_BUILD_SCRIPT 设置为 Android.mk 文件的绝对路径。 Gradle 中的 externalNativeBuild 块将根据 externalNativeBuild.ndkBuild.path 变量自动设置此路径。 APP_CFLAGS 为项目中的所有 C/C++ 编译传递的标记。 APP_CLANG_TIDY 为项目中的所有模块启用 clang-tidy，将此标记设置为 True。默认为停用状态。 APP_CLANG_TIDY_FLAGS 要为项目中的所有 clang-tidy 执行传递的标记。 APP_CONLYFLAGS 要为项目中的所有 C 编译传递的标记。这些标记不会用于 C++ 代码。 APP_CPPFLAGS 要为项目中的所有 C++ 编译传递的标记。这些标记不会用于 C 代码。 APP_CXXFLAGS APP_CPPFLAGS 应优先于 APP_CXXFLAGS。 与 APP_CPPFLAGS 相同，但在编译命令中将出现在 APP_CPPFLAGS 之后。例如： 12APP_CPPFLAGS := -DFOOAPP_CXXFLAGS := -DBAR 以上配置将导致编译命令类似于 clang++ -DFOO -DBAR，而不是 clang++ -DBAR -DFOO。 APP_DEBUG 构建可调试的应用，将此标记设置为 True。 APP_LDFLAGS 关联可执行文件和共享库时要传递的标记。 这些标记对静态库没有影响。不会关联静态库。 APP_MANIFEST AndroidManifest.xml 文件的绝对路径。 默认情况下将使用 $(APP_PROJECT_PATH)/AndroidManifest.xml)（如果存在）。 使用 externalNativeBuild 时，Gradle 不会设置此值。 APP_MODULES 要构建的模块的显式列表。此列表的元素是模块在 Android.mk 文件的 LOCAL_MODULE 中显示的名称。 默认情况下，ndk-build 将构建所有共享库、可执行文件及其依赖项。仅当项目使用静态库、项目仅包含静态库或者在 APP_MODULES 中指定了静态库时，才会构建静态库。 不会构建导入的模块（在使用 $(call import-module) 导入的构建脚本中定义的模块），除非要在 APP_MODULES 中构建或列出的模块依赖导入的模块。 APP_OPTIM 定义为 release 或 debug。默认情况下，将构建 relase 模式的二进制文件。 release 模式会启用优化，并可能生成无法与调试程序一起使用的二进制文件。debug 模式会停用优化，以便可以使用调试程序。 应用清单的 &lt;application&gt; 标记中声明 android:debuggable 将导致此变量默认为 debug，而不是 release。将 APP_OPTIM 设置为 release 可替换此默认值。 使用 externalNativeBuild 进行构建时，Android Studio 将根据您的构建风格适当地设置此标记。 APP_PLATFORM 声明构建此应用所面向的 Android API 级别，并对应于应用的 minSdkVersion。 如果未指定，ndk-build 将以 NDK 支持的最低 API 级别为目标。最新 NDK 支持的最低 API 级别总是足够低，支持几乎所有有效设备。 将 APP_PLATFORM 设置为高于应用的 minSdkVersion 可能会生成一个无法在旧设备上运行的应用。在大多数情况下，库将无法加载，因为它们引用了在旧设备上不可用的符号。 使用 Gradle 和 externalNativeBuild 时，不应直接设置此参数。而应在模块级别 build.gradle 文件的 defaultConfig 或 productFlavors 块中设置 minSdkVersion 属性。这样就能确保只有在运行足够高 Android 版本的设备上安装的应用才能使用您的库。 NDK 不包含 Android 每个 API 级别的库，省略了不包含新的原生 API 的版本以节省 NDK 中的空间。ndk-build 按以下优先级降序使用 API： 匹配 APP_PLATFORM 的平台版本。 低于 APP_PLATFORM 的下一个可用 API 级别。例如，APP_PLATFORM 为 android-20 时，将使用 android-19，因为 android-20 中没有新的原生 API; NDK 支持的最低 API 级别。 APP_PROJECT_PATH 项目根目录的绝对路径。 APP_SHORT_COMMANDS LOCAL_SHORT_COMMANDS 的项目级等效项。 APP_STL 用于此应用的 C++ 标准库。 默认情况下使用 system STL。其他选项包括 c++_shared、c++_static 和 none。 APP_STRIP_MODE 要为此应用中的模块传递给 strip 的参数。默认为 --strip-unneeded。若要避免剥离模块中的所有二进制文件，请将其设置为 none。 APP_THIN_ARCHIVE 为项目中的所有静态库使用瘦归档，将此变量设置为 True。 APP_WRAP_SH 要包含在此应用中的 wrap.sh 文件的路径。 每个 ABI 都存在此变量的变体，ABI 通用变体也是如此： 12345APP_WRAP_SHAPP_WRAP_SH_armeabi-v7aAPP_WRAP_SH_arm64-v8aAPP_WRAP_SH_x86APP_WRAP_SH_x86_64 APP_WRAP_SH_&lt;abi&gt; 可能无法与 APP_WRAP_SH 结合使用。如果有任何 ABI 使用特定于 ABI 的 wrap.sh，所有 ABI 都必须使用该 wrap.sh。 NDK APINDK 开发几乎必须要使用到 NDK 提供的原生 API，最常用的就是 liblog，用来在 logcat 中打印日志，下面分别使用 Android.mk 和 CMake 引入日志库。 引入其他库方法一致，可用 NDK 库列表可参考官方文档：https://developer.android.google.cn/ndk/guides/stable_apis Android.mk非常简单，只需要在 Android.mk 文件中使用 LOCAL_LDLIBS 变量使用 -l 前缀描述需要连接的库即可： 123456789101112131415# Android.mkLOCAL_PATH := $(call my-dir)$(warning $(TARGET_PLATFORM))include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := libfoo.cpp# 添加日志库，需要添加其他库可直接使用空格分隔LOCAL_LDLIBS := -lloginclude $(BUILD_SHARED_LIBRARY) 此时在源代码中即可使用 android/log.h 引入日志打印方法了。 12345678910111213141516// libfoo.cpp#include &lt;android/log.h&gt;#include \"main.h\"#include &lt;android/log.h&gt;static const char *TAG = \"NDK\";extern \"C\" {jstring Java_io_l0neman_mkexample_NativeHandler_getHello(JNIEnv *env, jclass clazz) { __android_log_print(ANDROID_LOG_DEBUG, TAG, \"log test.\"); return env-&gt;NewStringUTF(\"Hello-jni\");}}; CMakeCMake 描述如下，首先使用 find_library 描述 NDK 库，再用 target_link_libraries 指定链接库： 12345678910111213141516171819202122# CMakeLists.txtcmake_minimum_required(VERSION 3.4.3)add_library( foo SHARED main.cpp)find_library( # 使用变量描述系统库 log-lib # 系统库名字 log)# 指定将前面描述的 log-lib 库链接到目标 foo 中target_link_libraries( foo ${log-lib}) 如果需要添加多个库，新增 find_library 块，添加另一个库的描述后，在 target_link_libraries 加入即可： 1234567891011121314# CMakeLists.txt...find_library( zip-lib z)target_link_libraries( foo ${log-lib} ${zip-lib}) 引入预编译库有时需要引入提前编译好或者第三方提供的 so 共享库，或是引入现成的 .a 静态库，那么根据情况进行如下配置。 引入动态库 首先在独立的 NDK 工程编译出一个共享库 libbar.so（创建 libbar Module），作为第三方库提供给其他 Module 使用。 工程目录结构： 123456jni | +-- Android.mk +-- Application.mk +-- libbar.h +-- libbar.cpp 测试代码： 1234567891011// libbar.h#ifndef NDKTPROJECT_LIBBAR_H#define NDKTPROJECT_LIBBAR_Hextern \"C\" {int bar_add(int a, int b);};#endif //NDKTPROJECT_LIBBAR_H 123456// libbar.cpp#include \"libbar.h\"int bar_add(int a, int b) { return a + b;} 12345678910# libbar/src/main/jni/Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := barLOCAL_SRC_FILES := libbar.cppinclude $(BUILD_SHARED_LIBRARY) 1234# libbar/src/main/jni/Application.mkAPP_ABI := armeabi-v7a arm64-v8a x86 x86_64APP_OPTIM := debug 使用命令行进入 jni 目录下，然后执行 ndk-build 编译出 4 种架构的 libbar.so 文件，在和 jni 同级的 libs 目录下。 1234567891011121314jnilibs | +-- armeabi-v7a | +-- libbar.so | +-- arm64-v8a | +-- libbar.so | +-- x86 | +-- libbar.so | +-- x86_64 +-- libbar.so 将每种架构目录复制到需要使用此库的 NDK 工程中（libfoo.so Module），在工程中新建 include 目录，将 libbar 的头文件复制过来，为了提供调用的接口。 工程目录结构： 123456789101112131415161718192021jni | +-- armeabi-v7a | +-- libbar.so | +-- arm64-v8a | +-- libbar.so | +-- x86 | +-- libbar.so | +-- x86_64 | +-- libbar.so | +-- include | +-- libbar.h | +-- Android.mk +-- Application.mk +-- libfoo.h +-- libfoo.cpp 编写 libfoo.so Module 的 Android.mk 文件，$(TARGET_ARCH_ABI) 为 NDK 编译时每种架构的名字。 1234567891011121314151617LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)# 描述预编译库动态库的名称LOCAL_MODULE := libbar-pre# 描述预编译动态库路径LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.so# 描述预编译动态库引入的头文件LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/includeinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := main.cpp# 描述要使用的共享库名称LOCAL_SHARED_LIBRARIES := libbar-preinclude $(BUILD_SHARED_LIBRARY) 此时当工程编译时，对应的 libbar.so 将会自动被加入到 apk 包中。 代码调用 123456789101112131415// libfoo.h#ifndef NDKTPROJECT_LIBFOO_H#define NDKTPROJECT_LIBFOO_H#include &lt;jni.h&gt;extern \"C\" {JNIEXPORT void JNICALLJava_io_l0neman_mkexample_NativeHandler_test(JNIEnv *env, jclass clazz);};#endif //NDKTPROJECT_LIBFOO_H 123456789// libfoo.cpp#include \"libbar.h\"#include \"libfoo.h\"void Java_io_l0neman_mkexample_NativeHandler_test(JNIEnv *env, jclass clazz) { int a = bar_add(1, 4); printf(\"%d\\n\", a);} Java 层调用测试 1234567891011// class io.l0neman.mkexample.NativeHandlerpublic class NativeHandler { static { // 加载 libfoo.so 时，libbar 会被自动加载。 System.loadLibrary(\"foo\"); } public static native void test();} 12// MainActivity.javaNativeHandler.test(); 引入静态库 首先编译出 .a 后缀的静态库 libbar.a。 工程结构和上面引入动态库中的 libbar 工程一致，只需要将 Android.mk 文件中引入的 BUILD_SHARED_LIBRARY 变量修改为 BUILD_STATIC_LIBRARY 即可指定编译出静态库。 1234567891011# libbar/src/main/Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := barLOCAL_SRC_FILES := libbar.cpp# 指定编译出静态库include $(BUILD_STATIC_LIBRARY) 使用 ndk-build 编译后，不会产生和 jni 同级的 libs 目录，每种架构的 libbar.a 文件将出现在和 jni 同级的 obj 目录中。 目录结构如下： 1234567891011121314jniobj | +-- armeabi-v7a | +-- libbar.a | +-- arm64-v8a | +-- libbar.a | +-- x86 | +-- libbar.a | +-- x86_64 +-- libbar.a 在 libfoo.so 工程中引入静态库，步骤和引入动态库大同小异，把 obj 中每种架构的目录复制到需要使用此库的 NDK 工程中（libfoo.so），在工程中新建 include 目录，将 libbar 的头文件复制过来，为了提供调用的接口。 工程目录结构： 123456789101112131415161718192021jni | +-- armeabi-v7a | +-- libbar.a | +-- arm64-v8a | +-- libbar.a | +-- x86 | +-- libbar.a | +-- x86_64 | +-- libbar.a | +-- include | +-- libbar.h | +-- Android.mk +-- Application.mk +-- libfoo.h +-- libfoo.cpp 编写 libfoo.so 的 Android.mk 文件，$(TARGET_ARCH_ABI) 为 NDK 编译时每种架构的名字。 1234567891011121314151617LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)# 描述预编译静态库的名字LOCAL_MODULE := libbar-pre# 描述预编译静态库的位置LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.a# 描述预编译静态库引入的头文件LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/includeinclude $(PREBUILT_STATIC_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE := fooLOCAL_SRC_FILES := main.cpp# 描述要使用的静态库名称LOCAL_STATIC_LIBRARIES := libbar-preinclude $(BUILD_SHARED_LIBRARY) 此时当工程编译时，对应的 libbar.a 将会自动编译到 libfoo.so 中，成为它的一部分。 最后引用头文件正常调用编译即可，参考引用动态库中的步骤 4。 CMake上面的两个示例均为 Android.mk 构建示例，使用 CMake 构建简要描述如下： 引入动态库 首先将前面 libbar.so 复制到 CMake 项目的 jniLibs 中，项目结构如下： 12345678910111213141516171819202122232425main | +-- cpp | | | +-- include | | | | | +-- libbar.h | | | +-- libfoo.cpp | +-- libfoo.h | +-- CMakeLists.txt | +-- jniLibs | +-- armeabi-v7a | +-- libbar.so | +-- arm64-v8a | +-- libbar.so | +-- x86 | +-- libbar.so | +-- x86_64 +-- libbar.so 将预编译库放在 jniLibs 下面是为了在编译时打包到 apk 中。 其中 libfoo.cpp 和 libfoo.h 与上述 Android.mk 中源码一致，重点关注 CMakeLists.txt： 12345678910111213141516171819202122232425262728cmake_minimum_required(VERSION 3.4.3)# 设置当前路径变量set(CURRENT_DIR ${CMAKE_SOURCE_DIR})add_library( foo SHARED main.cpp)# 描述预编译动态库 bar-libadd_library( bar-lib SHARED IMPORTED)# 设置预编译库 bar-lib 位置属性set_target_properties( bar-lib PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/libbar.so)# 为上面预编译库指定头文件路径include_directories(include/)target_link_libraries( foo bar-lib) 编译测试即可。 引入静态库 将前面 libbar.a 复制到 CMake 项目的 cpp 中，项目结构如下： 123456789101112131415161718192021cpp | +-- include | | | +-- libbar.h | +-- libfoo.cpp +-- libfoo.h +-- CMakeLists.txt | +-- armeabi-v7a | +-- libbar.a | +-- arm64-v8a | +-- libbar.a | +-- x86 | +-- libbar.a | +-- x86_64 +-- libbar.a 由于静态库 .a 直接编译到目标文件 libfoo 中，所以不用放在 jniLibs 打包至 apk 中。 CMakeLists.txt： 12345678910111213141516171819202122232425262728cmake_minimum_required(VERSION 3.4.3)# 设置当前路径变量set(CURRENT_DIR ${CMAKE_SOURCE_DIR})add_library( foo SHARED main.cpp)# 描述预编译库静态库 bar-libadd_library( bar-lib STATIC IMPORTED)# 设置预编译库 bar-lib 位置属性set_target_properties( bar-lib PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/${ANDROID_ABI}/libbar.a)# 为上面预编译库指定头文件路径include_directories(include/)target_link_libraries( foo bar-lib) 编译测试即可。 参考https://developer.android.google.cn/ndk/guides/build","link":"/2020/07/14/android-ndk-%E6%8C%87%E5%8D%97/"},{"title":"Android JNI 指南","text":"前言编写此文档的用意： 作为 Android NDK 项目开发的参考手册。 对于 NDK 工程的搭建可参考 Android NDK 指南 JNI 简介JNI（Java Native Interface，Java 原生接口），是 Java 和 C++ 组件用以互相通信的接口。 Android 平台下的 JNI 支持由 Android NDK 提供，它是一套能将 C 或 C++（原生代码）嵌入到 Android 应用中的工具。 为什么要使用 JNI 在 Android 平台下进行编程： 在平台之间移植应用； 重复使用现有库，或者提供自己的库供重复使用； 在某些情况下提供高性能，特别是像游戏这种计算密集型应用； 提供安全性保障，在二进制层面比字节码层面的逆向工作更加困难。 JNI 优化原则 尽可能减少跨 JNI 层的编组（Marshalling）数据资源的次数，因为跨 JNI 层进行编组的开销很大。尽可能设计一种接口，减少需要编组的数据量以及必须进行数据编组的频率； 尽量避免在使用受管理的编程语言（在虚拟机中运行）中与 C/C++ 编写的代码之间进行异步通信（例如 C/C++ 中开启线程后直接回调 Java 语言），这样可以使 JNI 接口更容易维护。通常使用与编写界面的相同语言进行异步更新，以简化异步界面的更新，例如，使用 Java 语言创建线程，然后发出对 C++ 层的阻塞调用，然后在阻塞完成后通知界面线程； 尽可能减少需要访问 JNI 或被 JNI 访问的线程数。如果确实需要以 Java 和 C++ 两种语言来利用线程池，请尝试在池所有者之间（而不是各个工作线程之间）保持 JNI 通信； 将接口保存在少量的容易识别的 C++ 和 Java 源位置，以便于将来进行重构。 名词说明下文叙述中使用到的名词说明： JNI 方法，在 Java 层使用 native 声明，使用 C/C++ 中实现的方法。 JNI 函数，JNI 提供的与 Java 层交互的工具一系列函数，例如 RegisterNatives。 不透明，具体结构未知，由具体的虚拟机实现决定。 JavaVM 和 JNIEnvJNI 定义了两个关键的数据结构，JavaVM 和 JNIEnv，它们的本质都是指向函数表的二级指针（在 C++ 版本中，两者都是类，类中都有一个指向函数表的指针，它们的成员函数封装了通过函数表进行访问的 JNI 函数），可以使用 JavaVM 类进行创建和销毁 JavaVM 的操作。理论上，每个进程可以有多个 JavaVM，但 Android 只允许有一个。 JNIEnv 的指针将在每个 JNI 函数的第一个参数中。 这个 JNIEnv 只能用于线程本地存储（Thread Local），所以无法在线程之间共享 JNIEnv，如果需要在其他线程中访问 JNIEnv，可以通过 JavaVM 调用 GetEnv 函数获得相应的 JNIEnv 指针（需要在之前使用过 AttachCurrentThread 对此线程进行附加后调用）。 JavaVM 指针是全局的，可以在线程之间共享，通过保存 JavaVM 用于在其他线程中获取 JNIEnv。 JNIEnv 和 JavaVM 在 C 源文件和 C++ 源文件中的声明不同，使用 C 文件和 C++ 文件包含 jni.h 时，会有不同的类型定义。 123456789// jni.h#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#elsetypedef const struct JNINativeInterface* JNIEnv;typedef const struct JNIInvokeInterface* JavaVM;#endif 因此，不建议同时在这两种语言包含的头文件中添加 JNIEnv 参数（容易导致混乱）。或者当源文件中出现 #ifdef __cplusplus ，且该文件中所有的内容都引用了 JNIEnv 时，那么可能需要做额外的处理。 JNI 方法注册JNI 方法是 Java 代码与 C/C++ 代码沟通的桥梁，使用它时必须首先注册。JNI 方法的声明在 Java 类中，实现在 C/C++ 代码中，在 Java 层的方法声明前面必须添加 native 关键字，然后才能进行注册。 注册方式分为静态注册（根据 JNI 命令规范直接定义对应名字的 C/C++ 函数）和动态注册（使用 RegisterNatives 函数注册到 C/C++ 函数上）两种方式。 例如，Java 声明了如下 JNI 方法： 1234567891011// io.l0neman.jniexample.NativeHandlerpublic class NativeHandler { static { System.loadLibrary(\"hello\"); } // 期望 JNI 返回一个字符串。 public static native String getString();} NDK 工程描述如下： 123456789src/main/ | +-- java +-- jni | +-- Android.mk +-- Application.mk +-- hello.cpp +-- hello.h 12345678910# Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := helloLOCAL_SRC_FILES := hello.cppinclude $(BUILD_SHARED_LIBRARY) 下面将针对上面搭建的 NDK 工程，采用两种方式在 C/C++ 代码中实现 Java 类 NativeHandler 中的 getString 方法并注册。 静态注册静态注册只需要按照 JNI 接口规范，在 C/C++ 代码中声明一个 Java_[全类名中 的 . 替换为 _]_[方法名] 函数，然后添加 JNIEXPORT 前缀即可。 当系统加载 so 文件后，将根据名字对应规则，自动注册 JNI 方法。 下面采用了 C++ 代码描述，其中的函数需要使用 extern &quot;C&quot; 来包括（为了兼容 C 语言的符号签名规则，让 C 语言能够正常链接调用它）。 12345678910111213// hello.h#ifndef NDKTPROJECT_MAIN_H#define NDKTPROJECT_MAIN_H#include &lt;jni.h&gt;extern \"C\" {JNIEXPORT jstring JNICALLJava_io_l0neman_jniexample_NativeHandler_getString(JNIEnv *env, jclass clazz);}#endif //NDKTPROJECT_MAIN_H 123456789// hello.cpp#include \"main.h\"extern \"C\" {jstring Java_io_l0neman_jniexample_NativeHandler_getString(JNIEnv *env, jclass clazz) { return env-&gt;NewStringUTF(\"hello\");}} 如果是 C 语言代码的实现，那么可以去除 extern &quot;C&quot; 的声明，且返回字符串的代码要改为： 12// 此时 C 语言中的 env 不是类，只是一个指向函数表的指针return (*env)-&gt;NewStringUTF(env, \"hello\"); 此时就注册完成了，Java 层可以直接调用 textView.setText(NativeHandler.getString()) 进行测试了。 这种注册方式简单直接，但是所有 C/C++ 中实现的 JNI 函数符号都需要被导出，对于逆向人员来说，使用 IDA Pro 可以直接看到注册 JNI 方法的名字，快速定位到对应的 Java 代码。 动态注册动态注册与静态注册不同，它是用 JNIEnv 类型提供的 registerNatives 方法来将 JNI 方法动态绑定到指定的 C/C++ 函数上。 首先需要实现 JNI 提供的标准入口函数，JNI_OnLoad，它将会在调用 System.loadLibrary(&quot;hello&quot;) 后，由 Java 虚拟机进行回调，同时可以实现可选的 JNI_OnUnload 函数，用于虚拟机将动态库卸载时回收资源。 12345// hello.cppJNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { return JNI_VERSION_1_6;} 返回值表示要使用的 JNI 版本，返回低版本，将不能使用高版本提供的一些 JNI 函数，这里返回当前最高版本 JNI_VERSION_1_6，如果返回其它非版本数值，将导致加载 so 库失败。 完整注册代码如下： 1234567891011121314151617181920212223242526272829303132333435// hello.cppstatic const char *CLASS_NAME = \"io/l0neman/jniexample/NativeHandler\";static jstring getString(JNIEnv *env, jclass nativeHandler) { return env-&gt;NewStringUTF(\"hello\");}static JNINativeMethod gMethods[] = { {\"getString\", \"()Ljava/lang/String;\", (void *) getString},};JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = nullptr; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } jclass nativeHandlerClass = env-&gt;FindClass(CLASS_NAME); if (nativeHandlerClass == nullptr) { return JNI_ERR; } jint methods = sizeof(gMethods) / sizeof(JNINativeMethod); jint ret = env-&gt;RegisterNatives(nativeHandlerClass, gMethods, methods); if (ret != JNI_OK) { return ret; } return JNI_VERSION_1_6;}JNIEXPORT void JNI_OnUnload(JavaVM *vm, void *reserved) { // 回收工作} 从 JNI_OnLoad 开始看。 首先 RegisterNatives 这个函数由 JNIEnv 类型提供，而 JNI_OnLoad 第一个参数是 JavaVM *，所以，这里首先获取 JNIEnv 类型指针，使用 JavaVM 的 GetEnv 函数获取（由于系统默认已经附加到线程，所以这里才能直接 GetEnv）; 下面需要使用 RegisterNatives 注册 JNI 函数，看一下它的声明： 123// jni.hjint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods); 第 1 个参数是 JNI 方法所在的 Java 类，第 2 个是包含需要注册的 JNI 方法对应关系的数组，第 3 个是要注册的 JNI 方法数量或者说前面的数组大小。 那么，就根据要求填充相关参数。 使用 JNIEnv 的 FindClass 来获得表示 NativeHandler 类型的 jclass，可以看到描述全类名的方法，将 . 替换为路径符号 / 即可，这样得到了第一个参数； 定义一个 JNINativeMethod 的数组，每个 JNINativeMethod 都用于描述一个 JNI 方法的 Java 方法声明和 C/C++ 函数的一对一关系。 JNINativeMethod 定义如下： 1234567// jni.htypedef struct { const char* name; const char* signature; void* fnPtr;} JNINativeMethod; 分别是 Java 层 JNI 方法的名字，方法签名，和要注册的 C/C++ 函数地址。 在方法签名中，每种 Java 基本类型都有对应的签名字符串，引用类型则为 L[全类型名中的 . 替换为 /];。 JNI 类型签名如下表： 签名 Java 类型 Z boolean B byte C char S short I int J long F float D double L 引用类型 [ 数组前缀 示例： 1long f (int n, String s, int[] arr); 签名为： 1(ILjava/lang/String;[I)J 那么前面的代码中的 gMethods 数组，即表明了要把 NativeHandler 中的 getString 注册绑定到 C++ 中的 getString 函数上。 最后调用 env-&gt;RegisterNatives 函数就可以了，一般情况下，注册成功，那么返回 JNI_OK。 可以允许在 JNI_OnLoad 中绑定多个 Java 类中的 native 方法，建议不要这样做，会导致难以维护。 动态注册的好处是，可以只导出 JNI_OnLoad（注册的 C/C++ 函数可以进行符号优化，不导出），生成速度更快且更小的代码，且可避免与加载到应用中的其他库发生潜在冲突。 类静态方法和类成员方法注册 Java 中的静态 JNI 方法和类成员 JNI 方法的区别是，对应的 C/C++ 函数的回调参数不同。 123456789101112// io.l0neman.jniexample.NativeHanderpublic class NativeHandler { static { System.loadLibrary(\"hello\"); } public static native String getString(); public native String getHello();} 对应的 C++ 函数： 12345678jstring getString(JNIEnv *env, jclass nativeHandler) { return env-&gt;NewStringUTF(\"hello\");}jstring getHello(JNIEnv *env, jobject thiz) { jclass nativeHandlerClass = env-&gt;GetObjectClass(thiz); return env-&gt;NewStringUTF(\"hello\");} 静态方法传递的是代码 Java 类的 jclass，而类方法传递的是表示 Java this 对象的 jobject，可以使用它来访问对应的 this 对象内的成员变量和相关方法。如果需要访问 jclass，使用 JNI 提供的 GetObjectClass 函数获取。 在注册工作完成后，就可以从 Java 层调用 JNI 方法，使用 C/C++ 语言处理逻辑了。 Java 层访问在 C/C++ 代码中，需要对 Java 层进行访问，最基本的两种访问操作就是读写 Java 类成员和调用 Java 类方法。 Java 成员变量访问JNI 提供了一系列访问 Java 类的静态成员和对象成员的函数，例如。 123456789GetStaticIntField(); // 读取 Java 类型为 int 的类静态成员SetStaticIntField(); // 写入 Java 类型为 int 的类静态成员GetStaticObjectField(); // 读取类型为 Java 引用的类静态成员SetStaticObjectField(); // 写入类型为 Java 引用的类静态成员GetIntField(); // 读取 Java 类型为 int 的类对象成员SetIntField(); // 写入 Java 类型为 int 的类对象成员GetObjectField(); // 读取类型为 Java 引用的类对象成员SetObjectField(); // 写入类型为 Java 引用的类对象成员 总结为： 1234GetStatic&lt;type&gt;Field(); // 读取 Java 类型为 type 的类静态成员SetStatic&lt;type&gt;Field(); // 写入 Java 类型为 type 的类静态成员Get&lt;type&gt;Field(); // 读取 Java 类型为 type 的类对象成员Set&lt;type&gt;Field(); // 写入 Java 类型为 type 的类对象成员 当需要访问静态成员时需要提供一个代表 Java 类型的 jclass 作为参数，访问类对象成员时则需要一个表示 Java 对象的 jobject 作为参数。 同时两者都需要首先提供目标 Java 类成员的 JNI 类型签名（符合上面的 JNI 签名表规则），用来获取一个不透明的 jfieldID 类型，传递给 JNI 函数，用于找到目标成员，之后才能使用上述 JNI 函数访问 Java 类成员。 1jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig); Java 类方法访问JNI 同时也提供了一系列调用 Java 类的静态方法和对象方法的函数，例如： 123456789CallStaticVoidMethod(); // 调用返回值类型为 void 的静态方法CallStaticIntMethod(); // 调用返回值类型为 int 的静态方法CallObjectMethod(); // 调用返回值类型为 Java 引用的静态方法// ...CallVoidMethod(); // 调用返回值类型为 void 的对象方法CallIntMethod(); // 调用返回值类型为 int 的对象方法CallObjectMethod(); // 调用返回值类型为 Java 引用的成员方法// ... 总结为： 12env-&gt;CallStatic&lt;type&gt;Method(); // 调用返回值类型为 type 的静态方法env-&gt;Call&lt;type&gt;Method(); // 调用返回值类型为 type 的成员方法 当需要调用静态方法时需要提供一个代表 Java 类型的 jclass 作为参数，调用类成员方法时则需要一个表示 Java 对象的 jobject 作为参数。 同时两者都需要首先提供目标 Java 方法的 JNI 签名（符合上面的 JNI 签名表规则），用来获取一个不透明的 jMethodID 类型，传递给 JNI 函数，用于找到目标方法，之后才能使用上述 JNI 函数调用 Java 类方法。 Java 层访问实例下面对实际的 Java 类成员和方法进行访问和调用。 首先定义一个 Java 类，JniCallExample。 123456789101112131415// io.hexman.jniexample.JniCallExamplepublic class JniCallExample { private static int sFlag = 256; private String mData = \"info\"; public String getData() { return mData; } public static boolean setHello(String hello) { return \"hello\".equals(hello); }} JniCallExample 类具有一个静态成员 sFlag，和成员变量 mData，还包含一个 getData 成员方法和一个静态方法。 那么下面将进行如下操作： 读取 sFlag 的值并打印； 改变 mData 的值，然后调用 Java 层的 getData 方法，获得修改后的值； 调用 Java 层的 sayHello 方法，传递 hello 字符串，获得方法返回值。 这里需要在 C/C++ 代码中打印变量，所以需要使用 NDK 提供的 liblog 库，Android.mk 如下： 1234567891011LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := helloLOCAL_SRC_FILES := hello.cpp# 此行表示依赖 liblog 库LOCAL_LDLIBS := -lloginclude $(BUILD_SHARED_LIBRARY) 下面开始编写源代码。 首先在 NativeHandler 类里面，声明 JNI 方法 void testAccessJava(JniCallExample jniCallExample)，用于调用 C/C++ 代码来启动测试。 其中提供一个 JniCallExample 对象，是因为需要访问它的成员值。 12345678910// io.hexman.jniexample.NativeHandlerpublic class NativeHandler { static { System.loadLibrary(\"hello\"); } public static native void testAccessJava(JniCallExample jniCallExample);} 然后在 C++ 代码中定义对应的 JNI 方法的实现函数，并在 JNI_OnLoad 中注册函数。 12345678910111213141516171819202122232425262728293031// hello.cppstatic const char *CLASS_NAME = \"io/l0neman/jniexample/NativeHandler\";static JNINativeMethod gMethods[] = { {\"testAccessJava\", \"(Lio/l0neman/jniexample/JniCallExample;)V\", (void *) testAccessJava},};void testAccessJava(JNIEnv *env, jobject nativeHandler) { // ...}JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = nullptr; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } jclass nativeHandlerClass = env-&gt;FindClass(CLASS_NAME); if (nativeHandlerClass == nullptr) { return JNI_ERR; } jint methods = sizeof(gMethods) / sizeof(JNINativeMethod); jint ret = env-&gt;RegisterNatives(nativeHandlerClass, gMethods, methods); if (ret != JNI_OK) { return ret; } return JNI_VERSION_1_6;} 下面填充 testAccessJava 的逻辑： 1234567891011121314151617181920212223242526272829303132333435363738// hello.cppstatic const char *TAG = \"TAJ\";// 用于输出 Java 字符串（mData）的工具函数void utilPrintJavaStr(JNIEnv *env, jstring jStr) { const char *mDataCChar = env-&gt;GetStringUTFChars(jStr, nullptr); // str+ // 这里需要把 Java 字符串转为 C 字符串才能输出 __android_log_print(ANDROID_LOG_DEBUG, TAG, \"jniCallExample.mData: %s\", mDataCChar); env-&gt;ReleaseStringUTFChars(jStr, mDataCChar); // str-}void testAccessJava(JNIEnv *env, jclass nativeHandler, jobject jniCallExample) { jclass jniCallExampleClass = env-&gt;FindClass(\"io/l0neman/jniexample/JniCallExample\"); jfieldID sFlagStaticFieldId = env-&gt;GetStaticFieldID(jniCallExampleClass, \"sFlag\", \"I\"); // Java: int sFlag = JniCallExample.sFlag; jint sFlag = env-&gt;GetStaticIntField(jniCallExampleClass, sFlagStaticFieldId); __android_log_print(ANDROID_LOG_DEBUG, TAG, \"JniCallExample.sFlag: %d\", sFlag); jfieldID mDataFieldId = env-&gt;GetFieldID(jniCallExampleClass, \"mData\", \"Ljava/lang/String;\"); // Java: newData = \"data; jstring newData = env-&gt;NewStringUTF(\"data\"); // Java: jniCallExample.mData = newData; env-&gt;SetObjectField(jniCallExample, mDataFieldId, newData); jmethodID getDataMethodId = env-&gt;GetMethodID(jniCallExampleClass, \"getData\", \"()Ljava/lang/String;\"); // Java: String newMData = jniCallExample.getData(); jstring newMData = (jstring) env-&gt;CallObjectMethod(jniCallExample, getDataMethodId); utilPrintJavaStr(env, newMData); jmethodID setHelloStaticMethodId = env-&gt;GetStaticMethodID(jniCallExampleClass, \"setHello\", \"(Ljava/lang/String;)Z\"); // JavaL helloParam = \"hello\"; jstring helloParam = env-&gt;NewStringUTF(\"hello\"); // Java: JniCallExample.setHello(helloParam); jboolean isSetHello = (jboolean) env-&gt;CallStaticBooleanMethod(jniCallExampleClass, setHelloStaticMethodId, helloParam); __android_log_print(ANDROID_LOG_DEBUG, TAG, \"isSetHello %d\", isSetHello);} 打印出如下结果： 123JniCallExample.sFlag: 256jniCallExample.mData: dataisSetHello 1 其中注释 Java: xxx 表示与 Java 代码有相同作用。 其中包含一部分对于字符串的操作： env-&gt;NewStringUTF(&quot;data&quot;) 用于创建一个 Java 字符串（new String()），它的内存由 Java 虚拟机管理，它使用 jstring 类型来描述，是一个 JNI 提供的不透明类型，用于映射一个 Java 字符串。每种 Java 类型都有对应的映射类型（下面会提供映射表），这里用作 Java 变量来给 Java 变量赋值或者作为参数传递。 env-&gt;GetStringUTFChars(jStr, nullptr); 用于从 Java 字符串中取得 C 形式的 Modified_UTF-8（下文介绍）字符串，它将会在 native 层分配内存，而不是由 Java 虚拟机管理，所以使用后需要手动使用 ReleaseStringUTFChars 释放。 访问优化在对 Java 层进行访问时，不管是访问 Java 类成员还是调用 Java 方法，都需要首先使用 FindClass 找到目标 Java 类，然后获取对应的成员 ID 和方法 ID， 对于 FindClass 和查找相关 ID 的函数，每次调用它们可能都需要进行多次的字符串比较，而使用这些 ID 去访问对于的 Java 类成员和方法速度却是很快的。 那么如果需要多次访问相同的 Java 目标，那么考虑将这些 jclass（FindClass 的结果）和相关 ID 缓存起来。 这些变量在被访问的 Java 类被卸载之前保证是有效的。只有在与 ClassLoader 关联的所有类都满足垃圾回收条件时，系统才会卸载这些类，这种情况比较少见，但在 Android 中是有可能出现的。 Android 推荐的方法是，在 Java 类中声明一个名叫 nativeInit 的 JNI 方法，在类的静态块内调用，这个 JNI 方法就负责提前缓存要使用的 Java 类型，那么一个类被加载时，nativeInit 就会被调用。 可以在 Android 系统源码中看到许多名叫 nativeInit 的 JNI 方法，它们就是负责此用途的。 一般使用 static 结构来缓存这些 ID 和 jclass，jclass 作为 Java 引用，需要使用 NewGlobalRef 函数创建一个全局引用来保护它不被回收。 那么现在改进之前的 Java 访问实例，如下： 首先在 NativeHandler 中增加 nativeInit 方法。 12345678910111213// io.hexman.jniexample.NativeHandlerpublic class NativeHandler { static { System.loadLibrary(\"hello\"); nativeInit(); } public static native void nativeInit(); public static native void testAccessJava(JniCallExample jniCallExample);} 然后是源代码，注册部分只修改 JNINativeMethod 数组即可： 1234static JNINativeMethod gMethods[] = { {\"testAccessJava\", \"(Lio/l0neman/jniexample/JniCallExample;)V\", (void *) testAccessJava}, {\"nativeInit\", \"()V\", (void *) nativeInit}}; 然后是 nativeInit 的逻辑和修改过的 testAccessJava 函数的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// hello.cpp// 缓存结构体struct JniCallExampleHolder { jclass jniCallExampleClass; jfieldID sFlagStaticFieldId; jfieldID mDataFieldId; jmethodID getDataMethodId; jmethodID setHelloStaticMethodId;};static JniCallExampleHolder gJniCallExampleHolder;// 提前缓存 jclass 和访问 IDvoid nativeInit(JNIEnv *env, jclass clazz) { jclass jniCallExampleClass = env-&gt;FindClass(\"io/l0neman/jniexample/JniCallExample\"); gJniCallExampleHolder.jniCallExampleClass = (jclass) env-&gt;NewGlobalRef(jniCallExampleClass); // gr+ gJniCallExampleHolder.sFlagStaticFieldId = env-&gt;GetStaticFieldID(jniCallExampleClass, \"sFlag\", \"I\");; gJniCallExampleHolder.mDataFieldId = env-&gt;GetFieldID(jniCallExampleClass, \"mData\", \"Ljava/lang/String;\"); gJniCallExampleHolder.getDataMethodId = env-&gt;GetMethodID(jniCallExampleClass, \"getData\", \"()Ljava/lang/String;\");; gJniCallExampleHolder.setHelloStaticMethodId = env-&gt;GetStaticMethodID(jniCallExampleClass, \"setHello\", \"(Ljava/lang/String;)Z\");}void testAccessJava(JNIEnv *env, jclass nativeHandler, jobject jniCallExample) { // Java: int sFlag = JniCallExample.sFlag; jint sFlag = env-&gt;GetStaticIntField(gJniCallExampleHolder.jniCallExampleClass, gJniCallExampleHolder.sFlagStaticFieldId); __android_log_print(ANDROID_LOG_DEBUG, TAG, \"JniCallExample.sFlag: %d\", sFlag); // Java: newData = \"data; jstring newData = env-&gt;NewStringUTF(\"data\"); // Java: jniCallExample.mData = newData; env-&gt;SetObjectField(jniCallExample, gJniCallExampleHolder.mDataFieldId, newData); // Java: String newMData = jniCallExample.getData(); jstring newMData = (jstring) env-&gt;CallObjectMethod(jniCallExample, gJniCallExampleHolder.getDataMethodId); utilPrintJavaStr(env, newMData); // JavaL helloParam = \"hello\"; jstring helloParam = env-&gt;NewStringUTF(\"hello\"); // Java: JniCallExample.setHello(helloParam); jboolean isSetHello = (jboolean) env-&gt;CallStaticBooleanMethod(gJniCallExampleHolder.jniCallExampleClass, gJniCallExampleHolder.setHelloStaticMethodId, helloParam); __android_log_print(ANDROID_LOG_DEBUG, TAG, \"isSetHello %d\", isSetHello);} 其中有一个地方使用了 env-&gt;NewGlobalRef 建立了一个全局引用，它会保护这个 jclass 不会在 JNI 函数执行完之后被回收，注意需要在不使用的时候使用 env-&gt;DeleteGlobalRef 释放引用，例如 JNI_OnUnload 中。 JNI 类型每种 Java 类型在 JNI 中都有对应的本地数据类型，C/C++ 通过 JNI 方法与 Java 层进行交互时，均是使用这些类型进行参数传递，此时虚拟机再根据每种类型翻译为相应的 Java 类型传递给 Java 层方法. 还有一些特殊的数据类型用来存储 Java 方法 ID 和类成员 ID。 基本数据类型 Java 类型 本地类型 说明 boolean jboolean unsigned 8 bits byte jbyte signed 8 bits char jchar signed 16 bits short jshort signed 16 bits int jint signed 32 bits long jlong signed 64 bits float jfloat 32 bits double jdouble 64 bits void void 无 jboolean 的两种取值： 12#define JNI_FALSE 0 #define JNI_TRUE 1 jsize 类型用于描述数组大小或者索引。 从 jni.h 中看它们和真实 C/C++ 数据类型的对应关系： 1234567891011121314// jni.h/* Primitive types that match up with Java equivalents. */typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 *//* \"cardinal indices and sizes\" */typedef jint jsize; 引用类型在 C++ 中，Java 引用类型使用一些类表示，它们的继承关系如下： 1234567891011121314151617jobject (所有 Java 对象) | +-- jclass (java.lang.Class 对象) +-- jstring (java.lang.String 对象) +-- jarray (数组) | | | +-- jobjectArray (object 数组) | +-- jbooleanArray (boolean 数组) | +-- jbyteArray (byte 数组) | +-- jcharArray (char 数组) | +-- jshortArray (short 数组) | +-- jintArray (int 数组) | +-- jlongArray (long 数组) | +-- jfloatArray (float 数组) | +-- jdoubleArray (double 数组) | +- jthrowable (java.lang.Throwable 对象) 源码中定义如下： 1234567891011121314151617181920212223242526272829303132// jni.hclass _jobject {};class _jclass : public _jobject {};class _jstring : public _jobject {};class _jarray : public _jobject {};class _jobjectArray : public _jarray {};class _jbooleanArray : public _jarray {};class _jbyteArray : public _jarray {};class _jcharArray : public _jarray {};class _jshortArray : public _jarray {};class _jintArray : public _jarray {};class _jlongArray : public _jarray {};class _jfloatArray : public _jarray {};class _jdoubleArray : public _jarray {};class _jthrowable : public _jobject {};typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray* jbyteArray;typedef _jcharArray* jcharArray;typedef _jshortArray* jshortArray;typedef _jintArray* jintArray;typedef _jlongArray* jlongArray;typedef _jfloatArray* jfloatArray;typedef _jdoubleArray* jdoubleArray;typedef _jthrowable* jthrowable;typedef _jobject* jweak; 在 C 语言中，所有 JNI 引用类型都与 jobject 的定义相同。 1234567891011121314151617// jni.htypedef void* jobject;typedef jobject jclass;typedef jobject jstring;typedef jobject jarray;typedef jarray jobjectArray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jobject jthrowable;typedef jobject jweak; 方法和类成员 ID它们是不透明结构体指针类型： 1234567// jni.hstruct _jfieldID;typedef struct _jfieldID *jfieldID; struct _jmethodID;typedef struct _jmethodID *jmethodID; 数组元素jvalue 用于作为参数数组中的元素类型： 12345678910111213// jni.htypedef union jvalue { jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l;} jvalue; 引用管理Java 对象在 JNI 中有两种引用方式，一种是局部引用；一种是全局引用。 局部引用Java 层通过 JNI 方法传递给 C/C++ 函数的每个对象参数，以及 C/C++ 通过 JNI 函数（Call&lt;type&gt;Method）调用接收的 Java 方法的对象返回值都属于局部引用。 局部引用仅在当前线程中的当前 C/C++ 函数运行期间有效。在 C/C++ 函数返回后，即使对象本身继续存在，该引用也无效。 局部引用适用于 jobject 的所有子类，包括 jclass、jstring 和 jarray。 全局引用创建全局引用只能使用 NewGlobalRef 和 NewWeakGlobalRef 函数。 如果希望长时间的持有某个引用，那么必须使用全局引用，使用 NewGlobalRef 函数时将局部引用作为参数传入，换取全局引用。在调用 DeleteGlobalRef 删除全局引用之前，此引用保证有效。 通常用于缓存 FindClass 返回的 jclass，就像前面的 Java 访问优化中所做的措施一样。 12jclass localClass = env-&gt;FindClass(\"MyClass\");jclass globalClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(localClass)); 提示对于同一个对象的引用可能存在多个不同的值，例如，对于同一个对象多次调用 NewGlobalRef 所返回的值可能不同。 如果需要比较两个引用是否指向同一个对象，必须使用 IsSameObject 函数，切勿在 C/C++ 代码中使用 == 比较各个引用。 在两次调用 NewGlobalRef 对同一个对象创建全局引用时，表示这个对象的 32 位值可能不同；而在多次调用 NewGlobalRef 创建不同对象的全局引用时，它们可能具有相同的 32 位值，所以不能将 jobject 用作 key 使用。 不要过度分配局部引用，如果需要创建大量引用，应该主动调用 DeleteLocalRef 删除它们，而不是期望 JNI 自动删除。JNI 默认实现只能保留 16 个局部引用，如果需要保存更多数量，可以按照需要删除，或使用 EnsureLocalCapacity/PushLocalFrame 申请保留更多引用数量。 jfieldID 和 jmethodID 为不透明类型，不属于对象引用，所以不能使用 NewGlobalRef 保护。GetStringUTFChars 和 GetByteArrayElements 返回的原始数据指针也不属于对象。 一种特殊情况是，如果使用 AttachCurrentThread 附加到 C/C++ 线程，那么在线程分离之前，运行中的代码一定不会自动释放局部引用。代码创建的任何局部引用都必须手动删除。通常，在循环中创建局部引用的任何 C/C++ 代码需要执行某些手动删除操作。 谨慎使用全局引用。全局引用不可避免，但它们很难调试，并且可能会导致难以诊断的内存（不良）行为。在所有其他条件相同的情况下，全局引用越少，解决方案的效果可能越好。 Java 常用数据访问对 Java 字符串和数组的访问方法。访问这些数据是 JNI 开发的基础。 访问字符串访问字符串有如下两种情况： Java 层调用 JNI 方法，String 对象以 jstring 的形式传入 JNI 方法，此时 C/C++ 语言接收使用； C/C++ 产生字符串数据，返回给 Java 层使用。 代码如下： 1234// Java Code// hello = \"result\"final String hello = NativeHandler.testAccessString(\"hello\"); 123456789// C++ Codejstring testAccessString(JNIEnv *env, jclass clazz, jstring hello) { const char *stringChars = env-&gt;GetStringUTFChars(hello, nullptr); // str+ __android_log_print(ANDROID_LOG_DEBUG, TAG, \"java string: %s\", stringChars); env-&gt;ReleaseStringUTFChars(hello, stringChars); // str- return env-&gt;NewStringUTF(\"result\");} 获取字符串GetStringUTFChars 将返回 C/C++ 语言可以直接使用的 Modified_UTF-8 格式字符串（Modified_UTF-8 格式是 JNI 提供的优化后的 UTF-8 格式字符串，优化后的编码对 C 代码友好，因为它将 \\u0000 编码为 0xc0 0x80，而不是 0x00。这样做的好处是，可以依靠以 \\0 终止的 C 样式字符串，非常适合与标准 libc 字符串函数配合使用。但缺点是，无法将任意 UTF-8 的数据传递给 JNI 函数）。 在使用 GetStringUTFChars 获取字符串后，JavaVM 为字符串在 native 层分配了内存，在字符串使用完毕后，必须使用 ReleaseStringUTFChars 释放内存，否则将会造成内存泄漏。 从 C/C++ 获取 Java 字符串的长度有两种方式，可直接使用 GetStringUTFLength 对 jstring 计算长度： 1234// Java Codejstring hello;jsize utfLength = env-&gt;GetStringUTFLength(hello); 或者使用 C/C++ 的 strlen 计算： 1234// C++ Codeconst char *stringChars = env-&gt;GetStringUTFChars(hello, nullptr);size_t utfLength = strlen(stringChars); GetStringUTFChars 函数的第 2 个参数是一个 jboolean 类型的指针，表示关心是否创建了字符串的副本，如果创建了字符串的副本它会返回 JNI_TRUE，否则为 JNI_FALSE，不管是否创建，都需要 Release 操作，所以一般不会关心它的结果，传递 nullptr 即可（C 语言传递 NULL）。 123456789// C++ Codejboolean isCopy;const char *stringChars = env-&gt;GetStringUTFChars(hello,); // str+if (isCopy == JNI_TRUE) { // 创建了字符串副本} else if (isCopy == JNI_FALSE) { // 未创建字符串副本} 提示JNI 还提供了 GetStringChars 函数，它返回的是 UTF-16 字符串，使用 UTF-16 字符串执行操作通常会更快，但是 UTF-16 字符串不是以零终止的，并且允许使用 \\u0000，因此需要保留字符串长度和返回的 jchar 指针。 一般的开发中几乎都使用 GetStringUTFChars 获取字符串。 返回字符串如果需要返回给 Java 层字符串，使用 env-&gt;NewStringUTF(&quot;result&quot;) 即可，JavaVM 将会基于 C 字符串创建一个新的 String 的对象，它的内存由虚拟机管理。 注意传递给 NewStringUTF 的数据必须采用 Modified_UTF-8 格式。一种常见的错误是从文件或网络数据流中读取字符数据，在未过滤的情况下将其传递给 NewStringUTF。除非确定数据是有效的 Modified_UTF-8 格式（或 7 位 ASCII，这是一个兼容子集），否则需要剔除无效字符或将它们转换为适当的 Modified_UTF-8 格式。如果不这样做，UTF-16 转换可能会产生意外的结果（Java 语言使用的是 UTF-16）。默认状态下 CheckJNI 会为模拟器启用，它会扫描并在收到无效字符串输入时中止虚拟机。 访问数组和访问 Java 成员类似，JNI 提供了一系列访问数组的函数： 1234GetIntArrayElements();GetBooleanArrayElements();GetDoubleArrayElements();// ... 总结为： 1Get&lt;type&gt;ArrayElements(); 其中 &lt;type&gt; 中只能是 Java 的基本类型，不包含 String 以及其他引用类型。 下面分别使用 C/C++ 获取 Java 传递的 int 类型和 String 的数组，作为获取 Java 基本类型和引用类型数组的典型示例： 12345// Java Codeint[] array0 = {1, 2, 3, 4, 5};String[] array1 = {\"a\", \"b\", \"c\", \"d\", \"e\"};NativeHandler.testAccessArray(array0, array1); 1234567891011121314151617181920212223// C++ Codevoid testAccessArray(JNIEnv *env, jclass clazz, jintArray array0, jobjectArray array1) { // 访问原始数组 jint *elements0 = env-&gt;GetIntArrayElements(array0, nullptr); if(elements0 != nullptr) { jsize array0Length = env-&gt;GetArrayLength(array0); for (jint i = 0; i &lt; array0Length; i++) { __android_log_print(ANDROID_LOG_DEBUG, TAG, \"array0[%d] = %d\", i, elements0[i]); } env-&gt;ReleaseIntArrayElements(array0, elements0, 0); } // 访问对象数组 jsize array1Length = env-&gt;GetArrayLength(array1); for (jint i = 0; i &lt; array1Length; i++) { jstring element = (jstring) env-&gt;GetObjectArrayElement(array1, i); const char *chars = env-&gt;GetStringUTFChars(element, nullptr); // str+ __android_log_print(ANDROID_LOG_DEBUG, TAG, \"array1[%d] = %s\", i, chars); env-&gt;ReleaseStringUTFChars(element, chars); // str- }} 输出如下： 12345678910array0[0] = 1array0[1] = 2array0[2] = 3array0[3] = 4array0[4] = 5array1[0] = aarray1[1] = barray1[2] = carray1[3] = darray1[4] = e 代码比较清晰，可以看到基本类型的数组，直接可以使用 Get&lt;type&gt;ArrayElements(...) 获得一个数组的首地址，使用 GetArrayLength 获取数组长度后，即可像 C/C++ 原生数组一样使用指针遍历每一个元素。 在对原生类型的数组访问之后，需要调用 Release&lt;type&gt;ArrayElements 请求释放内存。 对象数组则没有提供 Get&lt;type&gt;ArrayElements(...) 的方法，但是它提供了获取单个元素的 GetObjectArrayElement 方法，那么也可以使用循环获取每个 jobject 元素，然后转换为原本的类型。 如果需要更改原生类型的数组元素值，直接修改获取 C/C++ 数组元素的值，JNI 将会把值复制回原始数据区中。 如果需要更改引用类型的数组元素值，JNI 提供了 SetObjectArrayElement 函数，可直接修改原始元素对象。 1env-&gt;SetObjectArrayElement(array1, 1, env-&gt;NewStringUTF(\"hello\")); 提示JNI 为了在不限制虚拟机实现的情况下使接口尽可能高效，允许 Get&lt;type&gt;ArrayElements(...) 函数的调用在运行时直接返回指向实际数据元素的指针，或者分配一些内存创建数据的副本。 在调用 Release 之前，返回的原生数组指针保证可用，如果没有创建数据的副本，那么原生数组将被固定，在虚拟机整理内存碎片时不会调整原生数组的位置，Release 的时候需要进行判空操作，防止在 Get 数组失败时 Release 空指针。 ReleaseIntArrayElements 函数的最后一个函数的 mode 参数有三个，运行时执行的操作取决于返回的指针指向实际数据还是指向数据副本。 mode 以及对应的 Release 行为： 0 实际数据：取消数组元素固定。数据副本：将数据复制回原始数据，释放包含副本的缓冲区。 JNI_COMMIT 实际数据：不执行任何操作。数据副本：将数据复制回原始数据，不释放包含副本的缓冲区。 JNI_ABORT 实际数据：取消数组元素固定，不中止早期的写入数据。数据副本：释放包含相应副本的缓冲区；对该副本所做的任何更改都会丢失。 通常传递 0 来保持固定和复制数组的行为一致，其他选项可以用来更好地控制内存，需要谨慎传递。 其中 GetIntArrayElements 的第 2 个参数，它类似于 GetStringUTFChars 的第 2 个参数，也是 isCopy，表示获取数组时是否创建了数据副本。 通常检查 isCopy 标志的原因有两个： 了解是否需要在对数组进行更改后使用 JNI_COMMIT 调用 Release 函数，如果需要在对数组进行更改和仅使用数组内容的代码之间切换，则可以跳过释放缓冲区提交（更改数组数据后需要继续访问数组）； 有效处理 JNI_ABORT，考虑可能需要获取一个数组，然后进行适当修改后，将数组的一部分传递给其他函数使用，最后舍弃对数组的修改。如果知道 JNI 为数组创建了副本，那么就不需要自己创建一个可被修改的副本，如果 JNI 传递的是实际数据的指针，那么就需要自己创建数组的副本。 注意不能认为 *isCopy 为 JNI_FALSE 时就不需要调用 Release，这是一种常见误区。 如果 JNI 没有分配任何副本缓冲区，返回指向实际数据的指针，那么虚拟机必须固定实际数组的内存，此时垃圾回收器将不能移动内存，造成内存不能释放。 JNI_COMMIT 标记不会释放数组，最终还需要使用其他标记再次调用 Release。 数组区域调用如果只想复制 Java 数组，使用 Get&lt;type&gt;ArrayRegion 更好。 通常使用 Get&lt;type&gt;ArrayElements 时，如果需要复制数组数据到外部的缓冲区中，代码如下： 12345jbyte* data = env-&gt;GetByteArrayElements(array, NULL);if (data != nullptr) { memcpy(buffer, data, len); env-&gt;ReleaseByteArrayElements(array, data, JNI_ABORT);} 这样会复制数组 len 长度的字节到 buffer 中，然后释放数组内存。其中 Get 调用可能会返回实际数组或者实际数组的副本，取决于运行时的情况，代码复制数据（那么上面的代码可能是第 2 次复制），那么这种情况下，使用 JNI_ABORT 确保不会再出现第 3 次复制。 使用 Get&lt;type&gt;ArrayRegion 函数不仅可以完成相同操作，而且不必考虑 Release 调用： 12// 复制数组 len 长度的字节到缓冲区 buffer 中env-&gt;GetByteArrayRegion(array, 0, len, buffer); 区域调用优点： 只需要一个 JNI 调用，而不是两个，减少开销； 不需要固定实际数组或额外复制数据； 降低风险，不存在操作失败后忘记调用 Release 的风险。 除此之外，JNI 还提供了针对于字符串的区域调用函数，GetStringUTFRegion 或 GetStringRegion 将字符数据复制到 String 对象之外。 线程所有线程都是 Linux 线程，由内核调度。线程通常从受虚拟机管理的代码启动（使用 Thread#start() 方法），但也可以在 native 层创建，然后通过 JNI 函数附加到 JavaVM。在 C/C++ 代码中例如使用 pthread_create 启动本地线程，然后调用 JNI 提供的 AttachCurrentThread 或 AttachCurrentThreadAsDeamon 函数，在附加之前，这个线程不会包含任何 JNIEnv，所以无法调用 JNI（JNIEnv 指针不能在多个线程中共享，只能分别附加，主线程默认已被附加）。 被附加成功的本地线程会构建 java.lang.Thread 对象并被添加到 Main ThreadGroup，从而使调试程序能够看到它。在已附加的线程上调用 AttachCurrentThread 属于空操作。 通过 JNI 附加的线程在退出之前必须调用 DetachCurrentThread 分离附加。如果直接对此进行编写代码会很麻烦，可以使用 pthread_key_create 定义在线程退出之前调用的析构函数，之后再调用 DetachCurrentThread。（将该 key 与 pthread_setspecific 配合使用，以将 JNIEnv 存储在线程本地存储中；这样一来，该 key 将作为参数传递到线程的析构函数中。） 附加到本地线程下面是一个附加到线程的示例，使用 pthread_create 创建一个线程，并在线程执行代码中附加： 123// Java Code:NativeHandler.testThread(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// C++ Code:// 线程函数static void *threadTest(void *arg) { JNIEnv *env = nullptr; // 尝试获得已附加的 JNIEnv jint ret = gJavaVM-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6); switch (ret) { case JNI_OK: __android_log_print(ANDROID_LOG_DEBUG, TAG, \"获得了 JNIEnv.\"); break; case JNI_EDETACHED: ret = gJavaVM-&gt;AttachCurrentThread(&amp;env, nullptr); if (ret == JNI_OK) { __android_log_print(ANDROID_LOG_DEBUG, TAG, \"线程已附加. %ld\", (long) pthread_getspecific(gKey)); } else { __android_log_print(ANDROID_LOG_ERROR, TAG, \"线程附加失败，code: %d.\", ret); } break; case JNI_EVERSION: __android_log_print(ANDROID_LOG_DEBUG, TAG, \"错误 JNI_EVERSION.\"); break; default: __android_log_print(ANDROID_LOG_ERROR, TAG, \"未知错误：%d\", ret); break; } return nullptr;}// 线程销毁函数static void threadDestroy(void *arg) { JNIEnv *env = nullptr; jint ret = gJavaVM-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6); if (ret == JNI_OK) { __android_log_print(ANDROID_LOG_DEBUG, TAG, \"线程分离.\"); gJavaVM-&gt;DetachCurrentThread(); }}void testThread(JNIEnv *env, jclass clazz) { // 获取 JavaVM 指针 env-&gt;GetJavaVM(&amp;gJavaVM); // 创建线程本地存储，指定线程析构函数 pthread_key_create(&amp;gKey, &amp;threadDestroy); // 创建线程 pthread_t tid; int ret = pthread_create(&amp;tid, nullptr, &amp;threadTest, nullptr); if (ret != 0) { __android_log_print(ANDROID_LOG_DEBUG, TAG, \"thread [%ld] create err\", tid); return; } // 等待线程结束 pthread_join(tid, nullptr); // 移除线程本地存储 pthread_key_delete(gKey);} 上述代码，首先保存 JavaVM，然后启动线程，在线程中使用 GetEnv 函数尝试从线程获得 JNIEnv，返回值将有 3 种结果： JNI_OK，说明此线程已附加，可直接使用获得的 JNIEnv； JNI_EDETACHED，说明此线程未附加，那么需要使用 AttachCurrentThread 进行附加； JNI_EVERSION，说明不支持指定的版本。 在获得 JNIEnv 之后线程就执行完毕了，那么 pthread_create 中指定的线程析构函数 threadDestroy 将被回调，在这里确认线程已被附加后，使用 DetachCurrentThread 分离线程。 AttachCurrentThread 的第 2 个参数一般可以指定为空，它是一个 JavaVMAttachArgs 结构指针，用于指定格外信息。 1234567// jni.hstruct JavaVMAttachArgs { jint version; /* must be &gt;= JNI_VERSION_1_2 */ const char* name; /* NULL or name of thread as modified UTF-8 str */ jobject group; /* global ref of a ThreadGroup object, or NULL */}; JNI 异常当原生代码出现异常挂起时，大多数 JNI 函数无法被调用。通过 C/C++ 代码可以检查到是否出现了异常（通过 ExceptionCheck 或者 ExceptionOccurred 的返回值）；或者直接清除异常。 在异常挂起时，只能调用如下 JNI 函数： 123456789101112131415DeleteGlobalRefDeleteLocalRefDeleteWeakGlobalRefExceptionCheckExceptionClearExceptionDescribeExceptionOccurredMonitorExitPopLocalFramePushLocalFrameRelease&lt;PrimitiveType&gt;ArrayElementsReleasePrimitiveArrayCriticalReleaseStringCharsReleaseStringCriticalReleaseStringUTFChars 许多 JNI 调用都会抛出异常，但通常可以使用一种更简单的方法来检查失败调用，例如 NewString 函数返回非空，则表示不需要检查异常。如果使用 CallObjectMethod 函数，则始终必须检查异常，如果系统抛出异常，那么函数返回值无效。 检查异常使用 ExceptionCheck 函数可检查上一次代码调用是否出现了异常，如果出现异常，ExceptionCheck 将返回 JNI_TRUE，否则为 JNI_FALSE；或使用 ExceptionOccurred 函数，如果出现异常，它会返回一个 jthrowable 对象，否则为空。 通常使用 ExceptionCheck 函数，因为它不需要创建局部引用（jthrowable）。 在捕获到异常之后，使用 ExceptionDescribe 打印异常信息，如果调用 ExceptionClear 清除异常，那么异常将被忽略（不过在未处理的情况下盲目地忽略异常可能会出现问题）。 12345678910// 检查异常bool checkException(JNIEnv *env) { if (env-&gt;ExceptionCheck() == JNI_TRUE) { env-&gt;ExceptionDescribe(); env-&gt;ExceptionClear(); return true; } return false;} 抛出异常目前 Android 并不支持 C++ 异常。 JNI 提供了 Throw 和 ThrowNew 用来抛出 Java 异常，但不会在调用后就抛出异常，只是在当前线程中设置了异常指针。从本地代码返回到受虚拟机管理的代码后，会观察到这些异常指针并进行相应处理（抛出异常）。 JNI 没有提供直接操作 Java Throwable 对象本身的内置函数（直接创建对象或者获取异常信息）。 如果想要抛出指定异常，则需要自己找到 Throwable 类后，调用 ThrowNew 函数产生异常： 1234// 抛出 NullPointerExceptionenv-&gt;ThrowNew(env-&gt;FindClass(\"java/lang/NullPointerException\"), msg);// 抛出 RuntimeExceptionenv-&gt;ThrowNew(env-&gt;FindClass(env, \"java/lang/RuntimeException\"), msg); 如果需要获取异常信息，那么需要查找 Throwable#getMessage() 的方法 ID 并调用。 参考 https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html https://developer.android.google.cn/training/articles/perf-jni","link":"/2020/07/14/android-jni-%E6%8C%87%E5%8D%97/"},{"title":"Makefile 指南","text":"前言此文档内容是对于博客 跟我一起写Makefile 的归纳整理。 规范了文档格式，重构为参考手册的形式，不适合作为教程，适合作为参考。 Makefile 介绍编写原则 如果这个工程没有编译过，那么所有的 C 文件都需要编译并链接； 如果这个工程的某几个 C 文件被修改，那么只编译被修改的 C 文件，并连接目标程序； 如果这个工程的头文件被改变了，那么需要编译引用了这几个头文件的 C 文件，并连接目标程序。 Makefile 规则1234target ...: prerequisites ... command ... ... target 一个目标文件（Object File），或一个可执行文件，或一个标签（Label） prerequisites 生成该 target 所依赖的文件以或/和 target command 该 target 要执行的命令 Makefile 示例12345678910111213141516171819202122232425edit: main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.omain.o: main.c defs.h cc -c main.ckbd.o: kdb.c defs.h command.h cc -c command.ccommand.o: commnd.c defs.h command.h cc -c command.cdisplay.o: display.c defs.h buffer.h cc -c dislay.cinsert.o: insert.c defs.h buffer.h cc -c insert.cserch.o: search.c defs.h buffer.h cc -c search.cfiles.o: files.c defs.h buffer.h command.h cc -c files.cutils.o: utils.c defs.h cc -c utils.c clean: rm edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o Make 工作方式输入 make 命令后： Make 会在当前目录下寻找名字叫做“Makefile”或“makefile”的文件； 如果找到，继续找到文件中第一个 target（目标文件）； 如果 target 不存在，或者 target 后面依赖的“.o”文件的修改时间比 target 要新，那么，它会执行后面所定义的命令来生成 target 文件； 如果 target 依赖的“.o”文件也不存在，那么 Make 会在当前文件中寻找目标为“.o”文件的依赖性，如果找到则再根据哪个规则生成“.o”文件； 如果 C 文件和 H 文件存在，则 Make 会根据规则生成“.o”文件，从而生成最终的 target 文件。 Make 会层层递进的寻找依赖关系，直到编译出最终的 target，一旦依赖的文件不存在，那么 Make 就会报错。 clean 命令没有被 target 依赖，那么 Make 不会执行后面定义的命令，除非显式的执行： 1make clean Makefile 中的变量12345678910111213141516171819202122232425objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit: $(objects) cc -o $(objects)main.o: main.c defs.h cc -c main.ckbd.o: kdb.c defs.h command.h cc -c command.ccommand.o: commnd.c defs.h command.h cc -c command.cdisplay.o: display.c defs.h buffer.h cc -c dislay.cinsert.o: insert.c defs.h buffer.h cc -c insert.cserch.o: search.c defs.h buffer.h cc -c search.cfiles.o: files.c defs.h buffer.h command.h cc -c files.cutils.o: utils.c defs.h cc -c utils.cclean: rm edit $(objects) Makefile 自动推导Make 可以自动推导文件以及文件依赖后面的命令. 123456789101112131415161718objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit: $(objects) cc -o edit $(objects)main.o: defs.hkbd.o: defs.h command.hcommand.o: defs.h command.hdisplay.o: defs.h buffer.hinsert.o: defs.h buffer.hsearch.o: defs.h buffer.hfiles.o: defs.h buffer.h command.hutils.o: defs.h.PHONY: cleanclean: rm edit $(objects) .PHONY 表示 clean 是一个伪目标文件。 另类风格的 Makefile12345678910111213objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit: $(objects) cc -o edit $(objects) $(objects): defs.h kbd.o command.o files.o: command.h display.o insert.o seatch.o files.o: buffer.h.PHONY: cleanclean: rm edit $(objects) clean 规则12clean: rm edit $(objects) 123.PHONY: cleanclean: -rm edit $(objects) “-”表示也许某些文件会出现问题，忽略继续做后面的事 Makefile 里有什么？ 显式规则，它说明了如何生成一个或者多个目标文件。这是由 Makefile 的书写者明显指出要生成的文件、文件的依赖文件和生成的命令； 隐晦规则，由于 Make 有自动推导功能，所以隐晦规则支持简写 Makefile； 变量定义，在 Makefile 中我们要定义一些列的变量，一般都是字符串，类似 C 语言中的宏； 文件指示，包括 3 部分：在一个 Makefile 中引用另一个 Makefile，类似 C 语言中的“include”；另一个是根据某些情况指定 Makefile 的有效部分，类似 C 语言中的预编译“#if”；最后就是定义一个多行命令； 注释，Makefile 中只有行注释，使用“#”字符进行注释。 Makefile 中命令必须以 [Tab] 开始。 Makfefile 文件名默认情况下，Make 会在当前目录按顺序寻找名为“GNUmakefile”、“makefile”、“Makefile”的文件。 最好使用“Makefile”，更醒目，通用性更强。 可指定 Makefile 文件名： 12make -f Make.mymake -file Make.abc 引用其他的 Makfile使用 include 关键字包含别的 Makefile，类似 C 语言中的 #include，被包含的文件内容会被扩展到当前包含的位置。 1include &lt;filename&gt; 1include foo.make *.mk $(bar) Make 首先寻找 include 指出其他 Makefile，并将它们的内容扩展到当前位置。 Make 首先在当前目录寻找文件，找不到时，Make 还会在如下目录寻找： 如果 Make 执行时，被指定了 -I 或 --include-dir 参数，那么 Make 就会在此参数指定的目录下寻找； 如果目录 &lt;prefix&gt;/include（一般为 /usr/local/bin 或 /usr/include）存在，Make 也会在里面寻找。 1-include &lt;filename&gt; “-”表示，无论 include 过程中出现什么错误，都不要报错，继续执行。 其他版本中有类似的 sinclude 兼容命令。 环境变量 MAKEFILES如果当前环境中定义了 MAKFEFILES 变量，那么 Make 会把它当作类似 include 的动作。 此变量中的值为其他 Makefile 的定义，使用空格隔开。 Make 工作方式 读入所有 Makefile； 读入被 include 的其他 Makefile； 初始化文件中的变量； 推导隐晦规则，并分析所有规则； 为所有的目标文件创建依赖关系链； 根据依赖关系，决定那些目标要重新生成； 执行生成命令。 书写规则规则包含两部分，一个是依赖关系，一个是生成目标的方法。 12foo.o: foo.c defs.h cc -c -g foo.c 规则语法123targets: prerequisites command ... 123targets: prerequisites; command command ... targets 是文件名，以空格分开，可以使用通配符。 command 是命令行，如果不与前面的内容在一行，那么必须以 [Tab] 键开头，如果在一行，可以以分号作为分隔。 prerequisites 也就是目标所依赖的文件。如果其中的某个文件比目标文件新，那么目标文件被认为是“过时的”，需要被重新生成。 如果命令太长，可以使用 \\ 作为换行符。 一般，Make 会以 UNIX 的标准 Shell，也就是 /bin/sh 来执行。 规则中使用通配符Make 支持 3 个通配符，*、? 和 ~。 ~ 表示当前用户的 $HOME 目录。 1objects: $(wildcard *.o) 文件搜寻VAPTH 可指明 Make 在当前目录找不到的情况下，去指定的目录中去寻找文件，多个路径使用 : 分隔。 1VPATH = src:.../headers 或使用 Make 中的 vpath 关键字。 12345678vpath &lt;pattern&gt; &lt;directories&gt;为符合模式 &lt;pattern&gt; 的文件指定搜索目录 &lt;directories&gt;。vapth &lt;pattern&gt;清除符合模式 &lt;pattern&gt; 文件的搜索目录。vpath清除所有以被设置好了的文件搜索目录。 vpath 中的 &lt;pattern&gt; 需要包含 % 字符，% 的意思是匹配零或若干字符。 12vpath %.h ../headers# 表示在 ../headers 目录下搜索所有以 .h 结尾的文件 多行 vpath 关键字，Make 将会按顺序执行搜索。 123vpath %.c foo:barvpath % blish# 表示先在 foo 目录，然后 bar 目录，最后是 blish 目录搜寻 .c 的结尾文件 伪目标伪目标并不是一个文件，只是一个标签。 避免和文件重名，使用 .PHONY 标记显式指定一个“伪目标”。 当伪目标放在第一行时，可作为“默认目标”，利用它实现同时编译出多个可执行文件。 1234567891011all: prog1 prog2 prog3.PHONY: allprog1: prog1.o utils.o cc -o prog1 prog1.o utils.oprog2: prog2.o cc -o prog2 prog2.oprog3: prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o 伪目标也可以成为依赖： 12345678910.PHONY: cleanall cleanobj cleandiffcleanall: cleanobj cleandiff rm programcleanobj: rm *.ocleandiff: rm *.diff 多目标Makefile 支持多个目标，有时多个目标会依赖于同一个文件，并且生成命令类似，可以将其合并起来。 自动化变量 $@ 表示目前规则中所有目标的集合。 12bigoutput littleoutput: text.g generate text.g -$(subst output,,$@) &gt; $@ 等价于 1234bigoutout: text.g gererate text.g -big &gt; bigoutputlittleoutput: text.g generate text.g -little &gt; littleoutput 静态模式静态模式可以更容易的定义多目标的规则，使得规则更加灵活。 123&lt;target ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt; &lt;commands&gt; ... targets 定义了一系列的目标文件，可以有通配符，是目标的集合。 target-pattern 指明了 targets 的模式，也就是目标集模式。 prereq-patterns 是目标的依赖模式，对 target-pattern 再进行一次依赖目标的定义。 123456objects = foo.o bar.oall: $(objects)$(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 上面指明了目标从 $object 中获取，%.o 表明所有以 .o 结尾的目标，后面的 %.c 取模式 %.o 的 % 部分，也就是 foo bar，并添加上 .c 的后缀，表示依赖的目标是 foo.c bar.c。 展开上述规则： 1234foo.o: foo.c $(CC) -c $(CFLAGS) foo.c -o foo.obar.o: bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o 自动生成依赖性使用编译器命令自动生成依赖关系： 1cc -M main.c 会生成： 1main.o: main.c defs.h GNU 建议把每一个源文件的依赖关系保存到一个对应的 .d 文件中。 可以让 Make 自动生成 .d 文件，并包含在 Makefile 中。 12345%.d: %.c @set -e; rm -f $@; \\ $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \\ sed 's,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \\ rm -f $@.$$$$ 意思是，所有的 .d 文件依赖于 .c 文件， rm -f $@ 意思是删除所有的目标，也就是 .d 文件，第二行意思是，为每个依赖文件 $&lt; ，也就是 .c 文件生成依赖文件， $@ 表示模式 %.d 文件，如果有一个 C 文件是 a.c，那么 % 就是 a ， $$$$ 表示一个随机编号，第二行生成的文件可能是“name.d.12345”，第三行使用 sed 命令做了替换。 从而在编译器生成的依赖关系中加入了 .d 文件依赖。即： 1main.o: main.c defs.h 变成了 1main.o main.d: main.c defs.h 书写命令显示命令通常 Make 会把执行的命令在命令执行前打印出来，使用 @ 字符可以不让 Make 显示命令。 1@echo 正在编译 xxx 模块…… Make 执行时，只会显示出 正在编译 xxx 模块……，如果没有 @，那么显示： 12@echo 正在编译 xxx 模块……正在编译 xxx 模块…… 使用 Make 带上 -n 或 --just-print 参数，那么只显示命令，不执行命令。 -s 和 --silent 或 --quiet 是全面禁止命令的显式。 命令执行如果需要在前一个命令执行的基础上执行下一个命令，需要放在一行，以 ; 隔开： 不能分两行执行。 12exec: cd /home/l0neman/; pwd 嵌套执行 Make大工程中，可能会把不同模块或者不同功能的源文件放在不同目录中，每一个目录中可以写一个 Makefile，有利于让 Makefile 变得更简洁，而不是全部都写在一个 Makefile 中。 12subsystem: cd subdir &amp;&amp; $(MAKE) 等价于： 12subsystem: $(MAKE) -C subdir $(MAKE) 是默认变量表示 Make 本身，使我们可以使用 Make 携带参数，上面两个 Makefile 都表示进入 subdir，然后执行 make 命令。 此 Makefile 被称为总控 Makefile，它可以将一些参数带入下一级 Makefile。 如果要传递变量到下一级，使用 export，如果不想，那么使用 unexport。 1export &lt;varible ...&gt;; 1unexport &lt;varible ...&gt;; 如： 12345678export variable = value# 或variable = valueexport variable# 或export variable := value# 或export variable += value 当单独使用 export 占一行时，那么表示传递所有变量。 两个特殊变量一定会传递，SHELL 和 MAKEFLAGS。 -w 或是 --print-directory 会在 Make 的过程中输出目前的工作目录信息： 12make: Entering directory `/home/l0neman/hello'.make: Leaving directory `/home/l0neman/hello' 定义命令包使用 define 开始，endef 结束，可以将一组命令定义为一个变量，成为命令包。 1234define run-yaccyacc $(firstword $^)mv y.tab.c $@endef 12foo.c: foo.y $(run-yacc) 使用变量变量基础使用变量，需要在变量名前加上 $ 符号，最好使用 () 和 {} 被变量括起来，使用真实 $ 变量，需要用 $$ 表示。 12345objects = program.o foo.o utils.oprogram : $(objects) cc -o program $(objects)$(objects) : defs.h 变量和 C 语言的宏一样，会在使用它的位置展开。 123foo = cprog.o: prog.$(foo) $(foo)$(foo) -$(foo) prog.$(foo) 得到： 12prog.o: prog.c cc -c prog.c 变量的变量使用 = 来将变量值赋值给另一个变量 123456foo = $(bar)bar = $(ugh)ugh = Huh?all: echo $(foo) 好处是可以把变量移动到后面定义： 12CFLAGS = $(include_dirs) -Oinclude_dirs = -Ifoo -Ibar 但可能会出现递归定义，Make 会检测到这种定义，从而报错。 1234CFLAGS = $(CFLAGS) -oA = $(B)B = $(A) 可以使用 := 来避免这种情况，:= 不允许使用后面定义的变量。 123x := fooy := $(x) barx := later 一个复杂的变量例子： 123456ifeq (0,${MAKELEVEL})cur-dir := $(shell pwd)whoami := $(shell whoami)host-type := $(shell arch)MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}endif 定义一个空格变量： 12nullstring :=space := $(nullstring) # end of the line nullstring 为一个 Empty 变量，表示什么都没有，那么 space 表示一个空格（在 # 号前面）。 注意，# 号符号前面的空格将会包含在变量中： 12dir := /foo/bar # directory to put the frobs in# 上面路径后面还包含了 4 个空格。 使用 ?=，表示如果变量没有被定义过，那么变量的值就是右边的，否则什么也不做。 1FOO ?= bar 等价于： 123ifeq ($(origin FOO), undefined) FOO = barendif 变量高级用法可以替换变量中共有的部分，格式是 $(var:a=b 或 $(var:a=b)，表示把变量 foo 中所有以 a 字符串结尾的 a 部分替换成 b。 12foo := a.o b.o c.obar := $(foo:.o=.c) 或“静态模式” 12foo := a.o b.o c.obar := $(foo:%.o=%.c) 变量再次当作变量 1234x = yy = za := $($(x))# 那么 a = z 12345x = $(y)y = zz = Helloa := $($(x))# 那么 a = Hello 12345first_second = Helloa = firstb = secondall = $($a_$b)# 那么 all = $(first_second) = Hello 1234a_objects := a.o b.o c.o1_objects := 1.o 2.o 3.osources := $($(a1)_objects:.o=.c) 123456789ifdef do_sort func := sortelse func := stripendifbar := a d b g q cfoo := $($(func) $(bar)) 12345dir = foo$(dir)_sources := $(wildcard $(dir)/*.c)define $(dir)_printlpr $($(dir)_sources)endef 追加变量值使用 += 给变量追加值。 12objects = main.o foo.o bar.o utils.oobjects += another.o 可以解释为： 12objects = main.o foo.o bar.o utils.oobjects := $(objects) another.o 如果变量之前没有定义过，那么 += 会自动变成 =。+= 会继承上次操作的赋值符。如果前一次的是 := ，那么 += 会以 := 作为其赋值符，那么 += 会以 := 作为其赋值符。 override 指示符如果有变量是通过 Make 的命令行设置的，那么 Makefile 对这个变量的赋值将会被忽略。 如果想要设置这类参数，可使用 override 指示符。 123override &lt;variable&gt;; = &lt;value&gt;;override &lt;variable&gt;; := &lt;value&gt;; 在 define 前使用 override 进行多行形式的变量定义： 123override define foobarendef 多行变量使用 define 关键字可以设置带有换行的变量值。 define 指示符后面跟的变量的名字，而重起一行定义变量的值，定义是以 endef 关键字结束。 1234define two-linesecho fooech $(bar)endef 环境变量Make 运行时的系统环境变量在 Make 开始执行时被载入到 Makefile 文件中，如果 Makefile 中已经定义了这个变量，或者变量由 make 命令带入，那么系统的环境变量的值将被覆盖。 如果系统中定义了 CFLAGS 环境变量，那么就可以在所有的 Makefile 中使用这个变量了。 目标变量可以为某个目标设置局部变量，被称为 Target-specific Variable，它可以和全局变量同名，由于它的作用域值在这条规则以及连带规则中，所以其值只在作用范围内有效，不会影响规则链以外的全局变量的值。 123&lt;target ...&gt;: &lt;variable-assignment&gt;&lt;target ...&gt;: overide &lt;variable-asignment&gt; 指的是各类赋值表达式，如 =、:=、+= 或 ?=。 第二行针对 make 命令带入的变量，或是系统环境变量。 123456789101112prog : CFLAGS = -gprog : prog.o foo.o bar.o $(CC) $(CFLAGS) prog.o foo.o bar.oprog.o : prog.c $(CC) $(CFLAGS) prog.cfoo.o : foo.c $(CC) $(CFLAGS) foo.cbar.o : bar.c $(CC) $(CFLAGS) bar.c 上面的示例，不管全局的 $(CFLAGS) 的值是什么，在目标 prog 中，以及其所引发的所有规则中（prog.o foo.o bar.o 的规则）， $(CFLAGS) 的值都是 -g。 模式变量GNU 的 Make 还支持模式变量（Pattern-specific Variable），可以给定一种模式，把变量定义在符合这种模式的所有目标上。 模式（pattern）至少含有一个 %，定义如下，给所有以 .o 结尾的目标定义目标变量。 1%.o: FLAGS = -o 模式变量的语法和目标变量一样： 123&lt;pattern ...&gt;; : &lt;variable-assignment&gt;&lt;pattern ...&gt;; : override &lt;variable-assignment&gt; 使用条件判断示例条件判断，可以让 Make 根据运行时的不同情况选择不同分支。 123456789libs_for_gcc = -lgnunormal_libs =foo: $(objects)ifeq ($(CC),gcc) $(CC) -o foo $(objects) $(libs_for_gcc)else $(CC) -o foo $(objects) $(normal_libs)endif 上面的示例，目标 foo 根据变量 $(CC) 的值来选取不同的函数库编译程序。 上面也可写成如下： 1234567891011libs_for_gcc = -lgnunormal_libs =ifeq ($(CC),gcc) libs=$(libs_for_gcc)else libs=$(normal_libs)endiffoo: $(objects) $(CC) -o foo $(objects) $(libs) 语法123&lt;conditional-directive&gt;&lt;text-if-true&gt;endif 12345&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif 表示条件关键字。 ifeq 比较两个参数的值是否相同，参数中还可以使用 Make 支持的函数。 12345ifeq (&lt;arg1&gt;, &lt;arg2&gt;)ifeq '&lt;arg1&gt;' '&lt;arg2&gt;'ifeq \"&lt;arg1&gt;\" \"&lt;arg2&gt;\"ifeq \"&lt;arg1&gt;\" '&lt;arg2&gt;'ifeq '&lt;arg1&gt;' \"&lt;arg2&gt;\" 包含函数： 123ifeq ($(strip $(foo)),)&lt;text-if-empty&gt;endif 上面表示如果函数的返回值是空（Empty），那么 生效。 ifneq 比较两个参数是否不相同。 12345ifneq (&lt;arg1&gt;, &lt;arg2&gt;)ifneq '&lt;arg1&gt;' '&lt;arg2&gt;'ifneq \"&lt;arg1&gt;\" \"&lt;arg2&gt;\"ifneq \"&lt;arg1&gt;\" '&lt;arg2&gt;'ifneq '&lt;arg1&gt;' \"&lt;arg2&gt;\" ifdef 判断变量的值不为空，则通过。 1ifdef &lt;vaiable-name&gt; 它不会扩展变量值到当前位置，只会判断是否有值。 ifndef 与 ifdef 相反。 1ifndef &lt;variable-name&gt; 在 这行，允许后面存在多余的空格，但是不能以 [Tab] 键作为开始。那么注释符 # 是安全的。 Make 在读取 Makefile 时就计算条件表达式的值，所以避免将自动化变量如 $@ 放入条件表达式，因为它们是运行时才有的。 Make 不允许把整个条件语句分成两部分放在不同的文件中。 使用函数Makefile 中可以使用函数来处理变量。 函数的调用语法1$(&lt;function&gt; &lt;arguments&gt;) 或： 1${&lt;function&gt; &lt;arguments&gt;} 是函数名， 为函数参数，多个参数使用 , 分隔。 12345comma:= ,empty:=space:= $(empty) $(empty)foo:= a b cbar:= $(subst $(space),$(comma),$(foo)) 上面使用了字符串替换函数 subst，将 $(foo) 中的空格替换成了 , 结果是 $(bar)=a,b,c 字符串处理函数 subst 123456$(subst, &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)# 名称：字符串替换函数# 功能：把字符串 &lt;text&gt; 中的 &lt;from&gt; 字符串替换成 &lt;to&gt;# 结果：返回被替换过后的字符串# 示例：fEEt on the strEEt = $(subst ee,EE,feet on the street) patsubst 1234567$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)# 名称：模式字符串替换函数# 功能：查找 &lt;text&gt; 中的单词（单词以“空格”、“Tab”或“回车”、“换行”分隔）是否符合模式 &lt;pattern&gt; ，如果匹配的话，则以 &lt;replacement&gt; 替换。这里， &lt;pattern&gt; 可以包括通配符 % ，表示任意长度的字串。如果 &lt;replacement&gt; 中也包含 % ，那么， &lt;replacement&gt; 中的这个 % 将是 &lt;pattern&gt; 中的那个 % 所代表的字串。（可以用 \\ 来转义，以 \\% 来表示真实含义的 % 字符）# 结果：返回被替换过后的字符串# 示例：x.c.o bar.o = $(patsubst %.c,%.o,x.c.c bar.c)# 备注：$(var:&lt;pattern&gt;=&lt;replacement&gt;;) 相当于 $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))，而 $(var: &lt;suffix&gt;=&lt;replacement&gt;) 则相当于 $(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var)) strip 123456$(strip &lt;string&gt;)# 名称：去除空格函数# 功能：去除 &lt;string&gt; 字符串中开头和结尾的空字符# 结果：返回被去掉空格的字符串# 示例：a b c = $(strip a b c ) findstring 12345678$(findstring &lt;find&gt;,&lt;in&gt;)# 名称：查找字符串函数# 功能：在字串 &lt;in&gt; 中查找 &lt;find&gt; 字串# 结果：如果找到，那么返回 &lt;find&gt; ，否则返回空字符串# 示例： a = $(findstring a,a b c) = $(findstring a,b c) filter 12345678910$(filter &lt;pattern...&gt;,&lt;text&gt;)# 名称：过滤函数# 功能：以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，保留符合模式 &lt;pattern&gt; 的单词，可以有多个模式# 结果：返回符合模式 &lt;pattern&gt; 的字串# 示例： sources := foo.c bar.c baz.s ugh.h foo: $(sources) cc $(filter %.c %.s,$(sources)) -o foo # 返回值：foo.c bar.c baz.s filter-out 123456789$(filter-out &lt;pattern...&gt;,&lt;text&gt;)# 名称：反过滤函数# 功能：以 &lt;pattern&gt; 模式过滤 &lt;text&gt; 字符串中的单词，去除符合模式 &lt;pattern&gt; 的单词，可以有多个模式# 结果：返回不符合模式 &lt;pattern&gt; 的字串# 示例： objects = main1.o foo.o main2.o bar.o mains = main1.o main2.o # 返回值：foo.o bar.o sort 1234567$(sort &lt;list&gt;)# 名称：排序函数# 功能：给字符串 &lt;list&gt; 中的单词排序（升序）# 结果：返回排序后的字符串# 示例：bar foo lose = $(sort foo bar lose)# 备注：sort 函数会去掉 &lt;list&gt; 中相同的单词 word 123456$(word &lt;n&gt;,&lt;text&gt;)# 名称：取单词函数# 功能：取字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。（从一开始）# 结果：返回字符串 &lt;text&gt; 中第 &lt;n&gt; 个单词。如果 &lt;n&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串# 示例：bar = $(word 2, foo bar baz) wordlist 123456$(wordlist &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)# 名称：取单词串函数# 功能：从字符串 &lt;text&gt; 中取从 &lt;ss&gt; 开始到 &lt;e&gt; 的单词串。 &lt;ss&gt; 和 &lt;e&gt; 是一个数字# 结果：返回字符串 &lt;text&gt; 中从 &lt;ss&gt; 到 &lt;e&gt; 的单词字串。如果 &lt;ss&gt; 比 &lt;text&gt; 中的单词数要大，那么返回空字符串。如果 &lt;e&gt; 大于 &lt;text&gt; 的单词数，那么返回从 &lt;ss&gt; 开始，到 &lt;text&gt; 结束的单词串# 示例：bar baz = $(wordlist 2, 3, foo bar baz) words 1234567$(words &lt;text&gt;)# 名称：单词个数统计函数# 功能：统计 &lt;text&gt; 中字符串中的单词个数# 结果：返回 &lt;text&gt; 中的单词数# 示例：3 = $(words, foo bar baz)# 备注：如果要取 &lt;text&gt; 中最后的一个单词，可以这样：$(word $(words &lt;text&gt;),&lt;text&gt;) firstword 1234567$(firstword &lt;text&gt;)# 名称：首单词函数# 功能：取字符串 &lt;text&gt; 中的第一个单词# 结果：返回字符串 &lt;text&gt; 的第一个单词# 示例：foo = $(firstword foo bar)# 备注：可以用 word 函数来实现：$(word 1,&lt;text&gt;) 字符串函数实例： 利用搜索路径 VPATH 来指定编译器对头文件的搜索路径参数 CFLAGS 12override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))# $(VPATH) 值是 src:../headers ，那么 $(patsubst %,-I%,$(subst :, ,$(VPATH))) 将返回 -Isrc -I../headers 文件名操作函数每个函数的参数字符串都会被当做一个或是一系列的文件名来对待 dir 123456$(dir &lt;names...&gt;)# 名称：取目录函数# 功能：文件名序列 &lt;names&gt; 中取出目录部分。目录部分是指最后一个反斜杠（ / ）之前的部分。如果没有反斜杠，那么返回 ./# 结果：返回文件名序列 &lt;names&gt; 的目录部分# 示例：src/ ./ = $(dir src/foo.c hacks) notdir 123456$(notdir &lt;names...&gt;)# 名称：取文件函数# 功能：从文件名序列 &lt;names&gt; 中取出非目录部分。非目录部分是指最後一个反斜杠（ / ）之后的部分# 结果：返回文件名序列 &lt;names&gt; 的非目录部分# 示例：foo.c hacks = $(notdir src/foo.c hacks) suffix 123456$(suffix &lt;names...&gt;)# 名称：取后缀函数# 功能：从文件名序列 &lt;names&gt; 中取出各个文件名的后缀# 结果：返回文件名序列 &lt;names&gt; 的后缀序列，如果文件没有后缀，则返回空字串# 示例：.c .c = $(suffix src/foo.c src-1.0/bar.c hacks) basename 123456$(basename &lt;names...&gt;)# 名称：取前缀函数# 功能：从文件名序列 &lt;names&gt; 中取出各个文件名的前缀部分# 结果：返回文件名序列 &lt;names&gt; 的前缀序列，如果文件没有前缀，则返回空字串# 示例：src/foo src-1.0/bar hacks = $(basename src/foo.c src-1.0/bar.c hacks) addsuffix 123456$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)# 名称：加后缀函数# 功能：把后缀 &lt;suffix&gt; 加到 &lt;names&gt; 中的每个单词后面# 结果：返回加过后缀的文件名序列# 示例：foo.c bar.c = $(addsuffix .c,foo bar) addprefix 123456$(addprefix &lt;prefix&gt;,&lt;names...&gt;)# 名称：加前缀函数# 功能：把前缀 &lt;prefix&gt; 加到 &lt;names&gt; 中的每个单词后面# 结果：返回加过前缀的文件名序列# 示例：src/foo src/bar = $(addprefix src/,foo bar) join 123456$(join &lt;list1&gt;,&lt;list2&gt;)# 名称：连接函数# 功能：把 &lt;list2&gt; 中的单词对应地加到 &lt;list1&gt; 的单词后面。如果 &lt;list1&gt; 的单词个数要比 &lt;list2&gt; 的多，那么， &lt;list1&gt; 中的多出来的单词将保持原样。如果 &lt;list2&gt; 的单词个数要比 &lt;list1&gt; 多，那么， &lt;list2&gt; 多出来的单词将被复制到 &lt;list1&gt; 中# 结果：返回连接过后的字符串# 示例：aaa111 bbb222 333 = $(join aaa bbb , 111 222 333) foreach 函数1$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;) ，把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中，然后再执行 &lt;text&gt; 所包含的表达式。每一次 &lt;text&gt; 会返回一个字符串，循环过程中， &lt;text&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， &lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值 实例： 12names := a b c dfiles := $(foreach n,$(names),$(n).o) $(name) 中的单词会被挨个取出，并存到变量 n 中，$(n).o 每次根据 $(n) 计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，那么，$(files) 的值是 a.o b.o c.o d.o if 函数123$(if &lt;condition&gt;,&lt;then-part&gt;)# 或$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;) if 函数可以包含“else”部分，或是不含。即 if 函数的参数可以是两个，也可以是三个。 &lt;condition&gt; 参数是 if 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，&lt;then-part&gt; 会被计算，否则 &lt;else-part&gt; 会被计算。 if 函数的返回值：如果 &lt;condition&gt; 为真（非空字符串），那个 &lt;then-part&gt; 会是整个函数的返回值，如果 &lt;condition&gt; 为假（空字符串），那么 &lt;else-part&gt; 会是整个函数的返回值，此时如果 &lt;else-part&gt; 没有被定义，那么，整个函数返回空字串。 所以，&lt;then-part&gt; 和 &lt;else-part&gt; 只会有一个被计算 call 函数唯一一个可以用来创建新的参数化的函数，可以写一个非常复杂的表达式，这个表达式中，可以定义许多参数，然后可以用 call 函数来向这个表达式传递参数。 1$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;) 当 Make 执行这个函数时，&lt;expression&gt; 参数中的变量，如 $(1) 、$(2) 等，会被参数 &lt;parm1&gt; 、&lt;parm2&gt; 、&lt;parm3&gt; 依次取代。而 &lt;expression&gt; 的返回值就是 call 函数的返回值。 示例： 12reverse = $(1) $(2)foo = $(call reverse,a,b) foo 的值就是 a b ，参数的次序可以是自定义的，不一定是顺序的。 12reverse = $(2) $(1)foo = $(call reverse,a,b) 此时的 foo 的值就是 b a 备注：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第 2 个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向 call 函数提供参数时，最安全的做法是去除所有多余的空格。 origin 函数它并不操作变量的值，它告诉你这个变量的来源。 1$(origin &lt;variable&gt;) 是变量的名字，不应该是引用（使用 $ 符号） 返回值： 1234567undefined -&gt; 如果 &lt;variable&gt; 从来没有定义过default -&gt; 如果 &lt;variable&gt; 是一个默认的定义，比如“CC”这个变量environment -&gt; 如果 &lt;variable&gt; 是一个环境变量，并且当 Makefile 被执行时，-e 参数没有被打开file -&gt; 如果 &lt;variable&gt; 这个变量被定义在 Makefile 中command line -&gt; 如果 &lt;variable&gt; 这个变量是被命令行定义的override -&gt; 如果 &lt;variable&gt; 是被 override 指示符重新定义的automatic -&gt; 如果 &lt;variable&gt; 是一个命令运行中的自动化变量 用法实例： 有一个 Makefile 包含了一个定义文件 Make.def，在 Make.def 中定义了一个变量“bletch”，而此时环境中也有一个环境变量“bletch”，此时，判断如果变量来源于环境，那么就把之重定义，如果来源于 Make.def 或是命令行等非环境的，那么就不重新定义它。 12345ifdef bletch ifeq \"$(origin bletch)\" \"environment\" bletch = barf, gag, etc. endifendif shell 函数它的参数就是操作系统 Shell 的命令，shell 函数把执行操作系统命令后的输出作为函数返回。 示例： 12contents := $(shell cat foo)files := $(shell echo *.c) 备注：这个函数会新生成一个 Shell 程序来执行命令，所以你要注意其运行性能。 控制 Make 的函数12345$(error &lt;text ...&gt;)# 产生一个致命的错误，&lt;text ...&gt; 是错误信息$(warning &lt;text ...&gt;)# 输出一段警告信息 可以将函数提前保存到变量，在合适的时候使用： 123ifdef ERROR_001 $(error error is $(ERROR_001))endif Make 的运行Make 的退出码make 命令执行后有三个退出码： 0 表示成功执行 1 Make 运行时出现任何错误 2 如果使用了 Make 的 -q 选项，并且 Make 使得一些目标不需要更新 指定 Makefile可以使用 -f 或 -makefile 给 Make 指定特殊名字的 Makefile 文件。 1make -f hello.mk 指定目标在 make 命令后面跟目标名字即可指定目标。 1make clean make 的环境变量 MAKECMDGOALS 会存放命令指定的目标的列表，如果命令行没有指定，则是空值。 可以将它用于特殊情况： 1234sources = foo.c bar.cifneq ( $(MAKECMDGOALS),clean) include $(sources:.c=.d)endif 如果没有执行 make clean，那么会包含 foo.d 和 bar.d 这两个 Makefile 12.PHONY: allall: prog1 prog2 prog3 prog4 可 make all 编译所有目标，也可以 make prog1 单独编译目标。 GNU Makefile 目标编写规范： 伪目标 含义 all 编译所有的文件 clean 删除所有被 make 创建的文件 install 安装已编译好的程序，就是把目标文件复制到指定的目标 print 列出改变过的源文件 tar 把源程序打包备份成一个 tar 文件 dist 创建一个压缩文件，一般先把 tar 文件压缩成 Z 文件，或者 gz 文件 TAGS 更新所有的目标，以准备完整地编译使用 check/test 一般用来测试 Makefile 的流程 检查规则检查命令，或执行序列，不执行 Makefile 中的规则，指定使用如下参数： 1-n, --just-print, --dry-run, --recon 不执行，只打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，这些参数对于调试 Makefile 很有用处。 1-t, --touch 把目标文件的时间更新，但不更改目标文件。就是说，Make 假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。 1-q, --question 寻找目标的意思，如果目标存在，那么什么也不输出，也不会执行编译，如果目标不存在，打印出一条出错信息。 1-W &lt;file&gt;, --what-if=&lt;file&gt;, --assume-new=&lt;file&gt;, --new-file=&lt;file&gt; 指定一个文件。一般是是源文件（或依赖文件），Make 会根据规则推导来运行依赖于这个文件的命令，一般可以和“-n”参数同时使用，用来查看这个依赖文件发生的规则命令。 结合 -p 和 -v 来输出 Makefile 被执行时的信息。 Make 参数GNU Make 3.80 的所有参数。 参数 含义 -b, -m 作用是忽略和其它版本 Make 的兼容性 -B, –always-make 认为所有的目标都需要更新（重编译） -C , –directory= 指定读取 Makefile 的目录。如果有多个 -C 参数，Make 的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：make -C ~hchen/test -C prog 等价于 make -C ~hchen/test/prog -debug[=] 输出 Make 的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是的取值：1. a：all，输出所有的调试信息；2. b：basic，只输出简单的调试信息。即输出不需要重编译的目标；3. v：verbose，在 b 选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等；4. i：implicit，输出所以的隐含规则；5. j：jobs，输出执行规则中命令的详细信息，如命令的 PID、返回码等；6. m：Makefile，输出 Make 读取 Makefile，更新 Makefile，执行 Makefile 的信息。 -d 相当于 –debug=a -e, –environment-overrides 指明环境变量的值覆盖 Makefile 中定义的变量的值 -f=, –file=, –makefile= 指定需要执行的 Makefile -h, –help 显示帮助信息 -i , –ignore-errors 执行时忽略所有的错误 -I , –include-dir= 定一个被包含 Makefile 的搜索目标。可以使用多个 -I 参数来指定多个目录 -j [], –jobs[=] 指同时运行命令的个数。如果不指定此参数，Make 运行命令时能运行多少就运行多少。如果有一个以上的 -j 参数，那么仅最后一个 -j 才是有效的。（这个参数在 MS-DOS 中是无用的） -k, –keep-going 出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行 -l , –load-average[=], -max-load[=] 指定 Make 运行命令的负载 -n, –just-print, –dry-run, –recon 仅输出执行过程中的命令序列，但并不执行 -o , –old-file=, –assume-old= 不重新生成的指定的 &lt;file&gt;，即使这个目标的依赖文件新于它 -p, –print-data-base 输出 Makefile 中的所有数据，包括所有的规则和变量。这会让一个简单的 Makefile 都输出一堆信息。如果只是想输出信息而不想执行 Makefile，可以使用 make -qp 命令。如果想查看执行 Makefile 前的预设变量和规则，你可以使用 make –p –f /dev/null。这个参数输出的信息会包含着你的 Makefile 文件的文件名和行号，所以，用来调试 Makefile 会很有用，特别是当环境变量很复杂时 -q, –question 不运行命令，也不输出。仅检查所指定的目标是否需要更新。如果是 0 说明要更新，如果是 2 说明有错误发生 -r, –no-builtin-rules 禁止 Make 使用任何隐含规则 -R, –no-builtin-variabes 禁止 Make 使用任何作用于变量上的隐含规则 -s, –silent, –quiet 在命令运行时不输出命令的输出 -S, –no-keep-going, –stop 取消 -k 选项的作用。因为有些时候，Make 的选项是从环境变量 MAKEFLAGS 中继承下来的。所以可以在命令行中使用这个参数让环境变量中的 -k 选项失效 -t, –touch 相当于 UNIX 的 touch 命令，只是把目标的修改日期变成最新的，就是阻止生成目标的命令运行 -v, –version 输出 Make 程序的版本、版权等关于 Make 的信息 -w, –print-directory 输出运行 Makefile 之前和之后的信息。这对于跟踪嵌套式调用 Make 时很有用 –no-print-directory 禁止 -w 选项 -W , –what-if=, –new-file=, –assume-file= 假定目标 &lt;file&gt; 需要更新，如果和 -n 选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有 -n 那么就像运行 UNIX 的 touch 命令一样，使 &lt;file&gt; 的修改时间为当前时间 –warn-undefined-variables 只要 Make 发现有未定义的变量，那么输出警告信息 隐含规则Makefile 中包含了一些隐含规则，是一种默认约定，例如将 .c 文件自动编译为 .o 文件。 12foo : foo.o bar.o cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS) 可以省略如下使用 cc 编译器生成 .o 的规则。 1234foo.o : foo.c cc –c foo.c $(CFLAGS)bar.o : bar.c cc –c bar.c $(CFLAGS) 隐含规则列表make 命令的参数 -r 或 --no-builtin-rules 选项可取消所有的预置的隐含规则。 一个特殊的隐含规则，不能通过 -r 选项关闭。就是后缀规则，文件名中包含如下后缀，那么隐含规则生效。 1.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el 编译C程序的隐含规则 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.c，并且其生成命令是 $(CC) –c $(CPPFLAGS) $(CFLAGS)。 编译 C++ 程序的隐含规则 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.cc 或是 &lt;n&gt;.C，并且其生成命令是 $(CXX) –c $(CPPFLAGS) $(CFLAGS)（建议使用 .cc 作为 C++ 源文件的后缀，而不是 .C）。 编译 Pascal 程序的隐含规则 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.p，并且其生成命令是 $(PC) –c $(PFLAGS) 。 编译 Fortran/Ratfor 程序的隐含规则 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.r 或 &lt;n&gt;.F 或 &lt;n&gt;.f，并且其生成命令是: 123.f $(FC) –c $(FFLAGS).F $(FC) –c $(FFLAGS) $(CPPFLAGS).f $(FC) –c $(FFLAGS) $(RFLAGS) 预处理 Fortran/Ratfor 程序的隐含规则 &lt;n&gt;.f 的目标的依赖目标会自动推导为 &lt;n&gt;.r 或 &lt;n&gt;.F。这个规则只是转换 Ratfor 或有预处理的 Fortran 程序到一个标准的 Fortran 程序。其使用的命令是： 12.F $(FC) –F $(CPPFLAGS) $(FFLAGS).r $(FC) –F $(FFLAGS) $(RFLAGS) 编译 Modula-2 程序的隐含规则 &lt;n&gt;.sym 的目标的依赖目标会自动推导为 &lt;n&gt;.def，并且其生成命令是：$(M2C) $(M2FLAGS) $(DEFFLAGS)；&lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.mod，并且其生成命令是：$(M2C) $(M2FLAGS) $(MODFLAGS)。 汇编和汇编预处理的隐含规则 &lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.s，默认使用编译器 as，并且其生成命令是：$ (AS) $(ASFLAGS)；&lt;n&gt;.s 的目标的依赖目标会自动推导为 &lt;n&gt;.S，默认使用 C 预编译器 cpp，并且其生成命令是：$(AS) $(ASFLAGS)。 链接 Object 文件的隐含规则 &lt;n&gt; 目标依赖于 &lt;n&gt;.o，通过运行 C 的编译器来运行链接程序生成（一般是 ld），其生成命令是：$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)。这个规则对于只有一个源文件的工程有效，同时也对多个 Object 文件（由不同的源文件生成）的也有效。 Yacc C 程序时的隐含规则 &lt;n&gt;.c 的依赖文件被自动推导为 n.y（Yacc 生成的文件），其生成命令是：$(YACC) $(YFALGS)。 Lex C 程序时的隐含规则 &lt;n&gt;.c 的依赖文件被自动推导为 n.l（Lex 生成的文件），其生成命令是：$(LEX) $(LFALGS)。 Lex Ratfor 程序时的隐含规则 &lt;n&gt;.r 的依赖文件被自动推导为 n.l（Lex 生成的文件），其生成命令是：$(LEX) $(LFALGS)。 从 C 程序、Yacc 文件或 Lex 文件创建 Lint 库的隐含规则 &lt;n&gt;.ln（lint 生成的文件）的依赖文件被自动推导为 n.c，其生成命令是：$(LINT) $(LINTFALGS) $(CPPFLAGS) -i。对于 &lt;n&gt;.y 和 &lt;n&gt;.l 也是同样的规则。 隐含规则使用的变量隐含规则的命令使用了一些预置的变量。 make 命令的 -R 或 --no–builtin-variables 参数可以取消自定义的变量对隐含规则的作用。 隐含规则会使用两类变量，命令类型和命令参数类型。 关于命令的变量 变量 含义 AR 函数库打包程序，默认命令是 ar AS 汇编语言编译程序。默认命令是 as CC C语言编译程序。默认命令是 cc CXX C++语言编译程序。默认命令是 g++ CO 从 RCS文件中扩展文件程序。默认命令是 co CPP C程序的预处理器（输出是标准输出设备）。默认命令是 $(CC) –E FC Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 f77 GET 从SCCS文件中扩展文件的程序。默认命令是 get LEX Lex方法分析器程序（针对于C或Ratfor）。默认命令是 lex PC Pascal语言编译程序。默认命令是 pc YACC Yacc文法分析器（针对于C程序）。默认命令是 yacc YACCR Yacc文法分析器（针对于Ratfor程序）。默认命令是 yacc –r MAKEINFO 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 makeinfo TEX 从TeX源文件创建TeX DVI文件的程序。默认命令是 tex TEXI2DVI 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 texi2dvi WEAVE 转换Web到TeX的程序。默认命令是 weave CWEAVE 转换C Web 到 TeX的程序。默认命令是 cweave TANGLE 转换Web到Pascal语言的程序。默认命令是 tangle CTANGLE 转换C Web 到 C。默认命令是 ctangle RM 删除文件命令。默认命令是 rm –f 关于命令参数的变量 变量 含义 ARFLAGS 函数库打包程序AR命令的参数。默认值是 rv ASFLAGS 汇编语言编译器参数。（当明显地调用 .s 或 .S 文件时） CFLAGS C 语言编译器参数 CXXFLAGS C++ 语言编译器参数 COFLAGS RCS 命令参数 CPPFLAGS C 预处理器参数（ C 和 Fortran 编译器也会用到） FFLAGS Fortran 语言编译器参数 GFLAGS SCCS “get” 程序参数 LDFLAGS 链接器参数 LFLAGS Lex 文法分析器参数 PFLAGS Pascal 语言编译器参数 RFLAGS Ratfor 程序的 Fortran 编译器参数 YFLAGS Yacc 文法分析器参数 隐含规则链有时一个目标可能被一系列的隐含规则所作用，例如 .o 文件可能先被 Yacc 生成 .c 文件，再由 C 编译器编译 C 文件生成，如果 .c 文件存在， 那么直接调用 C 的编译隐含规则，否则先寻找 Yacc 的 .y 文件，产生 .c。 这一系列的隐含规则叫做“隐含规则链”。 上面由隐含规则推断出来的中间过程的 .c 文件，被称为中间目标。 默认情况下，中间目标和一般目标的 2 个区别：除非中间的目标不存在，才会引发中间规则；只要目标成功产生，那么所产生的中间目标文件会被以 rm -f 删除。 可以使用伪目标 .INTERMEDIATE 来强制声明某个目标为中间目标。例如：.INTERMEDIATE : mid。 可以使用伪目标 .SECONDARY 来强制声明阻止 Make 删除中间目标。例如：.SECONDARY : sec。 定义模式规则模式规则中，至少在规则的目标定义中要包含 %。目标中的 % 定义表示对文件名的匹配，% 表示长度任意的非空字符串。 模式规则示例 12%.o : %.c ; &lt;command ......&gt;;# 定义了怎样从所有的 .c 文件生成相应的 .o 文件的规则 123%.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@# $@ 表示所有的目标的相邻值， $&lt; 表示了所有依赖目标的相邻值 123%.tab.c %.tab.h: %.y bison -d $&lt;# 把所有的 .y 文件都以 bison -d &lt;n&gt;.y 执行，然后生成 &lt;n&gt;.tab.c 和 &lt;n&gt;.tab.h 文件（其中，&lt;n&gt; 表示一个任意字符串 自动化变量 这种变量会把模式中所定义的一系列的文件自动依次取出，直至所有的符合模式的文件都取完了。 自动化变量只应出现在规则的命令中。 自动化变量 含义 $@ 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么 $@ 就是匹配于目标中模式定义的集合 $% 仅当目标是函数库文件中，表示规则中的目标成员名 $&lt; 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $&lt; 将是符合模式的一系列的文件集 $? 所有比目标新的依赖目标的集合，以空格分隔 $^ 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份 $+ 这个变量类似 $^，也是所有依赖目标的集合。只是它不去除重复的依赖目标 $* 这个变量表示目标模式中 % 及其之前的部分。如果目标是 dir/a.foo.b ，并且目标的模式是 a.%.b ，那么，$* 的值就是 dir/a.foo 最好给 $ 后面的那个特定字符都加上圆括号，比如 $(&lt;) 就要比 $&lt; 要好。 四个变量（$@ 、$&lt; 、$% 、$* ）在扩展时只会有一个文件，而外另三个的值是一个文件列表。 搭配上 D 或 F 字符，可以取得文件的目录名或是在当前目录下的符合模式的文件名。 这是 GNU Make 旧版的特性，在新版，使用函数 dir 或 notdir 就可以做到。 七个变量分别加上 D 或是 F 的含义： $(@D) 表示 $@ 的目录部分（不以斜杠作为结尾），如果 $@ 值是 dir/foo.o ，那么 $(@D) 就是 dir ，而如果 $@ 中没有包含斜杠的话，其值就是 . （当前目录）。 $(@F)表示 $@ 的文件部分，如果 $@ 值是 dir/foo.o ，那么 $(@F) 就是 foo.o ， $(@F) 相当于函数 $(notdir $@) 。 $(D), $(F) 和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， $(D) 返回 dir ，而 $(F) 返回 foo $(%D), $(%F) 分别表示了函数包文件成员的目录部分和文件部分。这对于形同 archive(member) 形式的目标中的 member 中包含了不同的目录很有用。 $(&lt;D), $(&lt;F) 分别表示依赖文件的目录部分和文件部分。 $(^D), $(^F) 分别表示所有依赖文件的目录部分和文件部分。（无相同的） $(+D), $(+F) 分别表示所有依赖文件的目录部分和文件部分。（可以有相同的） $(?D), $(?F) 分别表示被更新的依赖文件的目录部分和文件部分 模式的匹配% 所匹配的内容被称为“茎”，例如 %.c 所匹配的文件 test.c 中 test 就是“茎”。 在目标和依赖目标中同时有 % 时，依赖目标的“茎”会传给目标，当做目标中的“茎”。 当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。 例如有一个模式 e%t，文件 src/eat 匹配于该模式，于是 src/a 就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 c%r，那么目标就是 src/car （“茎”被传递）。 重载内建隐含规则可以重新构造和内建隐含规则不同的命令： 12%.o : %.c $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date) 旧版“后缀规则”后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步取代。 后缀规则有两种方式：“双后缀”和“单后缀” 双后缀 双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。 如 .c.o 相当于 %o : %c 单后缀 定义源文件的后缀。如 .c 相当于 % : %.c 后缀规则中所定义的后缀应该是 Make 所认识的。 12.c.o: $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt; 后缀规则不允许任何的依赖文件。 12.c.o: foo.h $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt; 使用伪目标 .SUFFIXES 来定义或是删除特定后缀。 12.SUFFIXES: # 删除默认的后缀.SUFFIXES: .c .o .h # 定义自己的后缀 make 命令的参数 -r 或 -no-builtin-rules 也会使默认的后缀列表为空。 变量 SUFFIXE 被用来定义默认的后缀列表，可以用 .SUFFIXES 来改变后缀列表，但不要改变变量 SUFFIXE 的值。 隐含规则搜索算法使用 Make 更新函数库文件设有目标 T，搜索目标 T 的规则的算法如下： 所有的后缀规则在 Makefile 被载入内存时，会被转换成模式规则。如果目标是 archive(member) 的函数库文件模式，这个算法会被运行两次，第一次是找目标 T，如果没有找到，进入第二次，第二次把 member 当作 T 来搜索。 把 T 的目录部分分离出来。叫 D，而剩余部分叫 N。（如：如果 T 是 src/foo.o，那么 D 就是 src/，N 就是 foo.o）； 创建所有匹配于T或是N的模式规则列表； 如果在模式规则列表中有匹配所有文件的模式，如 %，那么从列表中移除其它的模式； 移除列表中没有命令的规则； 对于第一个在列表中的模式规则： 1&gt; 推导其“茎”S，S 应该是 T 或是 N 匹配于模式中 % 非空的部分； 2&gt; 计算依赖文件。把依赖文件中的 % 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把 D 加在第一个依赖文件的开头； 3&gt; 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）； 4&gt; 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则： 1&gt; 如果规则是终止规则，那就忽略它，继续下一条模式规则； 2&gt; 计算依赖文件（同第 5 步）； 3&gt; 测试所有的依赖文件是否存在或是理当存在； 4&gt; 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到； 5&gt; 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法； 6&gt; 如果没有隐含规则可以使用，查看 .DEFAULT 规则，如果有，采用，把 .DEFAULT 的命令给T使用。 一旦规则被找到，就会执行其相当的命令，而此时自动化变量的值才会生成。 使用 Make 更新函数库文件函数库文件就是对 Object 文件（程序编译的中间文件）的打包文件。 在Unix下，一般是由 ar 命令来完成打包工作。 函数库文件的成员一个函数库文件由多个文件组成，使用如下格式指定函数库文件及其组成： 1archive(member) 例如： 12foolib(hack.o) : hack.o ar cr foolib hack.o 指定多个 member，使用空格隔开： 1foolib(hack.o kludge.o) 等价于： 1foolib(hack.o) foolib(kludge.o) 使用通配符： 1foolib(*.o) 函数库成员的隐含规则当 Make 搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 a(m) 形式的，其会把目标变成 (m)。 如果成员是 %.o 的模式定义，并且如果使用 make foo.a(bar.o) 的形式调用 Makefile，隐含规则会去找 bar.o 的规则，如果没有定义 bar.o 的规则，那么内建隐含规则生效，Make 会去找 bar.c 文件来生成 bar.o。 流程如下： 123cc -c bar.c -o bar.oar r foo.a bar.orm -f bar.o 函数库文件的后缀规则可以使用“后缀规则”和“隐含规则”来生成函数库打包文件： 1234.c.a: $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o $(AR) r $@ $*.o $(RM) $*.o 等效于： 1234(%.o) : %.c $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o $(AR) r $@ $*.o $(RM) $*.o 注意事项在进行函数库打包文件生成时，需要小心使用 Make 的并行机制（-j 参数）。如果多个 ar 命令在同一时间运行在同一个函数库打包文件上，就很有可能损坏这个函数库文件。","link":"/2020/07/14/makefile-%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"Android","slug":"android","link":"/tags/android/"},{"name":"Binder","slug":"binder","link":"/tags/binder/"},{"name":"NDK","slug":"ndk","link":"/tags/ndk/"},{"name":"JNI","slug":"jni","link":"/tags/jni/"},{"name":"Makefile","slug":"makefile","link":"/tags/makefile/"},{"name":"Make","slug":"make","link":"/tags/make/"}],"categories":[{"name":"Android 系统原理","slug":"android-系统原理","link":"/categories/android-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"Android 应用开发","slug":"android-应用开发","link":"/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]}
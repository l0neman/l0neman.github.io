<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Xposed 实现原理分析 - l0neman 的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="l0neman 的博客"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="l0neman 的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言Xposed 是 Android 平台上著名的 Java 层 Hook 框架，通过在 Android 设备上安装 Xposed 框架，编写 Xposed 模块，可实现对任意 Android 应用的 Java 方法的 Hook，以及应用资源的替换。 （Hook 是一种函数钩子技术，能够对函数进行接管，从而修改函数的返回值，改变函数的原始意图） 本文将基于 Xposed 最新的开源代码对 Xpos"><meta property="og:type" content="blog"><meta property="og:title" content="Xposed 实现原理分析"><meta property="og:url" content="https://l0neman.github.io/2020/10/11/xposed-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"><meta property="og:site_name" content="l0neman 的博客"><meta property="og:description" content="前言Xposed 是 Android 平台上著名的 Java 层 Hook 框架，通过在 Android 设备上安装 Xposed 框架，编写 Xposed 模块，可实现对任意 Android 应用的 Java 方法的 Hook，以及应用资源的替换。 （Hook 是一种函数钩子技术，能够对函数进行接管，从而修改函数的返回值，改变函数的原始意图） 本文将基于 Xposed 最新的开源代码对 Xpos"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://l0neman.github.io/2020/10/11/xposed-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/hook_flow.png"><meta property="article:published_time" content="2020-10-11T14:21:30.000Z"><meta property="article:modified_time" content="2020-10-11T14:21:30.000Z"><meta property="article:author" content="l0neman"><meta property="article:tag" content="Android"><meta property="article:tag" content="Xposed"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="./hook_flow.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://l0neman.github.io/2020/10/11/xposed-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},"headline":"Xposed 实现原理分析","image":["https://l0neman.github.io/2020/10/11/xposed-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/hook_flow.png"],"datePublished":"2020-10-11T14:21:30.000Z","dateModified":"2020-10-11T14:21:30.000Z","author":{"@type":"Person","name":"l0neman"},"publisher":{"@type":"Organization","name":"l0neman 的博客","logo":{"@type":"ImageObject","url":"https://l0neman.github.io/img/logo.png"}},"description":"前言Xposed 是 Android 平台上著名的 Java 层 Hook 框架，通过在 Android 设备上安装 Xposed 框架，编写 Xposed 模块，可实现对任意 Android 应用的 Java 方法的 Hook，以及应用资源的替换。 （Hook 是一种函数钩子技术，能够对函数进行接管，从而修改函数的返回值，改变函数的原始意图） 本文将基于 Xposed 最新的开源代码对 Xpos"}</script><link rel="canonical" href="https://l0neman.github.io/2020/10/11/xposed-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?1727d76e0a823184efc8776f32a916a9";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="l0neman 的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/l0neman"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-three-quarters"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-10-11T14:21:30.000Z" title="2020/10/11 下午10:21:30">2020-10-11</time>发表</span><span class="level-item"><time dateTime="2020-10-11T14:21:30.000Z" title="2020/10/11 下午10:21:30">2020-10-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/android-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">Android 逆向工程</a></span><span class="level-item">2 小时读完 (大约15723个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Xposed 实现原理分析</h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Xposed 是 Android 平台上著名的 Java 层 Hook 框架，通过在 Android 设备上安装 Xposed 框架，编写 Xposed 模块，可实现对任意 Android 应用的 Java 方法的 Hook，以及应用资源的替换。</p>
<p>（Hook 是一种函数钩子技术，能够对函数进行接管，从而修改函数的返回值，改变函数的原始意图）</p>
<p>本文将基于 Xposed 最新的开源代码对 Xposed 的实现原理进行分析。Xposed 有两种实现版本，一个是基于 Dalvik 虚拟机的实现，它是针对早期的 Android 4.4 之前的 Android 设备设计的；另一个是基于 ART 虚拟机的实现，自 Android 5.0 系统开始，Android 系统正式采用了 ART 虚拟机模式运行，Dalvik 就成了历史，目前市面上几乎所有的手机都是以 ART 模式运行的，下面将主要对于 ART 上的 Xposed 实现进行详细分析，对于 Dalvik 上的 Xposed 的实现，进行必要性的分析。</p>
<p>通过了解 Xposed 的实现原理可以学到在 Android 平台上对于 Java 层代码的一种 Hook 机制的实现，同时复习 Android 系统的启动原理以及增加对于 Android ART 虚拟机运行原理的了解。</p>
<span id="more"></span>


<h1 id="Xposed-使用方法"><a href="#Xposed-使用方法" class="headerlink" title="Xposed 使用方法"></a>Xposed 使用方法</h1><p>在对 Xposed 进行分析之前，先回顾一下 Xposed 基本 API 的使用。</p>
<p>Xposed 的核心用法就是对一个 Java 方法进行 Hook，它的典型调用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(Application.class, <span class="string">&quot;onCreate&quot;</span>, Context.class,</span><br><span class="line">    <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Application app = (Application) param.thisObject;</span><br><span class="line">        Context context = (Context) param.args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Application#onCreate(Context); this: &quot;</span> + app + <span class="string">&quot; arg: &quot;</span> + context);</span><br><span class="line"></span><br><span class="line">        param.setResult(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterHookedMethod(param);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码的意思是对 <code>Application</code> 这个类的 <code>onCreate</code> 方法进行 Hook，并使用 <code>XC_MethodHook</code> 对象提供一个 Hook 处理方法来接管原来方法的逻辑，当应用的 <code>Application</code> 类型的 <code>onCreate</code> 方法被调用时，<code>beforeHookedMethod</code> 将在被调用之前执行，同时 <code>onCreate</code> 的参数将会传递给 <code>beforeHookedMethod</code> 方法进行处理，上面的处理只是将参数打印了出来（一个 <code>Context</code>），同时还可以拿到被调用的 <code>this</code> 目标对象，也就是 <code>Application</code> 的对象，还可以使用 <code>setResult</code> 方法更改原始方法的返回值，不过这里的 <code>Application#onCreate</code> 方法是 <code>void</code> 返回类型的，<code>setResult</code> 不起作用，如果是其他类型，那么原方法的返回值将被更改。</p>
<p>这样就达到了修改一个 Java 方法的目的，即改变了原始方法的逻辑和意图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果要使用 Xposed 对一个 Java 方法进行 Hook，需要提供要 Hook 方法的名字、参数列表类型和方法所在类，以及处理 Hook 的回调方法。</p>
<p>下面正式开始分析。</p>
<h1 id="Xposed-原理概述"><a href="#Xposed-原理概述" class="headerlink" title="Xposed 原理概述"></a>Xposed 原理概述</h1><p>首先概述 Xposed 原理，之后再对具体细节进行分析。</p>
<p>Xposed 是一个 Hook 框架，它提供了对任意 Android 应用的 Java 方法进行 Hook 的一种方法，通常它的使用方法如下：</p>
<ol>
<li>首先按照 Xposed 官网提供的开发规范编写一个 Xposed 模块，它是一个普通的 Android 应用，包含一块开发者自己定义的代码，这块代码有能力通过 Xposed 框架提供的 Hook API 对任意应用的 Java 方法进行 Hook。</li>
<li>在要启用 Xposed 的 Android 设备上安装 Xposed 框架和这个 Xposed 模块，然后在 Xposed 框架应用中启用这个 Xposed 模块，重新启动设备后，Xposed 模块将被激活，当任意的应用运行起来后，Xposed 模块的 Hook 代码将会在这个应用进程中被加载，然后执行，从而对这个应用的 Java 方法进行指定 Hook 操作。 </li>
</ol>
<p>那么根据以上使用方法实现一个 Xposed 框架需要分成如下几个部分：</p>
<ol>
<li>提供用于 Hook 操作的 API，为了让开发者进行模块开发。它通常是一个 jar 包；</li>
<li>提供一个具有界面的管理器应用，用于安装和管理 Xposed 本身和 Xposed 模块；</li>
<li>提供将代码加载到每一个应用进程中的能力，目的是支持 Xposed 模块的代码在进程中使用 Xposed API 进行 Hook 操作；</li>
<li>提供 Hook 任意 Java 方法的能力，为 Xposed 模块的调用提供支持，当 Xposed 模块在应用进程中执行时可对方法进行 Hook。</li>
</ol>
<p>前两点对于我们开发者来说都很熟悉，没有什么难点，后面两点才是实现 Xposed 的核心。</p>
<p>首先是 Xposed 怎样实现的将代码加载到每一个应用进程中（Xposed 是基于 Root 权限实现的，所以有修改 Android 系统的能力）？</p>
<p>Xposed 是通过修改系统 zygote 进程的实现将代码注入应用进程中的。</p>
<p>为了知道 Xposed 是如何修改 Zygote 进程的，下面首先介绍 Android 系统 Zygote 相关内容。</p>
<h2 id="Android-zygote-进程"><a href="#Android-zygote-进程" class="headerlink" title="Android zygote 进程"></a>Android zygote 进程</h2><p>zygote 进程是 Android 系统中第一个拥有 Java 运行环境的进程，它是由用户空间 1 号进程 init 进程通过解析 init.rc 文件创建出来的，从 init 进程 fork 而来。</p>
<p>zygote 进程是一个孵化器。Android 系统中所有运行在 Java 虚拟机中的系统服务以及应用均由 zygote 进程孵化而来。</p>
<p>zygote 通过克隆（fork）的方式创建子进程，fork 出来的子进程将继承父进程的所有资源，基于这个特性，zygote 进程在启动过程将创建 Java ART 虚拟机，预加载一个 Java 进程需要的所有系统资源，之后子进程被创建后，就可以直接使用这些资源运行了。</p>
<p>自 Android 5.0 系统开始，zygote 不再是一个进程，而是两个进程，一个是 32 位 zygote，负责孵化 32 位进程（为了兼容使用了 armeabi 和 armeabi-v7a 等 32 位架构的本地动态库的应用），另一个是 64 位 zygote 进程，负责孵化 64 位应用进程（可加载 arm64-v8a 等 64 位架构本地库）。</p>
<p>init 进程是 Android 系统中的 pid 为 1 的进程，是用户空间的第一个进程，它会在 Android 系统启动时被内核创建出来，之后会对 init.rc 文件进行解析，init.rc 文件是一个按照特定规则编写的脚本文件，init 进程通过解析它的规则来创建对应的服务进程。下面看一下 zygote 相关的 rc 文件的内容。</p>
<p>注：自 Android 5.0 开始，32 位 zygote 启动内容在 init.zygote32.rc 文件中，64 位 zygote 启动内容在 init.zygote64.rc 中。</p>
<p>注：自 Android 9.0 开始，两个 zygote 启动配置放在一个文件中 init.zygote64_32.rc。</p>
<p>这里看一下 Android 8.1 系统的 32 位 zygote 的 rc 文件内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> init.zygote32.rc</span></span><br><span class="line"></span><br><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>

<p>上面的含义是，创建一个名为 zygote 的服务进程，它的可执行文件在 <code>/system/bin/app_process</code> 中，后面的 <code>-Xzygote</code>、<code>/system.bin</code> 等是可执行文件的 <code>main</code> 函数将要接收的参数。</p>
<p>具体的 init 进程和 zygote 进程的启动细节，可以参考之前的文章：</p>
<p><a href="/2020/08/17/android-init-%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/">Android init 进程启动分析</a></p>
<p><a href="/2020/08/24/android-zygote-%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/">Android zygote 进程启动分析</a></p>
<p>那么现在回到 Xposed，Xposed 对 zygote 进程的实现源码进行修改后，重新编译出 app_process 可执行文件，替换了系统的 app_process 文件（包括 64 位 zygote），并在其中加载了 XposedBridge.jar 这个 Dex 代码包，它包含 Xposed 的 Java 层实现代码和提供给 Xposed 模块的 API 代码，那么当 init 进程启动 zygote 服务进程时，将执行修改过的 app_process 文件，此时 zygote 进程就具有了 Xposed 的代码，Xposed 可以进行加载 Xposed 模块代码等任意操作了。</p>
<p>所有 Android 应用都是运行在 Java 虚拟机上的，所有的 Android 应用都是 zygote 的子进程，那么当 Android 应用进程启动后，将具备 zygote 进程加载的所有资源，从而将 Xposed 代码继承到了 Android 应用进程中，实现了将 Xposed 代码加载到每一个进程中的目的。</p>
<p>接下来是如何实现对应用中 Java 方法的 Hook。Hook 的基本原理如下，将 Java 方法的原始逻辑，转接到一个中间处理方法上，这个处理方法会对原始 Java 方法的参数进行转发，转发到一个用于处理 Hook 的方法上（即 <code>XC_MethodHook</code> 的实现），等处理 Hook 的方法执行自定义逻辑后（自定义逻辑可选择调用原始逻辑先获取原始返回值，再处理），再返回新的返回值。</p>
<p><img src="./hook_flow.png"></p>
<p>下面分别是 Xposed 在 Dalvik 虚拟机和 ART 虚拟机下的 Hook 实现。</p>
<h2 id="基于-Dalvik-的方法-Hook"><a href="#基于-Dalvik-的方法-Hook" class="headerlink" title="基于 Dalvik 的方法 Hook"></a>基于 Dalvik 的方法 Hook</h2><p>基于 Dalvik 的 Hook 方案是通过将被 Hook 方法修改为一个 JNI 方法，然后绑定一个 Xposed 自定义处理方法逻辑的函数上来实现的。</p>
<p>当需要 Hook 一个指定方法时，需要提供要 Hook 方法的名字、参数列表类型和方法所在类型，还要提供一个用于处理 Hook 的回调，回调方法用于修改原始方法的逻辑，它可以接收 Hook 方法的参数，然后返回一个新的返回值。</p>
<p>首先 Xposed 会取得这个方法的反射表示对象（例如通过 <code>Class.getDeclaredMethod</code>），它是一个 <code>java.lang.reflect.Method</code> 对象，然后取得这个对象的一个私有成员变量 <code>slot</code> 的值，将它和处理 Hook 的回调传递给 Xposed 的 Native 层代码，这个 <code>slot</code> 变量实际上是一个 Java 方法在虚拟机中的索引，使用这个索引可以从 Dalvik 中用于表示 Java 类的 <code>ClassObject</code> 映射类型的 <code>directMethod</code> 和 <code>virtualMethods</code> 数组中取出一个 <code>Method</code> 对象，它在虚拟机中表示一个 Java 方法，Xposed 的 Native 层代码接收到 Xposed Java 层传递过来的 <code>slot</code> 变量后，取出虚拟机中的 Method 对象，然后将这个 Method 对象的类型设置为 JNI 方法，即前面带有 native 修饰符的方法，然后将它的 <code>nativeFunc</code> 赋值给一个处理 Hook 逻辑的函数上，这个函数中将对这个 Method 的参数进行处理，传递给一开始提供的 Java 层中用于处理 Hook 的回调方法，让它来决定方法的新逻辑，从而返回新的返回值。此时便完成了 Hook。</p>
<p>那么调用一个被 Hook 的方法的过程是：当一个 Android 应用内的代码调用一个被 Hook 的方法时，Dalvik 将会进行代码的解释执行，Java 方法进入 Dalvik 虚拟机中会被转化为一个 Method 对象，然后虚拟机判断这个方法如果是一个 JNI 方法，就会直接调用它绑定的的 <code>nativeFunc</code> 函数，那么就走到了 Xposed 处理 Hook 的函数中，这个函数将这个被 Hook 方法的参数进行转发，让 Xposed 模块提供的处理 Hook 的回调方法来接管原来的逻辑，获得新的返回值返回给被 Hook 方法，即可完成整个 Hook 操作。</p>
<h2 id="基于-ART-的方法-Hook"><a href="#基于-ART-的方法-Hook" class="headerlink" title="基于 ART 的方法 Hook"></a>基于 ART 的方法 Hook</h2><p>基于 ART 的 Hook 方案相比 Dalvik 要复杂一些，需要重新修改编译 ART 虚拟机的源码，重新编译出 ART 虚拟机的可执行文件 libart.so，替换 Android 系统中的 ART 虚拟机实现。</p>
<p>它的核心原理就是直接修改一个方法对应的汇编代码的地址，让方法直接跳转到指定地址执行，然后就可以执行自定义的逻辑进行 Hook 处理了。</p>
<p>ART 虚拟机为了提高执行效率，采用了 <code>AOT（Ahead Of Time，预编译）</code> 模式运行，在应用运行之前先将整个 APK 包含的 Java 编译为二进制代码，然后应用运行时将执行每个方法对应的机器代码，比采用 <code>JIT（Just In Time Compiler，即时编译）</code> 的 Dalvik 虚拟机每次在运行时才编译代码执行的效率更高。</p>
<p>前面的过程和 Dalvik 一样，都需要在 Hook 一个指定方法时，提供要 Hook 方法的名字、参数列表类型和方法所在类型，和一个用于处理 Hook 的回调，这个回调用于修改原始方法的逻辑。</p>
<p>接下来 Xposed 取得这个方法的反射表示对象，它是一个 <code>java.lang.reflect.Method</code> 对象，然后和用于处理 Hook 的回调一起传递给 Xposed 的 Native 层代码，Native 层代码使用 <code>ArtMethod</code> 的一个静态转换方法，将 Java 层的反射对象 Method 转换为一个 ART 中用于表示一个 Java 方法的 <code>ArtMethod</code> 对象，获取这个表示被 Hook 的 Java 方法的 <code>ArtMethod</code> 对象后，会创建它的副本对象用于备份，备份目的是可以在可是的时候再调用原始方法，然后给这个 <code>ArtMethod</code> 对象重新设置汇编代码的地址，这个地址指向一段汇编代码，这个汇编代码是一段蹦床代码（Trampoline），会跳入原本用于处理 Java 动态代理的方法的函数，Xposed 对其进行了修改，在其中加入了处理 Hook 的逻辑，也就是转发被 Hook 方法的参数给处理 Hook 的回调方法，让 Hook 回调方法处理被 Hook 方法的逻辑，从而完成 Hook。至此就完成了 ART 中的 Hook 处理。</p>
<p>那么调用一个被 Hook 的方法的过程是：当一个 Android 应用内代码调用一个被 Hook 的方法时，ART 将会对方法代码进行执行，首先这个 Java 方法在 ART 虚拟机中将使用一个 <code>ArtMethod</code> 对象表示，然后进入 ART 的 Java 方法执行函数中，会跳入一段蹦床代码中进行执行，这段蹦床代码又会跳入这个 <code>ArtMethod</code> 对象设置的汇编代码地址处，从而执行到 Xposed 用于处理 Hook 的代码中，之后完成 Hook 逻辑。</p>
<p>上面使用书面语言分别概述了基于 Dalvik 和 ART 的方法 Hook 的实现，目的是对整个 Xposed 实现对方法的 Hook 原理进行概括，建立一个初步的印象。真正的细节还是在源代码中，为了分析最终源代码，下面进一步对 Xposed 进行分析。</p>
<h1 id="Xposed-工作流程"><a href="#Xposed-工作流程" class="headerlink" title="Xposed 工作流程"></a>Xposed 工作流程</h1><p>为了进一步分析 Xposed 的实现原理，先对 Xposed 的整体工作流程进行了解。</p>
<p>要使 Xposed 在 Android 设备上工作，首先需要安装 Xposed 框架。</p>
<p>首先获取 XposedInstaller 应用（去官方下载，或者通过 clone XposedInstaller 项目后自行编译），安装到已经 root 的设备上，然后打开 XposedInstaller。</p>
<p>XposedInstaller 主页会有“INSTALL/UPDATE” 的按钮，点击将会出现 <code>Install</code> 和 <code>Install via recovery</code> 两个选择，一个是直接进行安装；另一个是通过 recovery 进行刷入安装。不管选择哪个，都会首先从服务器下载相同的 xposed 补丁包。</p>
<p>XposedInstaller 会根据系统版本和 CPU 支持架构下载对应的系统补丁包。</p>
<p>在 ARM64 架构 CPU 的 Android 8.1 系统上，补丁包内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">xposed-v90-sdk27-arm64-beta3.zip</span><br><span class="line"> +-META-INF</span><br><span class="line"> │ +- CERT.RSA</span><br><span class="line"> │ +- CERT.SF</span><br><span class="line"> │ +- MANIFEST.MF</span><br><span class="line"> │     +- com/google/android</span><br><span class="line"> │         +- flash-script.sh</span><br><span class="line"> │         +- update-binary</span><br><span class="line"> │         +- updater-script</span><br><span class="line"> │</span><br><span class="line"> +- system</span><br><span class="line">     +- xposed.prop</span><br><span class="line">     +- bin</span><br><span class="line">     |   +- app_process32_xposed</span><br><span class="line">     |   +- app_process64_xposed</span><br><span class="line">     |   +- dex2oat</span><br><span class="line">     |   +- dexdiag</span><br><span class="line">     |   +- dexlist</span><br><span class="line">     |   +- dexoptanalyzer</span><br><span class="line">     |   +- oatdump</span><br><span class="line">     |   +- patchoat</span><br><span class="line">     |   +- profman</span><br><span class="line">     |</span><br><span class="line">     +- framework</span><br><span class="line">     |   +- XposedBridge.jar</span><br><span class="line">     |</span><br><span class="line">     +- lib</span><br><span class="line">     |   +- libart-compiler.so</span><br><span class="line">     |   +- libart-dexlayout.so</span><br><span class="line">     |   +- libart.so</span><br><span class="line">     |   +- libopenjdkjvm.so</span><br><span class="line">     |   +- libsigchain.so</span><br><span class="line">     |   +- libxposed_art.so</span><br><span class="line">     |</span><br><span class="line">     +- lib64</span><br><span class="line">         +- libart-compiler.so</span><br><span class="line">         +- libart-disassembler.so</span><br><span class="line">         +- libart.so</span><br><span class="line">         +- libopenjdkjvm.so</span><br><span class="line">         +- libsigchain.so</span><br><span class="line">         +- libxposed_art.so</span><br></pre></td></tr></table></figure>

<p>压缩包名为 xposed-v90-sdk27-arm64-beta3.zip，文件名包含系统版本、CPU 架构和 Xposed 版本信息。</p>
<p>META-INF 目录存放文件签名信息，和 Xposed 刷机脚本 flash-script.sh 文件，update-binary 为刷入文件时执行的文件，它的源代码在 Android 源代码 <code>bootable/recovery/updater/</code> 目录中。</p>
<p>system 目录为 Xposed 所需的文件，刷入时将会复制到系统 system 目录下，同名文件将进行覆盖，其中 xposed.prop 为 Xposed 的属性文件，里面会存放 Xposed 版本相关信息，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version=90-beta3</span><br><span class="line">arch=arm64</span><br><span class="line">minsdk=27</span><br><span class="line">maxsdk=27</span><br><span class="line">requires:fbe_aware=1</span><br></pre></td></tr></table></figure>

<p>bin 目录存放系统可执行文件；framwrok 目录存放 Xposed 的  Java 层 Dex 代码包，用于在 Zygote 进程中进行加载；lib、lib64 是 32 位和 64 位系统库，包括 ART 虚拟机库 libart.so 和依赖的库，还有 Xposed Native 层代码的实现 libxposed_art.so。</p>
<p>回到 XposedInstaller 中，如果选择了 <code>Install</code>，那么首先将压缩包中的 system 目录下的的可执行文件以及依赖库、配置文件等复制入系统 system 中覆盖相应系统文件，然后请求重启 Android 系统，重启后开机过程中，系统将会执行 app_process 可执行文件，从而启动 Xposed 修改过的 zygote 进程，其中会把 <code>XposedBridge.jar</code> 代码包加载起来，加载后其中的 Java 代码会加载已经安装的 Xposed 模块，当手机中的应用进程启动后，Xposed 模块代码将会被包含在应用进程中，开始工作；</p>
<p>如果是 <code>Install via recovery</code>，将创建文件 <code>/cache/recovery/command</code> 并写入指定刷机包路径的刷机命令，然后重启手机进入 recovery 模式，recovery 模式会自动执行 <code>command</code> 文件中的命令将 Xposed 文件刷入，然后正常重启至系统，启动过程和上面一致。</p>
<p>了解了 Xposed 的整体工作流程，下面开始着手进行源码分析。</p>
<h1 id="Xposed-项目结构"><a href="#Xposed-项目结构" class="headerlink" title="Xposed 项目结构"></a>Xposed 项目结构</h1><p>首先了解 Xposed 开源项目的结构，Xposed 包含如下几个开源项目：</p>
<h2 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h2><p>仓库地址：<a target="_blank" rel="noopener" href="https://github.com/rovo89/Xposed">https://github.com/rovo89/Xposed</a></p>
<p>Xposed Native 层代码的实现，主要修改了系统 <code>app_process</code> 的实现（即 zygote 服务进程的实现），为将 Hook 代码注入每个应用进程提供了入口。</p>
<h2 id="XposedBridge"><a href="#XposedBridge" class="headerlink" title="XposedBridge"></a>XposedBridge</h2><p>仓库地址：<a target="_blank" rel="noopener" href="https://github.com/rovo89/XposedBridge">https://github.com/rovo89/XposedBridge</a></p>
<p>Xposed Java 层的代码，它将单独作为一个 jar 包的形式通过 zygote 的分裂（fork）注入到每一个应用进程中，内部会 Xposed 模块，并为 Xposed 模块中的 Hook 操作提供 API 支持。</p>
<h2 id="XposedInstaller"><a href="#XposedInstaller" class="headerlink" title="XposedInstaller"></a>XposedInstaller</h2><p>仓库地址：<a target="_blank" rel="noopener" href="https://github.com/rovo89/XposedInstaller">https://github.com/rovo89/XposedInstaller</a></p>
<p>统一管理 Xposed 框架的 Android 应用，也是一个 Xposed 框架安装器，用于安装更新 Xposed 框架核心以及作为统一管理 Xposed 模块安装的模块管理器。</p>
<h2 id="android-art"><a href="#android-art" class="headerlink" title="android_art"></a>android_art</h2><p>仓库地址：<a target="_blank" rel="noopener" href="https://github.com/rovo89/android_art">https://github.com/rovo89/android_art</a></p>
<p>Xposed 修改后的 Android ART 虚拟机的实现，将编译出 libart.so 和其依赖库，替换系统的 ART 虚拟机实现。包含方法 Hook 的核心实现。</p>
<p>这个仓库最新分支是基于 Android Nougat MR2 源码修改的 ART 代码，目前 Xposed 最新版本支持到了 Android 8.1 系统，说明作者没有开源出最新代码，不过都是基于 ART 实现的 Hook，核心 Hook 实现是一致的，不影响分析。</p>
<h2 id="XposedTools"><a href="#XposedTools" class="headerlink" title="XposedTools"></a>XposedTools</h2><p>仓库地址：<a target="_blank" rel="noopener" href="https://github.com/rovo89/XposedTools">https://github.com/rovo89/XposedTools</a></p>
<p>用于编译 Xposed 框架的脚本工具。</p>
<p>目前只分析 Xposed 的实现，不需要对 Xposed 进行定制，所以先不关注 XposedTools 这个项目。</p>
<h1 id="Xposed-源码分析"><a href="#Xposed-源码分析" class="headerlink" title="Xposed 源码分析"></a>Xposed 源码分析</h1><p>可以对上面的项目进行 clone，然后用 Android Studio 和 VS Code 打开源代码，方便阅读。下面进入源码中分析具体实现。</p>
<h2 id="Xposed-安装"><a href="#Xposed-安装" class="headerlink" title="Xposed 安装"></a>Xposed 安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>首先从 Xposed 的安装开始分析，这部分代码的实现在 XposedInstaller 中。</p>
<p>在一台 Root 过的设备上安装 XposedInstaller 后打开，点击主页的“INSTALL/UPDATE”，会弹出一个对话框，选择“Install”或“Install via recovery”安装 Xposed 框架，此时会首先进行框架核心文件的下载，进入 <code>StatusInstallerFragment#download</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatusInstallerFragment.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(Context context, String title, FrameworkZips.Type type, <span class="keyword">final</span> RunnableWithParam&lt;File&gt; callback)</span> </span>&#123;</span><br><span class="line">    OnlineFrameworkZip zip = FrameworkZips.getOnline(title, type);</span><br><span class="line">    <span class="keyword">new</span> DownloadsUtil.Builder(context)</span><br><span class="line">            .setTitle(zip.title)</span><br><span class="line">2        <span class="comment">// 设置下载 url</span></span><br><span class="line">            .setUrl(zip.url)</span><br><span class="line">            .setDestinationFromUrl(DownloadsUtil.DOWNLOAD_FRAMEWORK)</span><br><span class="line">            .setCallback(<span class="keyword">new</span> DownloadFinishedCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDownloadFinished</span><span class="params">(Context context, DownloadInfo info)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 下载完成，触发回调</span></span><br><span class="line">                    LOCAL_ZIP_LOADER.triggerReload(<span class="keyword">true</span>);</span><br><span class="line">                    callback.run(<span class="keyword">new</span> File(info.localFilename));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .setMimeType(DownloadsUtil.MIME_TYPES.ZIP)</span><br><span class="line">            .setDialog(<span class="keyword">true</span>)</span><br><span class="line">            .download();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>zip.url</code> 为 Xposed 框架压缩包的下载地址，我们重点关注安装，所以这里简要描述 <code>zip</code> 对象，<code>zip</code> 是 <code>OnlineFrameworkZip</code> 类的对象，表示一个 Xposed 框架包，它包含 title、type 和 url 三个成员，type 有两种，Installer 和 Uninstaller，即安装包和卸载包，都是包含刷机脚本的 Xposed 补丁包（就是上面工作流程中的压缩包），title 有三种，Xposed 测试版、Xposed 正式版、和 Uninstaller，用于界面显示。上面的 <code>zip.url</code> 在  Android 8.1 的 Pixel 手机上运行出来是 <code>http://dl-xda.xposed.info/framework/sdk27/arm64/xposed-v90-sdk27-arm64-beta3.zip</code>，这个 url 是根据设备支持的 CPU 架构、系统版本和 Xposed 当前最新版本组合出来的，组合规则由一个 <code>framework.json</code> 提供，它的本地路径是 <code>/data/data/de.robv.android.xposed.installer/cache/framework.json</code>，是从 <code>http://dl-xda.xposed.info/framework.json</code> 解析后得到的，内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;zips&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Version 90-beta$(version)&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://dl-xda.xposed.info/framework/sdk$(sdk)/$(arch)/xposed-v90-sdk$(sdk)-$(arch)-beta$(version).zip&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;versions&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;3&quot;</span>, <span class="attr">&quot;current&quot;</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1&quot;</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;archs&quot;</span>: [<span class="string">&quot;arm&quot;</span>, <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;sdks&quot;</span> : [<span class="number">26</span>, <span class="number">27</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Version $(version)&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://dl-xda.xposed.info/framework/sdk$(sdk)/$(arch)/xposed-v$(version)-sdk$(sdk)-$(arch).zip&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;versions&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;89&quot;</span>, <span class="attr">&quot;current&quot;</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;88.2&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;88.1&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;88&quot;</span> &#125;,</span><br><span class="line">        ...</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;archs&quot;</span>: [<span class="string">&quot;arm&quot;</span>, <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;sdks&quot;</span> : [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">      <span class="attr">&quot;exclude&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;versions&quot;</span>: [<span class="string">&quot;88.1&quot;</span>],</span><br><span class="line">          <span class="attr">&quot;sdks&quot;</span>: [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;versions&quot;</span>: [<span class="string">&quot;78&quot;</span>, <span class="string">&quot;79&quot;</span>, <span class="string">&quot;80&quot;</span>, <span class="string">&quot;81&quot;</span>, <span class="string">&quot;82&quot;</span>, <span class="string">&quot;83&quot;</span>, <span class="string">&quot;84&quot;</span>, <span class="string">&quot;85&quot;</span>, <span class="string">&quot;86&quot;</span>, <span class="string">&quot;87&quot;</span>],</span><br><span class="line">          <span class="attr">&quot;sdks&quot;</span>: [<span class="number">24</span>, <span class="number">25</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Uninstaller ($(version))&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://dl-xda.xposed.info/framework/uninstaller/xposed-uninstaller-$(version)-$(arch).zip&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;uninstaller&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;versions&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;20180117&quot;</span>, <span class="attr">&quot;current&quot;</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;20180108&quot;</span> &#125;,</span><br><span class="line">        ...</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;archs&quot;</span>: [<span class="string">&quot;arm&quot;</span>, <span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;x86&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;sdks&quot;</span> : [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能看到，其中包含了 Xposed 测试版、Xposed 正式版、和 Xposed 的 Uninstaller 三种 title 的下载信息，每个下载信息中的 <code>url</code> 为下载地址的模板，<code>versions</code> 为可用的版本，根据系统信息和 Xposed 版本对 url 模板进行填充后组成下载地址。</p>
<p>回到上面的下载，下载成功后，将进入回调根据用户选择的安装类型进行安装，看一下回调的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatusInstallerFragment.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (action == ACTION_FLASH) &#123;</span><br><span class="line">    runAfterDownload = <span class="keyword">new</span> RunnableWithParam&lt;File&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 直接刷入</span></span><br><span class="line">            flash(context, <span class="keyword">new</span> FlashDirectly(file, type, title, <span class="keyword">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == ACTION_FLASH_RECOVERY) &#123;</span><br><span class="line">    runAfterDownload = <span class="keyword">new</span> RunnableWithParam&lt;File&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 依赖 recovery 模式进行刷入</span></span><br><span class="line">            flash(context, <span class="keyword">new</span> FlashRecoveryAuto(file, type, title));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == ACTION_SAVE) &#123;</span><br><span class="line">    runAfterDownload = <span class="keyword">new</span> RunnableWithParam&lt;File&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 仅保存</span></span><br><span class="line">            saveTo(context, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两个分支分别对应 <code>Install</code> 和 <code>Install via recovery</code> 两种安装方式的实现，<code>flash</code> 方法将会启动一个新的负责展示安装执行的界面，然后执行传入的 <code>Flashable</code> 对象的 <code>flash</code> 方法，执行成功后展示一个对话框，询问用户是否重启，重启后将激活 Xposed。分别看一下两种 <code>Flashable</code> 的实现。</p>
<h3 id="直接刷入"><a href="#直接刷入" class="headerlink" title="直接刷入"></a>直接刷入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlashDirectly.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flash</span><span class="params">(Context context, FlashCallback callback)</span> </span>&#123;</span><br><span class="line">    ZipCheckResult zipCheck = openAndCheckZip(callback);</span><br><span class="line">    <span class="keyword">if</span> (zipCheck == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取压缩包文件</span></span><br><span class="line">    ZipFile zip = zipCheck.getZip();</span><br><span class="line">    <span class="keyword">if</span> (!zipCheck.isFlashableInApp()) &#123;</span><br><span class="line">        triggerError(callback, FlashCallback.ERROR_NOT_FLASHABLE_IN_APP);</span><br><span class="line">        closeSilently(zip);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 update-binary 文件至 cache 目录中</span></span><br><span class="line">    ZipEntry entry = zip.getEntry(<span class="string">&quot;META-INF/com/google/android/update-binary&quot;</span>);</span><br><span class="line">    File updateBinaryFile = <span class="keyword">new</span> File(XposedApp.getInstance().getCacheDir(), <span class="string">&quot;update-binary&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AssetUtil.writeStreamToFile(zip.getInputStream(entry), updateBinaryFile, <span class="number">0700</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(XposedApp.TAG, <span class="string">&quot;Could not extract update-binary&quot;</span>, e);</span><br><span class="line">        triggerError(callback, FlashCallback.ERROR_INVALID_ZIP);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeSilently(zip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Root 身份执行刷入命令</span></span><br><span class="line">    RootUtil rootUtil = <span class="keyword">new</span> RootUtil();</span><br><span class="line">    <span class="keyword">if</span> (!rootUtil.startShell(callback)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callback.onStarted();</span><br><span class="line"></span><br><span class="line">    rootUtil.execute(<span class="string">&quot;export NO_UIPRINT=1&quot;</span>, callback);</span><br><span class="line">    <span class="keyword">if</span> (mSystemless) &#123;</span><br><span class="line">        rootUtil.execute(<span class="string">&quot;export SYSTEMLESS=1&quot;</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 update-binary 文件</span></span><br><span class="line">    <span class="keyword">int</span> result = rootUtil.execute(getShellPath(updateBinaryFile) + <span class="string">&quot; 2 1 &quot;</span> + getShellPath(mZipPath), callback);</span><br><span class="line">    <span class="keyword">if</span> (result != FlashCallback.OK) &#123;</span><br><span class="line">        triggerError(callback, result);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callback.onDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接刷入会直接使用 Root 身份执行 <code>update-binary</code> 可执行文件，其中会调用 <code>flash-script.sh</code> 文件，它将压缩包中的目录复制到对应的系统目录中，同名文件进行覆盖，在覆盖前会对原始系统文件进行备份，例如 <code>libart.so.orig.gz</code>，为了在卸载时恢复。</p>
<p>刷入后正常重启系统，系统在启动时将会加载自定义的 <code>app_process</code> 可执行文件，启动了带有 Xposed 框架代码的定制版 zygote 服务进程，为 Xposed 提供支持。</p>
<h3 id="使用-recovery-刷入"><a href="#使用-recovery-刷入" class="headerlink" title="使用 recovery 刷入"></a>使用 recovery 刷入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlashRecoveryAuto.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flash</span><span class="params">(Context context, FlashCallback callback)</span> </span>&#123;</span><br><span class="line">    ZipCheckResult zipCheck = openAndCheckZip(callback);</span><br><span class="line">    <span class="keyword">if</span> (zipCheck == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        closeSilently(zipCheck.getZip());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String zipName = mZipPath.getName();</span><br><span class="line">    String cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行刷入命令</span></span><br><span class="line">    RootUtil rootUtil = <span class="keyword">new</span> RootUtil();</span><br><span class="line">    <span class="keyword">if</span> (!rootUtil.startShell(callback)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callback.onStarted();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认 /cache/recovery/ 目录存在</span></span><br><span class="line">    <span class="keyword">if</span> (rootUtil.execute(<span class="string">&quot;ls /cache/recovery&quot;</span>, <span class="keyword">null</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        callback.onLine(context.getString(R.string.file_creating_directory, <span class="string">&quot;/cache/recovery&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (rootUtil.executeWithBusybox(<span class="string">&quot;mkdir /cache/recovery&quot;</span>, callback) != <span class="number">0</span>) &#123;</span><br><span class="line">            callback.onError(FlashCallback.ERROR_GENERIC,</span><br><span class="line">                    context.getString(R.string.file_create_directory_failed, <span class="string">&quot;/cache/recovery&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制 zip 到 /cache/recovery/ 目录</span></span><br><span class="line">    callback.onLine(context.getString(R.string.file_copying, zipName));</span><br><span class="line">    cmd = <span class="string">&quot;cp -a &quot;</span> + RootUtil.getShellPath(mZipPath) + <span class="string">&quot; /cache/recovery/&quot;</span> + zipName;</span><br><span class="line">    <span class="keyword">if</span> (rootUtil.executeWithBusybox(cmd, callback) != <span class="number">0</span>) &#123;</span><br><span class="line">        callback.onError(FlashCallback.ERROR_GENERIC,</span><br><span class="line">                context.getString(R.string.file_copy_failed, zipName, <span class="string">&quot;/cache/recovery&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将刷机命令写入 /cache/recovery/command 文件中</span></span><br><span class="line">    callback.onLine(context.getString(R.string.file_writing_recovery_command));</span><br><span class="line">    cmd = <span class="string">&quot;echo --update_package=/cache/recovery/&quot;</span> + zipName + <span class="string">&quot; &gt; /cache/recovery/command&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (rootUtil.execute(cmd, callback) != <span class="number">0</span>) &#123;</span><br><span class="line">        callback.onError(FlashCallback.ERROR_GENERIC,</span><br><span class="line">                context.getString(R.string.file_writing_recovery_command_failed));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callback.onLine(context.getString(R.string.auto_flash_note, zipName));</span><br><span class="line">    callback.onDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 recovery 模式进行刷入就是首先复制压缩包到 <code>/cache/recovery/</code> 中，然后向 <code>/cache/recovery/command</code> 文件中写入一条刷入压缩包的命令，然后询问用户是否重启至 recovery 模式，当系统处于 recovery 模式后将会自动检测 <code>command</code> 文件是否存在，如果存在将执行其中的指令，然后执行刷机包提供的脚本，过程和上面直接刷入一致，首先执行 <code>update-binary</code> 可执行文件，然后其中会调用 <code>flash-script.sh</code> 文件，将刷机包中的文件进行复制。此时，系统退出 reocvery 正常重启后将会加载成功 Xposed。</p>
<p>这里就分析完了安装，主要是通过刷入文件将系统关键组件替换为 Xposed 修改过的实现。</p>
<p>下面开始分析 Xposed 的启动，当系统启动后，init 进程将会通过解析 init.rc 文件后执行 app_process 创建 zygote 进程，此时就进入了 Xposed 重新编译修改过的 app_process 文件中。</p>
<h2 id="Xposed-启动"><a href="#Xposed-启动" class="headerlink" title="Xposed 启动"></a>Xposed 启动</h2><p>这部分的实现代码在项目 Xposed 中，是使用 C++ 代码编写的，如果这些代码出现崩溃，则会卡在开机界面，即 boot loop 情况。</p>
<p>Xposed 的 app_process 分为 Dalvik 和 ART 两种实现，这里只关注 ART 的实现，在 app_main2.cpp 中。</p>
<h3 id="Native-层"><a href="#Native-层" class="headerlink" title="Native 层"></a>Native 层</h3><p>入口为 <code>main</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app_main2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prctl</span>(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EINVAL) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;PR_SET_NO_NEW_PRIVS failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 处理 xposed 测试选项</span></span><br><span class="line">    <span class="keyword">if</span> (xposed::<span class="built_in">handleOptions</span>(argc, argv)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        runtime.<span class="built_in">addOption</span>(<span class="built_in">strdup</span>(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--nice-name=&quot;</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.<span class="built_in">setTo</span>(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.<span class="built_in">setTo</span>(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        args.<span class="built_in">add</span>(application ? <span class="built_in">String8</span>(<span class="string">&quot;application&quot;</span>) : <span class="built_in">String8</span>(<span class="string">&quot;tool&quot;</span>));</span><br><span class="line">        runtime.<span class="built_in">setClassNameAndArgs</span>(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">maybeCreateDalvikCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.<span class="built_in">add</span>(<span class="built_in">String8</span>(<span class="string">&quot;start-system-server&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">property_get</span>(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;app_process: Unable to determine ABI list from property %s.&quot;</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">&quot;--abi-list=&quot;</span>)</span></span>;</span><br><span class="line">        abiFlag.<span class="built_in">append</span>(prop);</span><br><span class="line">        args.<span class="built_in">add</span>(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.<span class="built_in">add</span>(<span class="built_in">String8</span>(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        runtime.<span class="built_in">setArgv0</span>(niceName.<span class="built_in">string</span>());</span><br><span class="line">        <span class="built_in">set_process_name</span>(niceName.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.</span></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">// 初始化 xposed</span></span><br><span class="line">        isXposedLoaded = xposed::<span class="built_in">initialize</span>(<span class="literal">true</span>, startSystemServer, <span class="literal">NULL</span>, argc, argv);</span><br><span class="line">        <span class="comment">// #define XPOSED_CLASS_DOTS_ZYGOTE &quot;de.robv.android.xposed.XposedBridge&quot;</span></span><br><span class="line">        <span class="comment">// 初始化成功则会 XposedBridge 流程，否则进入系统的 ZygoteInit 中</span></span><br><span class="line">        <span class="built_in">runtimeStart</span>(runtime, isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : <span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        <span class="comment">// 非 zygote 进程流程，用于支持使用命令行启动自定义的类，这里先不关心这个流程</span></span><br><span class="line">        isXposedLoaded = xposed::<span class="built_in">initialize</span>(<span class="literal">false</span>, <span class="literal">false</span>, className, argc, argv);</span><br><span class="line">        <span class="built_in">runtimeStart</span>(runtime, isXposedLoaded ? XPOSED_CLASS_DOTS_TOOLS : <span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">app_usage</span>();</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对比原版的 ART 代码，发现 main 函数中只有 1 和 2 两处代码进行了修改，当 init 进程解析 init.rc 文件时，会启动 zygote 进程，此时就进入了 app_process 的 main 函数中，并将 init.rc 中附带的选项使用 argv 参数传递进来。</p>
<p>先看第一处 <code>handleOptions</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xposed.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handleOptions</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">parseXposedProp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--xposedversion&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Xposed version: %s\n&quot;</span>, xposedVersion);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--xposedtestsafemode&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Testing Xposed safemode trigger\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">detectSafemodeTrigger</span>(<span class="built_in">shouldSkipSafemodeDelay</span>())) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Safemode triggered\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Safemode not triggered\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    argBlockStart = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">uintptr_t</span> start = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">uintptr_t</span> end = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(argv[argc - <span class="number">1</span>]);</span><br><span class="line">    end += <span class="built_in">strlen</span>(argv[argc - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">    argBlockLength = end - start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理了 <code>--xposedversion</code> 和 <code>--xposedtestsafemode</code> 两个参数，不过查看 init.rc 文件中启动 zygote 的选项中并没有这两项：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>所以应该是用于 Xposed 的测试代码，那么这里就不再关心。</p>
<p>继续下面第 2 部分，在 zygote 流程中，首先会初始化 Xposed，如果初始化成功就会传入 <code>XposedBridge</code> 的完整类名，用于进入 Java 层的 <code>XposedBridge</code> 入口。</p>
<p>首先看 <code>xposed::initialize</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initialize</span><span class="params">(<span class="keyword">bool</span> zygote, <span class="keyword">bool</span> startSystemServer, <span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(XPOSED_ENABLE_FOR_TOOLS)</span></span><br><span class="line">    <span class="keyword">if</span> (!zygote)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断系统是否处于 minmal framework 模式，此时 /data 是 tmpfs 类型，无法加载 Xposed</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isMinimalFramework</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;Not loading Xposed for minimal framework (encrypted device)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存相关参数</span></span><br><span class="line">    <span class="comment">// xposed 是一个用于共享信息的对象，XposedShared* xposed = new XposedShared;</span></span><br><span class="line">    xposed-&gt;zygote = zygote;</span><br><span class="line">    xposed-&gt;startSystemServer = startSystemServer;</span><br><span class="line">    xposed-&gt;startClassName = className;</span><br><span class="line">    xposed-&gt;xposedVersionInt = xposedVersionInt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> XPOSED_WITH_SELINUX</span></span><br><span class="line">    xposed-&gt;isSELinuxEnabled   = <span class="built_in">is_selinux_enabled</span>() == <span class="number">1</span>;</span><br><span class="line">    xposed-&gt;isSELinuxEnforcing = xposed-&gt;isSELinuxEnabled &amp;&amp; <span class="built_in">security_getenforce</span>() == <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    xposed-&gt;isSELinuxEnabled   = <span class="literal">false</span>;</span><br><span class="line">    xposed-&gt;isSELinuxEnforcing = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// XPOSED_WITH_SELINUX</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        xposed::logcat::<span class="built_in">printStartupMarker</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">// 给另一个架构的优先执行的 zygote 进程一些时间启动，从而避免同时打印日志，造成难以阅读</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 Xposed 版本和 Device、ROM 等信息，开机时可以在 logcat 中看到</span></span><br><span class="line">    <span class="built_in">printRomInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        <span class="comment">// 确保 XposedInstaller uid 和 gid 存在，即表示安装了 XposedInstaller</span></span><br><span class="line">        <span class="comment">// 启动 XposedService 服务</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">determineXposedInstallerUidGid</span>() || !xposed::service::<span class="built_in">startAll</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        xposed::logcat::<span class="built_in">start</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> XPOSED_WITH_SELINUX</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xposed-&gt;isSELinuxEnabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!xposed::service::<span class="built_in">startMembased</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// XPOSED_WITH_SELINUX</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> XPOSED_WITH_SELINUX</span></span><br><span class="line">    <span class="keyword">if</span> (xposed-&gt;isSELinuxEnabled) &#123;</span><br><span class="line">        xposed::service::membased::<span class="built_in">restrictMemoryInheritance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// XPOSED_WITH_SELINUX</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote &amp;&amp; !<span class="built_in">isSafemodeDisabled</span>() &amp;&amp; <span class="built_in">detectSafemodeTrigger</span>(<span class="built_in">shouldSkipSafemodeDelay</span>()))</span><br><span class="line">        <span class="built_in">disableXposed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isDisabled</span>() || (!zygote &amp;&amp; <span class="built_in">shouldIgnoreCommand</span>(argc, argv)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 XposedBridge.jar 加入系统 CLASSPATH 变量，使其代码中的类可被加载</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addJarToClasspath</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码主要是保存了 app_process 的启动选项，设置一些 xposed 支持，最后使用 <code>addJarToClasspath</code> 将 XposedBridge.jar 加入系统路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xposed.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">addJarToClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">    <span class="comment">// #define XPOSED_JAR &quot;/system/framework/XposedBridge.jar&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">access</span>(XPOSED_JAR, R_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">addPathToEnv</span>(<span class="string">&quot;CLASSPATH&quot;</span>, XPOSED_JAR))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;Added Xposed (%s) to CLASSPATH&quot;</span>, XPOSED_JAR);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;ERROR: Could not access Xposed jar &#x27;%s&#x27;&quot;</span>, XPOSED_JAR);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就初始化完成了，如果中间有一步执行失败，返回 false，那么 Xposed 就不能正常工作了，会通过传递 ZygoteInit 完整类名，进入系统正常的 zygote 流程。</p>
<p>现在回到 <code>main</code> 函数中，下面进入 <code>runtimeStart</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app_main2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runtimeStart</span><span class="params">(AppRuntime&amp; runtime, <span class="keyword">const</span> <span class="keyword">char</span> *classname, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM_SDK_VERSION &gt;= 23</span></span><br><span class="line">  runtime.<span class="built_in">start</span>(classname, options, zygote);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="comment">// try newer variant (5.1.1_r19 and later) first</span></span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*ptr1)(AppRuntime&amp;, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> Vector&lt;String8&gt;&amp;, <span class="keyword">bool</span>);</span><br><span class="line">  *(<span class="keyword">void</span> **) (&amp;ptr1) = <span class="built_in">dlsym</span>(RTLD_DEFAULT, <span class="string">&quot;_ZN7android14AndroidRuntime5startEPKcRKNS_6VectorINS_7String8EEEb&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ptr1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ptr1</span>(runtime, classname, options, zygote);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fall back to older variant</span></span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*ptr2)(AppRuntime&amp;, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> Vector&lt;String8&gt;&amp;);</span><br><span class="line">  *(<span class="keyword">void</span> **) (&amp;ptr2) = <span class="built_in">dlsym</span>(RTLD_DEFAULT, <span class="string">&quot;_ZN7android14AndroidRuntime5startEPKcRKNS_6VectorINS_7String8EEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ptr2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ptr2</span>(runtime, classname, options);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// should not happen</span></span><br><span class="line">  <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;app_process: could not locate AndroidRuntime::start() method.&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是直接调用系统 <code>AppRuntime</code> 的 <code>start</code> 函数，如果是 Android 5.1.1 之前需要通过通过获取 <code>AppRuntime::start</code> 函数符号句柄的方式调用，后面一长串字符串是函数被编译后的签名字符串。</p>
<p>调用 <code>AppRuntime::start</code> 后，内部会创建 Java 虚拟机，然后执行传入类的 <code>main</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AndroidRuntime.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ALOGD</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n&quot;</span>,</span><br><span class="line">          className != <span class="literal">NULL</span> ? className : <span class="string">&quot;(unknown)&quot;</span>, <span class="built_in">getuid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">&quot;start-system-server&quot;</span>)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  JniInvocation jni_invocation;</span><br><span class="line">  jni_invocation.<span class="built_in">Init</span>(<span class="literal">NULL</span>);</span><br><span class="line">  JNIEnv* env;</span><br><span class="line">  <span class="comment">// 创建虚拟机</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">onVmCreated</span>(env);</span><br><span class="line">  <span class="comment">// 注册系统类 JNI 方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">startReg</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 转换为 JNI 格式类名：com/android/internal/os/XposedBridge</span></span><br><span class="line">  <span class="keyword">char</span>* slashClassName = <span class="built_in">toSlashClassName</span>(className);</span><br><span class="line">  jclass startClass = env-&gt;<span class="built_in">FindClass</span>(slashClassName);</span><br><span class="line">  <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    jmethodID startMeth = env-&gt;<span class="built_in">GetStaticMethodID</span>(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">       <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">ALOGE</span>(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 XposedBridge.main();</span></span><br><span class="line">      env-&gt;<span class="built_in">CallStaticVoidMethod</span>(startClass, startMeth, strArray);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Java-层"><a href="#Java-层" class="headerlink" title="Java 层"></a>Java 层</h3><p>下面就进入到了 Java 层的 <code>XposedBridge#main</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XposedBridge.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize the Xposed framework and modules</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 native 加载成功</span></span><br><span class="line">    <span class="keyword">if</span> (!hadInitErrors()) &#123;</span><br><span class="line">      <span class="comment">// Xposed 相关初始化</span></span><br><span class="line">      initXResources();</span><br><span class="line">      <span class="comment">// SELinux 相关支持</span></span><br><span class="line">      SELinuxHelper.initOnce();</span><br><span class="line">      SELinuxHelper.initForProcess(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// runtime 表示 ART 还是 Dalivk</span></span><br><span class="line">      runtime = getRuntime();</span><br><span class="line">      XPOSED_BRIDGE_VERSION = getXposedVersion();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isZygote) &#123;</span><br><span class="line">        <span class="comment">// 为资源的 Hook 注册回调</span></span><br><span class="line">        XposedInit.hookResources();</span><br><span class="line">        <span class="comment">// 为代码 Hook 注册回调，将会调用每个 Xposed 模块的入口</span></span><br><span class="line">        XposedInit.initForZygote();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载设备上的 Xposed 模块</span></span><br><span class="line">      XposedInit.loadModules();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Not initializing Xposed because of previous errors&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;Errors during Xposed initialization&quot;</span>, t);</span><br><span class="line">    disableHooks = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用系统正常流程 Java 层</span></span><br><span class="line">  <span class="keyword">if</span> (isZygote) &#123;</span><br><span class="line">    ZygoteInit.main(args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RuntimeInit.main(args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注 <code>XposedInit.initForZygote();</code> 和 <code>XposedInit.loadModules();</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initForZygote</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// system_server 初始化</span></span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">21</span>) &#123;</span><br><span class="line">    findAndHookMethod(<span class="string">&quot;com.android.server.ServerThread&quot;</span>, <span class="keyword">null</span>,</span><br><span class="line">        Build.VERSION.SDK_INT &lt; <span class="number">19</span> ? <span class="string">&quot;run&quot;</span> : <span class="string">&quot;initAndLoop&quot;</span>, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            SELinuxHelper.initForProcess(<span class="string">&quot;android&quot;</span>);</span><br><span class="line">            loadedPackagesInProcess.add(<span class="string">&quot;android&quot;</span>);</span><br><span class="line"></span><br><span class="line">            XC_LoadPackage.LoadPackageParam lpparam = <span class="keyword">new</span> XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks);</span><br><span class="line">            lpparam.packageName = <span class="string">&quot;android&quot;</span>;</span><br><span class="line">            lpparam.processName = <span class="string">&quot;android&quot;</span>; <span class="comment">// it&#x27;s actually system_server, but other functions return this as well</span></span><br><span class="line">            lpparam.classLoader = XposedBridge.BOOTCLASSLOADER;</span><br><span class="line">            lpparam.appInfo = <span class="keyword">null</span>;</span><br><span class="line">            lpparam.isFirstApplication = <span class="keyword">true</span>;</span><br><span class="line">            XC_LoadPackage.callAll(lpparam);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  hookAllConstructors(LoadedApk.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      LoadedApk loadedApk = (LoadedApk) param.thisObject;</span><br><span class="line"></span><br><span class="line">      String packageName = loadedApk.getPackageName();</span><br><span class="line">      XResources.setPackageNameForResDir(packageName, loadedApk.getResDir());</span><br><span class="line">      <span class="keyword">if</span> (packageName.equals(<span class="string">&quot;android&quot;</span>) || !loadedPackagesInProcess.add(packageName))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!getBooleanField(loadedApk, <span class="string">&quot;mIncludeCode&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      XC_LoadPackage.LoadPackageParam lpparam = <span class="keyword">new</span> XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks);</span><br><span class="line">      lpparam.packageName = packageName;</span><br><span class="line">      lpparam.processName = AndroidAppHelper.currentProcessName();</span><br><span class="line">      lpparam.classLoader = loadedApk.getClassLoader();</span><br><span class="line">      lpparam.appInfo = loadedApk.getApplicationInfo();</span><br><span class="line">      lpparam.isFirstApplication = <span class="keyword">false</span>;</span><br><span class="line">      XC_LoadPackage.callAll(lpparam);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面省略了一部分代码，上面的代码主要是通过 Hook 系统关键类的流程，为 Xposed 模块注册加载代码包的回调，当这些系统流程执行时，会通过 <code>XC_LoadPackage.callAll(lpparm)</code> 通知所有的 Xposed 模块。</p>
<p>上面创建了 <code>XC_LoadPackage.LoadPackageParam</code> 的对象，就是为了给 Xposed 模块的入口进行传递。</p>
<p><code>XposedBridge.sLoadedPackageCallbacks</code> 是 Xposed 模块回调的集合，是一个 <code>CopyOnWriteSortedSet&lt;XC_LoadPackage&gt;</code> 类型。</p>
<p><code>XC_LoadPackage</code> 有一个 <code>call</code> 方法，用于回调自己的 <code>handleLoadPackage</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XC_LoadPackage.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Param param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (param <span class="keyword">instanceof</span> LoadPackageParam)</span><br><span class="line">    handleLoadPackage((LoadPackageParam) param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XC_LoadPackage.callAll</code> 将会调用每一个 <code>XC_LoadPackage</code> 的 call 方法，从而向 Xposed 模块传递 <code>lpparm</code> 参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XC_LoadPackage.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callAll</span><span class="params">(Param param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (param.callbacks == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This object was not created for use with callAll&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; param.callbacks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ((XCallback) param.callbacks[i]).call(param);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123; XposedBridge.log(t); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Xposed-模块加载"><a href="#Xposed-模块加载" class="headerlink" title="Xposed 模块加载"></a>Xposed 模块加载</h3><p>再来看 <code>XposedInit.loadModules();</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XposedInit.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*package*/</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadModules</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 从 modules.list 文件读取 Xposde 模块列表</span></span><br><span class="line">  <span class="keyword">final</span> String filename = BASE_DIR + <span class="string">&quot;conf/modules.list&quot;</span>;</span><br><span class="line">  BaseService service = SELinuxHelper.getAppDataFileService();</span><br><span class="line">  <span class="keyword">if</span> (!service.checkFileExists(filename)) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;Cannot load any modules because &quot;</span> + filename + <span class="string">&quot; was not found&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ClassLoader topClassLoader = XposedBridge.BOOTCLASSLOADER;</span><br><span class="line">  ClassLoader parent;</span><br><span class="line">  <span class="keyword">while</span> ((parent = topClassLoader.getParent()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    topClassLoader = parent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  InputStream stream = service.getFileInputStream(filename);</span><br><span class="line">  BufferedReader apks = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(stream));</span><br><span class="line">  String apk;</span><br><span class="line">  <span class="keyword">while</span> ((apk = apks.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 加载每个 Xposed 模块</span></span><br><span class="line">    loadModule(apk, topClassLoader);</span><br><span class="line">  &#125;</span><br><span class="line">  apks.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XposedInit.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadModule</span><span class="params">(String apk, ClassLoader topClassLoader)</span> </span>&#123;</span><br><span class="line">  Log.i(TAG, <span class="string">&quot;Loading modules from &quot;</span> + apk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  DexFile dexFile;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    dexFile = <span class="keyword">new</span> DexFile(apk);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;  Cannot load module&quot;</span>, e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  ZipFile zipFile = <span class="keyword">null</span>;</span><br><span class="line">  InputStream is;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    zipFile = <span class="keyword">new</span> ZipFile(apk);</span><br><span class="line">    <span class="comment">// 打开 Xposed 模块 apk 文件中的 xposed_init 文件，</span></span><br><span class="line">    <span class="comment">// 它的内容是 Xposed 模块入口类的全类名</span></span><br><span class="line">    ZipEntry zipEntry = zipFile.getEntry(<span class="string">&quot;assets/xposed_init&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (zipEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;  assets/xposed_init not found in the APK&quot;</span>);</span><br><span class="line">      closeSilently(zipFile);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    is = zipFile.getInputStream(zipEntry);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;  Cannot read assets/xposed_init in the APK&quot;</span>, e);</span><br><span class="line">    closeSilently(zipFile);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ClassLoader mcl = <span class="keyword">new</span> PathClassLoader(apk, XposedBridge.BOOTCLASSLOADER);</span><br><span class="line">  BufferedReader moduleClassesReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String moduleClassName;</span><br><span class="line">    <span class="comment">// 获取 Xposed 模块入口类名</span></span><br><span class="line">    <span class="keyword">while</span> ((moduleClassName = moduleClassesReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      moduleClassName = moduleClassName.trim();</span><br><span class="line">      <span class="keyword">if</span> (moduleClassName.isEmpty() || moduleClassName.startsWith(<span class="string">&quot;#&quot;</span>))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;  Loading class &quot;</span> + moduleClassName);</span><br><span class="line">        <span class="comment">// 加载入口类</span></span><br><span class="line">        Class&lt;?&gt; moduleClass = mcl.loadClass(moduleClassName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object moduleInstance = moduleClass.newInstance();</span><br><span class="line">        <span class="keyword">if</span> (XposedBridge.isZygote) &#123;</span><br><span class="line">          <span class="keyword">if</span> (moduleInstance <span class="keyword">instanceof</span> IXposedHookZygoteInit) &#123;</span><br><span class="line">            IXposedHookZygoteInit.StartupParam param = <span class="keyword">new</span> IXposedHookZygoteInit.StartupParam();</span><br><span class="line">            param.modulePath = apk;</span><br><span class="line">            param.startsSystemServer = startsSystemServer;</span><br><span class="line">            ((IXposedHookZygoteInit) moduleInstance).initZygote(param);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 根据模块关心代码 Hook 还是资源 Hook 分别处理</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (moduleInstance <span class="keyword">instanceof</span> IXposedHookLoadPackage)</span><br><span class="line">            <span class="comment">// 注册到 sLoadedPackageCallbacks 中</span></span><br><span class="line">            XposedBridge.hookLoadPackage(<span class="keyword">new</span> IXposedHookLoadPackage.Wrapper((IXposedHookLoadPackage) moduleInstance));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (moduleInstance <span class="keyword">instanceof</span> IXposedHookInitPackageResources)</span><br><span class="line">            <span class="comment">// 注册资源的 Xposed 模块回调</span></span><br><span class="line">            XposedBridge.hookInitPackageResources(<span class="keyword">new</span> IXposedHookInitPackageResources.Wrapper((IXposedHookInitPackageResources) moduleInstance));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;    Failed to load class &quot;</span> + moduleClassName, t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;  Failed to load module from &quot;</span> + apk, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeSilently(is);</span><br><span class="line">    closeSilently(zipFile);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码首先从 <code>conf/modules.list</code> 文件加载所有 Xposed 模块的 APK 路径列表，然后通过读取每一个 Xposed 模块 APK 包中的 <code>assets/xposed_init</code> 文件获得 Xposed 模块的入口类名，最后将这个类通过 <code>XposedBridge.hookLoadPackage</code> 注册到前面的 <code>XposedBridge.sLoadedPackageCallbacks</code> 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XposedBridge.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookLoadPackage</span><span class="params">(XC_LoadPackage callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (sLoadedPackageCallbacks) &#123;</span><br><span class="line">    sLoadedPackageCallbacks.add(callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当前面 Hook 的系统关键类流程被触发后，将会通过 <code>sLoadedPackageCallbacks</code> 回调每个 Xposed 模块的入口。</p>
<p>到这里 Xposed 模块的启动的核心逻辑就分析完了，主要是通过 Xposed 定制版的 zygote 加载 XposedBridge.jar，然后调用 <code>XposedBridge#main</code> 方法加载所有的 Xposed 模块，当一个进程通过 zygote 进程 clone 出来时，就会携带 XposedBridge.jar 的代码，同时在进程启动时回调所有的 Xposed 模块的入口，XposedBridge.jar 中还包含 Hook API，那么 Xposed 模块就可以通过这些 API 对应用程序进行 Hook 操作了。</p>
<p>接下来就是 Xposed 的方法 Hook 的实现代码分析了。</p>
<h2 id="Xposed-方法-Hook"><a href="#Xposed-方法-Hook" class="headerlink" title="Xposed 方法 Hook"></a>Xposed 方法 Hook</h2><p>从 <code>XposedHelpers.findAndHookMethod</code> 方法开始，看 Xposed 是如何进行 Hook 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XposedHelpers.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> XC_MethodHook.<span class="function">Unhook <span class="title">findAndHookMethod</span><span class="params">(Class&lt;?&gt; clazz, String methodName, Object... parameterTypesAndCallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parameterTypesAndCallback.length == <span class="number">0</span> || !(parameterTypesAndCallback[parameterTypesAndCallback.length-<span class="number">1</span>] <span class="keyword">instanceof</span> XC_MethodHook))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;no callback defined&quot;</span>);</span><br><span class="line"></span><br><span class="line">  XC_MethodHook callback = (XC_MethodHook) parameterTypesAndCallback[parameterTypesAndCallback.length-<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 获取方法的反射表示对象</span></span><br><span class="line">  Method m = findMethodExact(clazz, methodName, getParameterClasses(clazz.getClassLoader(), parameterTypesAndCallback));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一步</span></span><br><span class="line">  <span class="keyword">return</span> XposedBridge.hookMethod(m, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先使用 <code>findMethodExact</code> 获取一个 Java 方法的反射表示对象 <code>m</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XposedHelpers.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title">findMethodExact</span><span class="params">(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes)</span> </span>&#123;</span><br><span class="line">  String fullMethodName = clazz.getName() + <span class="string">&#x27;#&#x27;</span> + methodName + getParametersString(parameterTypes) + <span class="string">&quot;#exact&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (methodCache.containsKey(fullMethodName)) &#123;</span><br><span class="line">    <span class="comment">// 首先从缓存中取</span></span><br><span class="line">    Method method = methodCache.get(fullMethodName);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(fullMethodName);</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 通过反射 API 取得 Method 对象</span></span><br><span class="line">    Method method = clazz.getDeclaredMethod(methodName, parameterTypes);</span><br><span class="line">    method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    methodCache.put(fullMethodName, method);</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    methodCache.put(fullMethodName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(fullMethodName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也很简单，使用了缓存保存方法的反射对象，然后继续下一步，进入 <code>XposedBridge#hookMethod</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XposedBridge.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> XC_MethodHook.<span class="function">Unhook <span class="title">hookMethod</span><span class="params">(Member hookMethod, XC_MethodHook callback)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 只允许 Method 和 Constructor 类型，Constructor 类型为了支持 findAndHookConstructor</span></span><br><span class="line">  <span class="keyword">if</span> (!(hookMethod <span class="keyword">instanceof</span> Method) &amp;&amp; !(hookMethod <span class="keyword">instanceof</span> Constructor&lt;?&gt;)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Only methods and constructors can be hooked: &quot;</span> + hookMethod.toString());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hookMethod.getDeclaringClass().isInterface()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot hook interfaces: &quot;</span> + hookMethod.toString());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Modifier.isAbstract(hookMethod.getModifiers())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot hook abstract methods: &quot;</span> + hookMethod.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> newMethod = <span class="keyword">false</span>;</span><br><span class="line">  CopyOnWriteSortedSet&lt;XC_MethodHook&gt; callbacks;</span><br><span class="line">  <span class="keyword">synchronized</span> (sHookedMethodCallbacks) &#123;</span><br><span class="line">    callbacks = sHookedMethodCallbacks.get(hookMethod);</span><br><span class="line">    <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建 method 与 hook 回调列表关联的映射表</span></span><br><span class="line">      callbacks = <span class="keyword">new</span> CopyOnWriteSortedSet&lt;&gt;();</span><br><span class="line">      sHookedMethodCallbacks.put(hookMethod, callbacks);</span><br><span class="line">      newMethod = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加 hook 回调到和这个 method 关联的 hook 回调列表</span></span><br><span class="line">  callbacks.add(callback);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dnewMethod) &#123;</span><br><span class="line">    Clss&lt;?&gt; declaringClass = hookMethod.getDeclaringClass();</span><br><span class="line">    <span class="keyword">int</span> slot;</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">    Class&lt;?&gt; returnType;</span><br><span class="line">    <span class="keyword">if</span> (runtime == RUNTIME_ART) &#123;</span><br><span class="line">      slot = <span class="number">0</span>;</span><br><span class="line">      parameterTypes = <span class="keyword">null</span>;</span><br><span class="line">      returnType = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hookMethod <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">      <span class="comment">// slot 在 Android 5.0 以下的系统，java.reflect.Method 类中的成员，</span></span><br><span class="line">      <span class="comment">// 它是 Dralvik 虚拟机中这个 Method 在虚拟机中的地址。</span></span><br><span class="line">      <span class="comment">// Android 5.0 开始正式使用了 ART 虚拟机，所以不存在这个成员</span></span><br><span class="line">      slot = getIntField(hookMethod, <span class="string">&quot;slot&quot;</span>);</span><br><span class="line">      parameterTypes = ((Method) hookMethod).getParameterTypes();</span><br><span class="line">      returnType = ((Method) hookMethod).getReturnType();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 处理 Constructor</span></span><br><span class="line">      slot = getIntField(hookMethod, <span class="string">&quot;slot&quot;</span>);</span><br><span class="line">      parameterTypes = ((Constructor&lt;?&gt;) hookMethod).getParameterTypes();</span><br><span class="line">      returnType = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打包 Hook 回调相关信息，准备进入 Native 层</span></span><br><span class="line">    AdditionalHookInfo additionalInfo = <span class="keyword">new</span> AdditionalHookInfo(callbacks, parameterTypes, returnType);</span><br><span class="line">    <span class="comment">// 进入 Native 层代码，传入 method、class、slot、hook 回调等信息</span></span><br><span class="line">    hookMethodNative(hookMethod, declaringClass, slot, additionalInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> callback.<span class="function">new <span class="title">Unhook</span><span class="params">(hookMethod)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面主要是添加了 <code>XC_MethodHook</code> 类型的 Hook 回调，然后将相关信息全部传入了 Xposed native 层代码中。</p>
<p>最后返回一个 Unhook 对象，是为了取消 Hook，它的 <code>unhook</code> 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XC_MethodHook.java - class Unhook</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unhook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  XposedBridge.unhookMethod(hookMethod, XC_MethodHook.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XposedBridge.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unhookMethod</span><span class="params">(Member hookMethod, XC_MethodHook callback)</span> </span>&#123;</span><br><span class="line">  CopyOnWriteSortedSet&lt;XC_MethodHook&gt; callbacks;</span><br><span class="line">  <span class="keyword">synchronized</span> (sHookedMethodCallbacks) &#123;</span><br><span class="line">    callbacks = sHookedMethodCallbacks.get(hookMethod);</span><br><span class="line">    <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  callbacks.remove(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是直接移除与这个 Java 方法相关的 Hook 处理回调。</p>
<p>下面查看 <code>hookMethodNative</code> 函数的实现，发现它是一个 JNI 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private native synchronized static void hookMethodNative(Member method, Class&lt;?&gt; declaringClass, int slot, Object additionalInfo);</span><br></pre></td></tr></table></figure>

<p>它的实现在 <code>libxposed_art.so</code> 中，源代码在 Xposed 项目中。</p>
<p>首先需要解决一个问题，这个动态库是什么时候加载的，它的 JNI 方法和 Java 层是什么时候关联的？</p>
<p>它是在 Java 虚拟机中创建时加载的，同时关联的 JNI 方法。</p>
<p>在 app_main2.cpp 中，Xposed 除了改写 <code>app_process</code> 的 <code>main</code> 函数，还改写了 <code>AppRuntime::onVmCreated</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app_main2.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppRuntime</span> :</span> <span class="keyword">public</span> AndroidRuntime</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onVmCreated</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isXposedLoaded)</span><br><span class="line">            xposed::<span class="built_in">onVmCreated</span>(env);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mClassName.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>* slashClassName = <span class="built_in">toSlashClassName</span>(mClassName.<span class="built_in">string</span>());</span><br><span class="line">        mClass = env-&gt;<span class="built_in">FindClass</span>(slashClassName);</span><br><span class="line">        <span class="keyword">if</span> (mClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;ERROR: could not find class &#x27;%s&#x27;\n&quot;</span>, mClassName.<span class="built_in">string</span>());</span><br><span class="line">            env-&gt;<span class="built_in">ExceptionDescribe</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">        mClass = <span class="keyword">reinterpret_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(mClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>回顾前面的内容，这个函数将在 Java 虚拟机创建后被回调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AndroidRuntime.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 回调 Java 虚拟机创建</span></span><br><span class="line">  <span class="built_in">onVmCreated</span>(env);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">startReg</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 <code>xposed::onVmCreated</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xposed.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onVmCreated</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* xposedLibPath = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 首先确认 Xposed 库的路径是 ART 还是 Dalvik</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">determineRuntime</span>(&amp;xposedLibPath)) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not determine runtime, not loading Xposed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 Xposed 动态库</span></span><br><span class="line">    <span class="keyword">void</span>* xposedLibHandle = <span class="built_in">dlopen</span>(xposedLibPath, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (!xposedLibHandle) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not load libxposed: %s&quot;</span>, <span class="built_in">dlerror</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dlerror</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用初始化方法</span></span><br><span class="line">    <span class="built_in"><span class="keyword">bool</span></span> (*xposedInitLib)(XposedShared* shared) = <span class="literal">NULL</span>;</span><br><span class="line">    *(<span class="keyword">void</span> **) (&amp;xposedInitLib) = <span class="built_in">dlsym</span>(xposedLibHandle, <span class="string">&quot;xposedInitLib&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!xposedInitLib)  &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not find function xposedInitLib&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> XPOSED_WITH_SELINUX</span></span><br><span class="line">    xposed-&gt;zygoteservice_accessFile = &amp;service::membased::accessFile;</span><br><span class="line">    xposed-&gt;zygoteservice_statFile   = &amp;service::membased::statFile;</span><br><span class="line">    xposed-&gt;zygoteservice_readFile   = &amp;service::membased::readFile;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// XPOSED_WITH_SELINUX</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xposedInitLib</span>(xposed)) &#123;</span><br><span class="line">        <span class="comment">// 调用绑定的 onVmCreated 回调函数</span></span><br><span class="line">        xposed-&gt;<span class="built_in">onVmCreated</span>(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是 <code>determineRuntime</code> 确认 Xposed 的库路径：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xposed.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">determineRuntime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** xposedLibPath)</span> </span>&#123;</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not open /proc/self/maps: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(line, <span class="built_in"><span class="keyword">sizeof</span></span>(line), fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>* libname = <span class="built_in">strrchr</span>(line, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!libname)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        libname++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;libdvm.so\n&quot;</span>, libname) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGI</span>(<span class="string">&quot;Detected Dalvik runtime&quot;</span>);</span><br><span class="line">            <span class="comment">// #define XPOSED_LIB_DALVIK POSED_LIB_DIR &quot;libxposed_dalvik.so&quot;</span></span><br><span class="line">            *xposedLibPath = XPOSED_LIB_DALVIK;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;libart.so\n&quot;</span>, libname) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGI</span>(<span class="string">&quot;Detected ART runtime&quot;</span>);</span><br><span class="line">            <span class="comment">// #define XPOSED_LIB_ART XPOSED_LIB_DIR &quot;libxposed_art.so&quot;</span></span><br><span class="line">            *xposedLibPath = XPOSED_LIB_ART;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据系统中是否存在 <code>libdvm.so</code> 或 <code>libart.so</code>，确认加载支持 ART 还是 Dalvik 版本的 Xposed 库，在 ART 上加载 <code>libxposed_art.so</code>。</p>
<p>然后使用 <code>dlopen</code> 加载链接了这个动态库，那么它的符号就可以被正常访问了。</p>
<p>后面又调用了 <code>xposedInitLib</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libxposed_art.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">xposedInitLib</span><span class="params">(XposedShared* shared)</span> </span>&#123;</span><br><span class="line">    xposed = shared;</span><br><span class="line">    xposed-&gt;onVmCreated = &amp;onVmCreatedCommon;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定了一个 <code>xposed-&gt;onVmCreated</code> 为 <code>onVmCreatedCommon</code>，看一下它的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libxposed_common.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onVmCreatedCommon</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">initXposedBridge</span>(env) || !<span class="built_in">initZygoteService</span>(env)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">onVmCreated</span>(env)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xposedLoadedSuccessfully = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要关注 <code>initXposedBridge</code>，它会进行 JNI 方法的注册。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libxposed_common.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initXposedBridge</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// #define CLASS_XPOSED_BRIDGE  &quot;de/robv/android/xposed/XposedBridge&quot;</span></span><br><span class="line">    classXposedBridge = env-&gt;<span class="built_in">FindClass</span>(CLASS_XPOSED_BRIDGE);</span><br><span class="line">    <span class="keyword">if</span> (classXposedBridge == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Error while loading Xposed class &#x27;%s&#x27;:&quot;</span>, CLASS_XPOSED_BRIDGE);</span><br><span class="line">        <span class="built_in">logExceptionStackTrace</span>();</span><br><span class="line">        env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    classXposedBridge = <span class="keyword">reinterpret_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(classXposedBridge));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;Found Xposed class &#x27;%s&#x27;, now initializing&quot;</span>, CLASS_XPOSED_BRIDGE);</span><br><span class="line">    <span class="comment">// 注册 XposedBridge 关联的 JNI 方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">register_natives_XposedBridge</span>(env, classXposedBridge) != JNI_OK) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not register natives for &#x27;%s&#x27;&quot;</span>, CLASS_XPOSED_BRIDGE);</span><br><span class="line">        <span class="built_in">logExceptionStackTrace</span>();</span><br><span class="line">        env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存 XposedBridge 的 handleHookedMethod 方法的 jmethodID</span></span><br><span class="line">    methodXposedBridgeHandleHookedMethod = env-&gt;<span class="built_in">GetStaticMethodID</span>(classXposedBridge, <span class="string">&quot;handleHookedMethod&quot;</span>,</span><br><span class="line">        <span class="string">&quot;(Ljava/lang/reflect/Member;ILjava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (methodXposedBridgeHandleHookedMethod == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;ERROR: could not find method %s.handleHookedMethod(Member, int, Object, Object, Object[])&quot;</span>, CLASS_XPOSED_BRIDGE);</span><br><span class="line">        <span class="built_in">logExceptionStackTrace</span>();</span><br><span class="line">        env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libxposed_common.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_natives_XposedBridge</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, hadInitErrors, <span class="string">&quot;()Z&quot;</span>),</span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, getStartClassName, <span class="string">&quot;()Ljava/lang/String;&quot;</span>),</span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, getRuntime, <span class="string">&quot;()I&quot;</span>),</span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, startsSystemServer, <span class="string">&quot;()Z&quot;</span>),</span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, getXposedVersion, <span class="string">&quot;()I&quot;</span>),</span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, initXResourcesNative, <span class="string">&quot;()Z&quot;</span>),</span><br><span class="line">        <span class="comment">// 注册 hookMethodNative 方法</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, hookMethodNative, <span class="string">&quot;(Ljava/lang/reflect/Member;Ljava/lang/Class;ILjava/lang/Object;)V&quot;</span>),</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">RegisterNatives</span>(clazz, methods, <span class="built_in">NELEM</span>(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>NATIVE_METHOD</code> 是一个宏，方便注册 JNI 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libxposed_common.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NATIVE_METHOD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NATIVE_METHOD(className, functionName, signature) \</span></span><br><span class="line"><span class="meta">  &#123; #functionName, signature, reinterpret_cast<span class="meta-string">&lt;void*&gt;</span>(className ## _ ## functionName) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>现在回去，对 <code>hookMethodNative</code> 的具体实现进行分析，从这里开始就是真正开始实现方法 Hook 了。</p>
<p>由于这里是 Xposed 方法 Hook 的核心实现，所以同时分析一下基于 Dalvik 的实现。</p>
<h3 id="Dalvik-Hook-实现"><a href="#Dalvik-Hook-实现" class="headerlink" title="Dalvik Hook 实现"></a>Dalvik Hook 实现</h3><p>首先看一下 <code>libxposed_dalvik.so</code> 中的实现，验证一下本文开头基于 Dalvik 的方法 Hook 的描述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libxposed_dalvik.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XposedBridge_hookMethodNative</span><span class="params">(JNIEnv* env, jclass clazz, jobject reflectedMethodIndirect,</span></span></span><br><span class="line"><span class="params"><span class="function">            jobject declaredClassIndirect, jint slot, jobject additionalInfoIndirect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (declaredClassIndirect == <span class="literal">NULL</span> || reflectedMethodIndirect == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">dvmThrowIllegalArgumentException</span>(<span class="string">&quot;method and declaredClass must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Dalvik 中表示 Java 类的 ClassObject 对象</span></span><br><span class="line">    ClassObject* declaredClass = (ClassObject*) <span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), declaredClassIndirect);</span><br><span class="line">    <span class="comment">// 利用 slot 变量从 ClassObject 中找到 Dalvik 中表示 Java 方法的 Method 对象</span></span><br><span class="line">    Method* method = <span class="built_in">dvmSlotToMethod</span>(declaredClass, slot);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">dvmThrowNoSuchMethodError</span>(<span class="string">&quot;Could not get internal representation for method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inline bool isMethodHooked(const Method* method) &#123;</span></span><br><span class="line">    <span class="comment">//   return (method-&gt;nativeFunc == &amp;hookedMethodCallback);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isMethodHooked</span>(method)) &#123;</span><br><span class="line">        <span class="comment">// 此方法已经被 Hook，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原始方法的信息</span></span><br><span class="line">    XposedHookInfo* hookInfo = (XposedHookInfo*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(XposedHookInfo));</span><br><span class="line">    <span class="built_in">memcpy</span>(hookInfo, method, <span class="built_in"><span class="keyword">sizeof</span></span>(hookInfo-&gt;originalMethodStruct));</span><br><span class="line">    hookInfo-&gt;reflectedMethod = <span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), env-&gt;<span class="built_in">NewGlobalRef</span>(reflectedMethodIndirect));</span><br><span class="line">    hookInfo-&gt;additionalInfo = <span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), env-&gt;<span class="built_in">NewGlobalRef</span>(additionalInfoIndirect));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此 Java 方法增加 native 描述符，即 JNI 方法</span></span><br><span class="line">    <span class="built_in">SET_METHOD_FLAG</span>(method, ACC_NATIVE);</span><br><span class="line">    <span class="comment">// 设置 native 函数的处理函数，那么 Dalvik 解释执行这个方法时，</span></span><br><span class="line">    <span class="comment">// 首先判断会它是 JNI 方法，然后会跳转至 nativeFunc 进行执行</span></span><br><span class="line">    method-&gt;nativeFunc = &amp;hookedMethodCallback;</span><br><span class="line">    method-&gt;insns = (<span class="keyword">const</span> u2*) hookInfo;</span><br><span class="line">    method-&gt;registersSize = method-&gt;insSize;</span><br><span class="line">    method-&gt;outsSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PTR_gDvmJit != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> currentValue = *((<span class="keyword">char</span>*)PTR_gDvmJit + <span class="built_in">MEMBER_OFFSET_VAR</span>(DvmJitGlobals,codeCacheFull));</span><br><span class="line">        <span class="keyword">if</span> (currentValue == <span class="number">0</span> || currentValue == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">MEMBER_VAL</span>(PTR_gDvmJit, DvmJitGlobals, codeCacheFull) = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Unexpected current value for codeCacheFull: %d&quot;</span>, currentValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 Xposed 基于 Dalvik 实现的方法 Hook 处理比较简单，就是先将这个 Java 方法修改为 native 方法，然后给它绑定一个 <code>nativeFunc</code>，当 Java 代码调用这个方法时，由于它是 JNI 方法，虚拟机就会跳转到 <code>nativeFunc</code> 进行执行。</p>
<p>Dalvik 虚拟机执行 Java 方法的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stack.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dvmCallMethodV</span><span class="params">(Thread* self, <span class="keyword">const</span> Method* method, Object* obj, <span class="keyword">bool</span> fromJni, JValue* pResult, va_list args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">dvmIsNativeMethod</span>(method)) &#123;</span><br><span class="line">    <span class="built_in">TRACE_METHOD_ENTER</span>(self, method);</span><br><span class="line">    <span class="comment">// 如果是 native 方法，则跳转 nativeFunc 进行执行</span></span><br><span class="line">    (*method-&gt;nativeFunc)((u4*)self-&gt;interpSave.curFrame, pResult, method, self);</span><br><span class="line">    <span class="built_in">TRACE_METHOD_EXIT</span>(self, method);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">dvmInterpret</span>(self, method, pResult);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.h</span></span><br><span class="line"></span><br><span class="line"><span class="function">INLINE <span class="keyword">bool</span> <span class="title">dvmIsNativeMethod</span><span class="params">(<span class="keyword">const</span> Method* method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (method-&gt;accessFlags &amp; ACC_NATIVE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果一个方法是 JNI 方法，那么 Dalvik 虚拟机就会调用它绑定的 <code>nativeFunc</code> 函数。</p>
<p>前面设置的 <code>hookedMethodCallback</code> 函数将会把被调用的 Java 方法的参数进行转发，最终会调用 Java 层 <code>XposedBridge</code> 的 <code>handleHookedMethod</code> 方法进行处理，就能够达到 Hook 的目的了，至于 <code>hookedMethodCallback</code> 函数的实现，这里不再详细分析，可以自己看一下。Java 层 <code>handleHookedMethod</code> 方法的实现和 ART 没有区别，都是在 XposedBridge.jar 中，在下面 ART 部分中会进行分析。</p>
<p>下面进入 <code>libxposed_art.so</code> 中的 <code>hookMethodNative</code> 函数实现：</p>
<h3 id="ART-Hook-实现"><a href="#ART-Hook-实现" class="headerlink" title="ART Hook 实现"></a>ART Hook 实现</h3><p>接下来关注 <code>libxposed_art.so</code> 中的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libxposed_art.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XposedBridge_hookMethodNative</span><span class="params">(JNIEnv* env, jclass, jobject javaReflectedMethod,</span></span></span><br><span class="line"><span class="params"><span class="function">            jobject, jint, jobject javaAdditionalInfo)</span> </span>&#123;</span><br><span class="line">    <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (javaReflectedMethod == nullptr) &#123;</span><br><span class="line">#<span class="keyword">if</span> PLATFORM_SDK_VERSION &gt;= <span class="number">23</span></span><br><span class="line">        ThrowIllegalArgumentException(<span class="string">&quot;method must not be null&quot;</span>);</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">        ThrowIllegalArgumentException(nullptr, <span class="string">&quot;method must not be null&quot;</span>);</span><br><span class="line">#endif</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ART 虚拟机中表示 Java 方法的 artMethod 对象</span></span><br><span class="line">    ArtMethod* artMethod = ArtMethod::FromReflectedMethod(soa, javaReflectedMethod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fHook 这个方法</span></span><br><span class="line">    artMethod-&gt;EnableXposedHook(soa, javaAdditionalInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用 Java 层方法的反射表示对象 <code>javaReflectedMethod</code>，获取了一个 ART 虚拟机中用来表示 Java 方法的 <code>ArtMethod</code> 对象，然后就直接进入 <code>ArtMethod</code> 的 <code>EnableXposedHook</code> 函数中了。</p>
<p>其中 <code>FromReflectedMethod</code> 是 ART 虚拟机本来就有的方法；<code>ScopedObjectAccess</code> 是一个工具类，需要借助 <code>env</code> 进行操作。</p>
<p>下面进入 <code>ArtMethod</code> 的 <code>EnableXposedHook</code> 函数中，从这里开始就进入 Xposed 修改过的 ART 虚拟机的项目 android_art 中了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// art_method.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::EnableXposedHook</span><span class="params">(ScopedObjectAccess&amp; soa, jobject additional_info)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(<span class="built_in">IsXposedHookedMethod</span>())) &#123;</span><br><span class="line">    <span class="comment">// 已被 Hook</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(<span class="built_in">IsXposedOriginalMethod</span>())) &#123;</span><br><span class="line">    <span class="comment">// 是用于备份的 ArtMethod 对象，通常不应该走到这</span></span><br><span class="line">    <span class="built_in">ThrowIllegalArgumentException</span>(<span class="built_in">StringPrintf</span>(<span class="string">&quot;Cannot hook the method backup: %s&quot;</span>, <span class="built_in">PrettyMethod</span>(<span class="keyword">this</span>).<span class="built_in">c_str</span>()).<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 ClassLinker，它是链接器</span></span><br><span class="line">  <span class="keyword">auto</span>* cl = Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetClassLinker</span>();</span><br><span class="line">  <span class="comment">// 获取线性分配器，用于分配内存，类似于 malloc </span></span><br><span class="line">  <span class="keyword">auto</span>* linear_alloc = cl-&gt;<span class="built_in">GetAllocatorForClassLoader</span>(<span class="built_in">GetClassLoader</span>());</span><br><span class="line">  <span class="comment">// 创建一个新的 ArtMethod 对象，用于备份原始方法</span></span><br><span class="line">  ArtMethod* backup_method = cl-&gt;<span class="built_in">CreateRuntimeMethod</span>(linear_alloc);</span><br><span class="line">  <span class="comment">// 复制当前 ArtMethod 至 backup_method</span></span><br><span class="line">  backup_method-&gt;<span class="built_in">CopyFrom</span>(<span class="keyword">this</span>, cl-&gt;<span class="built_in">GetImagePointerSize</span>());</span><br><span class="line">  <span class="comment">// 添加 kAccXposedOriginalMethod 标记，说明是备份的方法</span></span><br><span class="line">  backup_method-&gt;<span class="built_in">SetAccessFlags</span>(backup_method-&gt;<span class="built_in">GetAccessFlags</span>() | kAccXposedOriginalMethod);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建备份方法对应的反射对象</span></span><br><span class="line">  mirror::AbstractMethod* reflected_method;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsConstructor</span>()) &#123;</span><br><span class="line">    reflected_method = mirror::Constructor::<span class="built_in">CreateFromArtMethod</span>(soa.<span class="built_in">Self</span>(), backup_method);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reflected_method = mirror::Method::<span class="built_in">CreateFromArtMethod</span>(soa.<span class="built_in">Self</span>(), backup_method);</span><br><span class="line">  &#125;</span><br><span class="line">  reflected_method-&gt;SetAccessible&lt;<span class="literal">false</span>&gt;(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将备份的方法和一路从 Java 层传过来的 additional_info（包含处理 Hook 的回调）装到 XposedHookInfo 对象中</span></span><br><span class="line">  XposedHookInfo* hook_info = <span class="keyword">reinterpret_cast</span>&lt;XposedHookInfo*&gt;(linear_alloc-&gt;<span class="built_in">Alloc</span>(soa.<span class="built_in">Self</span>(), <span class="built_in"><span class="keyword">sizeof</span></span>(XposedHookInfo)));</span><br><span class="line">  hook_info-&gt;reflected_method = soa.<span class="built_in">Vm</span>()-&gt;<span class="built_in">AddGlobalRef</span>(soa.<span class="built_in">Self</span>(), reflected_method);</span><br><span class="line">  hook_info-&gt;additional_info = soa.<span class="built_in">Env</span>()-&gt;<span class="built_in">NewGlobalRef</span>(additional_info);</span><br><span class="line">  hook_info-&gt;original_method = backup_method;</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedThreadSuspension <span class="title">sts</span><span class="params">(soa.Self(), kSuspended)</span></span>;</span><br><span class="line">  jit::ScopedJitSuspend sjs;</span><br><span class="line">  <span class="function">gc::ScopedGCCriticalSection <span class="title">gcs</span><span class="params">(soa.Self(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                  gc::kGcCauseXposed,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  gc::kCollectorTypeXposed)</span></span>;</span><br><span class="line">  <span class="function">ScopedSuspendAll <span class="title">ssa</span><span class="params">(__FUNCTION__)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除本方法的调用者信息</span></span><br><span class="line">  cl-&gt;<span class="built_in">InvalidateCallersForMethod</span>(soa.<span class="built_in">Self</span>(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  jit::Jit* jit = art::Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetJit</span>();</span><br><span class="line">  <span class="keyword">if</span> (jit != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 将本方法的 CodeCache 中的内容移动到备份方法对象中</span></span><br><span class="line">    <span class="comment">// CodeCache 就是从 Dex 文件中解析到的类和方法的相关信息，</span></span><br><span class="line">    <span class="comment">// 缓存起来，方便直接取用，而不是每次都解析 Dex 文件</span></span><br><span class="line">    jit-&gt;<span class="built_in">GetCodeCache</span>()-&gt;<span class="built_in">MoveObsoleteMethod</span>(<span class="keyword">this</span>, backup_method);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 hook_info 保存在用于原本用于存储 JNI 方法的内存地址上 </span></span><br><span class="line">  <span class="built_in">SetEntryPointFromJniPtrSize</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(hook_info), <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*));</span><br><span class="line">  <span class="comment">// 设置此方法对应的汇编代码的地址，一个 Java 方法经过编译器编译后会对应一段汇编代码，</span></span><br><span class="line">  <span class="comment">// 当虚拟机执行这个 Java 方法时，如果处于 AOT 模式，就会直接跳转到汇编代码执行机器指令</span></span><br><span class="line">  <span class="built_in">SetEntryPointFromQuickCompiledCode</span>(<span class="built_in">GetQuickProxyInvokeHandler</span>());</span><br><span class="line">  <span class="comment">// 设置 dex 中此方法的偏移为 0，表示它是 native 或 abstract 方法，没有具体代码</span></span><br><span class="line">  <span class="built_in">SetCodeItemOffset</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除以下标志</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> kRemoveFlags = kAccNative | kAccSynchronized | kAccAbstract | kAccDefault | kAccDefaultConflict;</span><br><span class="line">  <span class="comment">// 添加 Xposed 自定义的 kAccXposedHookedMethod 标志，用来标识它是被 Hook 的方法</span></span><br><span class="line">  <span class="comment">// 添加后，IsXposedHookedMethod 函数就会返回 true</span></span><br><span class="line">  <span class="built_in">SetAccessFlags</span>((<span class="built_in">GetAccessFlags</span>() &amp; ~kRemoveFlags) | kAccXposedHookedMethod);</span><br><span class="line"></span><br><span class="line">  <span class="function">MutexLock <span class="title">mu</span><span class="params">(soa.Self(), *Locks::thread_list_lock_)</span></span>;</span><br><span class="line">  Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetThreadList</span>()-&gt;<span class="built_in">ForEach</span>(StackReplaceMethodAndInstallInstrumentation, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码的主要工作是备份当前需要被 Hook 的方法，然后设置当前方法的汇编代码地址为 <code>GetQuickProxyInvokeHandler()</code>，此时就完成了 Hook 目的。</p>
<p>当这个 Java 方法被调用时，会跳转到上面设置的汇编代码地址处，Xposed 将会对这个 Java 方法的参数进行转发等处理，修改方法返回值，实现最终 Hook。</p>
<p>不过没有看到最终的处理，并不知道是怎么做的，下面继续分析。</p>
<p>首先看 <code>GetQuickProxyInvokeHandler()</code> 的返回值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">art_quick_proxy_invoke_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">GetQuickProxyInvokeHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(art_quick_proxy_invoke_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是一个 <code>art_quick_proxy_invoke_handler</code> 函数的地址，这个函数是在其他地方实现的（有 <code>extern</code> 声明），经过了解，发现它是由汇编代码实现的，有 arm、arm64、mips、mips64、x86、x86_64 这几个指令集的实现，这里看一下 arm 上的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// quick_entrypoints_arm.S</span><br><span class="line"></span><br><span class="line">.extern artQuickProxyInvokeHandler</span><br><span class="line">ENTRY art_quick_proxy_invoke_handler</span><br><span class="line">    SETUP_REFS_AND_ARGS_CALLEE_SAVE_FRAME_WITH_METHOD_IN_R0</span><br><span class="line">    // 传递相关参数</span><br><span class="line">    mov     r2, r9                 @ pass Thread::Current</span><br><span class="line">    mov     r3, sp                 @ pass SP</span><br><span class="line">    // 跳转至 artQuickProxyInvokeHandler 函数</span><br><span class="line">    blx     artQuickProxyInvokeHandler  @ (Method* proxy method, receiver, Thread*, SP)</span><br><span class="line">    ldr     r2, [r9, #THREAD_EXCEPTION_OFFSET]  @ load Thread::Current()-&gt;exception_</span><br><span class="line">    add     sp, #(FRAME_SIZE_REFS_AND_ARGS_CALLEE_SAVE - FRAME_SIZE_REFS_ONLY_CALLEE_SAVE)</span><br><span class="line">    .cfi_adjust_cfa_offset -(FRAME_SIZE_REFS_AND_ARGS_CALLEE_SAVE - FRAME_SIZE_REFS_ONLY_CALLEE_SAVE)</span><br><span class="line">    RESTORE_REFS_ONLY_CALLEE_SAVE_FRAME</span><br><span class="line">    cbnz    r2, 1f                 @ success if no exception is pending</span><br><span class="line">    vmov    d0, r0, r1             @ store into fpr, for when it&#x27;s a fpr return...</span><br><span class="line">    bx      lr                     @ return on success</span><br><span class="line">1:</span><br><span class="line">    DELIVER_PENDING_EXCEPTION</span><br><span class="line">END art_quick_proxy_invoke_handler</span><br></pre></td></tr></table></figure>

<p><code>art_quick_proxy_invoke_handler</code> 跳转至了 <code>artQuickProxyInvokeHandler</code> 函数中，那么继续跟进。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// qucik_trampoline_entrypoints.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">uint64_t</span> <span class="title">artQuickProxyInvokeHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ArtMethod* proxy_method, mirror::Object* receiver, Thread* self, ArtMethod** sp)</span></span></span><br><span class="line"><span class="function">    <span class="title">SHARED_REQUIRES</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// bool IsXposedHookedMethod() &#123;</span></span><br><span class="line">  <span class="comment">//   return (GetAccessFlags() &amp; kAccXposedHookedMethod) != 0;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_xposed = proxy_method-&gt;<span class="built_in">IsXposedHookedMethod</span>();</span><br><span class="line">  <span class="keyword">if</span> (!is_xposed) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(proxy_method-&gt;<span class="built_in">IsRealProxyMethod</span>()) &lt;&lt; <span class="built_in">PrettyMethod</span>(proxy_method);</span><br><span class="line">    <span class="built_in">DCHECK</span>(receiver-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">IsProxyClass</span>()) &lt;&lt; <span class="built_in">PrettyMethod</span>(proxy_method);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* old_cause = self-&gt;<span class="built_in">StartAssertNoThreadSuspension</span>(<span class="string">&quot;Adding to IRT proxy object arguments&quot;</span>);</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>((*sp), proxy_method) &lt;&lt; <span class="built_in">PrettyMethod</span>(proxy_method);</span><br><span class="line">  self-&gt;<span class="built_in">VerifyStack</span>();</span><br><span class="line">  JNIEnvExt* env = self-&gt;<span class="built_in">GetJniEnv</span>();</span><br><span class="line">  <span class="function">ScopedObjectAccessUnchecked <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="function">ScopedJniEnvLocalRefState <span class="title">env_state</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_static = proxy_method-&gt;<span class="built_in">IsStatic</span>();</span><br><span class="line">  jobject rcvr_jobj = is_static ? <span class="literal">nullptr</span> : soa.AddLocalReference&lt;jobject&gt;(receiver);</span><br><span class="line"></span><br><span class="line">  ArtMethod* non_proxy_method = proxy_method-&gt;<span class="built_in">GetInterfaceMethodIfProxy</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*));</span><br><span class="line">  <span class="built_in">CHECK</span>(is_xposed || !non_proxy_method-&gt;<span class="built_in">IsStatic</span>()) &lt;&lt; <span class="built_in">PrettyMethod</span>(proxy_method) &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">                                                    &lt;&lt; <span class="built_in">PrettyMethod</span>(non_proxy_method);</span><br><span class="line">  std::vector&lt;jvalue&gt; args;</span><br><span class="line">  <span class="keyword">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* shorty = non_proxy_method-&gt;<span class="built_in">GetShorty</span>(&amp;shorty_len);</span><br><span class="line">  <span class="function">BuildQuickArgumentVisitor <span class="title">local_ref_visitor</span><span class="params">(sp, is_static, shorty, shorty_len, &amp;soa, &amp;args)</span></span>;</span><br><span class="line"></span><br><span class="line">  local_ref_visitor.<span class="built_in">VisitArguments</span>();</span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    <span class="built_in">DCHECK_GT</span>(args.<span class="built_in">size</span>(), <span class="number">0U</span>) &lt;&lt; <span class="built_in">PrettyMethod</span>(proxy_method);</span><br><span class="line">    args.<span class="built_in">erase</span>(args.<span class="built_in">begin</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_xposed) &#123;</span><br><span class="line">    jmethodID proxy_methodid = soa.<span class="built_in">EncodeMethod</span>(proxy_method);</span><br><span class="line">    self-&gt;<span class="built_in">EndAssertNoThreadSuspension</span>(old_cause);</span><br><span class="line">    <span class="comment">// 处理 Hook 方法</span></span><br><span class="line">    JValue result = <span class="built_in">InvokeXposedHandleHookedMethod</span>(soa, shorty, rcvr_jobj, proxy_methodid, args);</span><br><span class="line">    local_ref_visitor.<span class="built_in">FixupReferences</span>();</span><br><span class="line">    <span class="comment">// 返回 Java 方法的返回值</span></span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">GetJ</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以大概看出来 <code>artQuickProxyInvokeHandler</code> 函数是用于处理动态代理方法的，不过 Xposed 对这个方法进行了修改，使其能够处理被 Hook 的方法，重点关注下面判断语句中的代码，如果是被 Xposed Hook 的方法，那么进入 <code>InvokeXposedHandleHookedMethod</code> 进行处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entrypoint_utils.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">JValue <span class="title">InvokeXposedHandleHookedMethod</span><span class="params">(ScopedObjectAccessAlreadyRunnable&amp; soa, <span class="keyword">const</span> <span class="keyword">char</span>* shorty,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      jobject rcvr_jobj, jmethodID method,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      std::vector&lt;jvalue&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  soa.<span class="built_in">Self</span>()-&gt;<span class="built_in">AssertThreadSuspensionIsAllowable</span>();</span><br><span class="line">  jobjectArray args_jobj = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">const</span> JValue zero;</span><br><span class="line">  <span class="keyword">int32_t</span> target_sdk_version = Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetTargetSdkVersion</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出 hook_info</span></span><br><span class="line">  <span class="keyword">const</span> XposedHookInfo* hook_info = soa.<span class="built_in">DecodeMethod</span>(method)-&gt;<span class="built_in">GetXposedHookInfo</span>();</span><br><span class="line">  <span class="comment">// 调用 Java 层的 XposedBridge.handleHookedMethod 方法</span></span><br><span class="line">  jvalue invocation_args[<span class="number">5</span>];</span><br><span class="line">  invocation_args[<span class="number">0</span>].l = hook_info-&gt;reflected_method;</span><br><span class="line">  invocation_args[<span class="number">1</span>].i = <span class="number">1</span>;</span><br><span class="line">  invocation_args[<span class="number">2</span>].l = hook_info-&gt;additional_info;</span><br><span class="line">  <span class="comment">// 方法的目标作用对象 this</span></span><br><span class="line">  invocation_args[<span class="number">3</span>].l = rcvr_jobj;</span><br><span class="line">  <span class="comment">// 参数保存传给方法的参数</span></span><br><span class="line">  invocation_args[<span class="number">4</span>].l = args_jobj;</span><br><span class="line">  jobject result =</span><br><span class="line">      soa.<span class="built_in">Env</span>()-&gt;<span class="built_in">CallStaticObjectMethodA</span>(ArtMethod::xposed_callback_class,</span><br><span class="line">                                         ArtMethod::xposed_callback_method,</span><br><span class="line">                                         invocation_args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(soa.<span class="built_in">Self</span>()-&gt;<span class="built_in">IsExceptionPending</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> zero;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shorty[<span class="number">0</span>] == <span class="string">&#x27;V&#x27;</span> || (shorty[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; result == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> pointer_size = Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetClassLinker</span>()-&gt;<span class="built_in">GetImagePointerSize</span>();</span><br><span class="line">    mirror::Class* result_type = soa.<span class="built_in">DecodeMethod</span>(method)-&gt;<span class="built_in">GetReturnType</span>(<span class="literal">true</span> <span class="comment">/* resolve */</span>, pointer_size);</span><br><span class="line">    mirror::Object* result_ref = soa.Decode&lt;mirror::Object*&gt;(result);</span><br><span class="line">    JValue result_unboxed;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">UnboxPrimitiveForResult</span>(result_ref, result_type, &amp;result_unboxed)) &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(soa.<span class="built_in">Self</span>()-&gt;<span class="built_in">IsExceptionPending</span>());</span><br><span class="line">      <span class="keyword">return</span> zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result_unboxed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就调用到了 Java 层 <code>XposedBridge</code> 的 <code>handleHookedMethod</code> 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XposedBridge.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">handleHookedMethod</span><span class="params">(Member method, <span class="keyword">int</span> originalMethodId, Object additionalInfoObj,</span></span></span><br><span class="line"><span class="params"><span class="function">    Object thisObject, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 取出 Hook 处理回调等信息</span></span><br><span class="line">  AdditionalHookInfo additionalInfo = (AdditionalHookInfo) additionalInfoObj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (disableHooks) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果关闭 Hook，那么调用原始方法</span></span><br><span class="line">      <span class="keyword">return</span> invokeOriginalMethodNative(method, originalMethodId, additionalInfo.parameterTypes,</span><br><span class="line">          additionalInfo.returnType, thisObject, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> e.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object[] callbacksSnapshot = additionalInfo.callbacks.getSnapshot();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> callbacksLength = callbacksSnapshot.length;</span><br><span class="line">  <span class="keyword">if</span> (callbacksLength == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 没有处理 Hook 的回调，则调用原始方法</span></span><br><span class="line">      <span class="keyword">return</span> invokeOriginalMethodNative(method, originalMethodId, additionalInfo.parameterTypes,</span><br><span class="line">          additionalInfo.returnType, thisObject, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> e.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MethodHookParam param = <span class="keyword">new</span> MethodHookParam();</span><br><span class="line">  param.method = method;</span><br><span class="line">  param.thisObject = thisObject;</span><br><span class="line">  param.args = args;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> beforeIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 回调 beforeHookedMethod 方法，表示在 Hook 之前</span></span><br><span class="line">      ((XC_MethodHook) callbacksSnapshot[beforeIdx]).beforeHookedMethod(param);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      XposedBridge.log(t);</span><br><span class="line"></span><br><span class="line">      param.setResult(<span class="keyword">null</span>);</span><br><span class="line">      param.returnEarly = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (param.returnEarly) &#123;</span><br><span class="line">      beforeIdx++;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (++beforeIdx &lt; callbacksLength);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Hook 回调没有处理，则调用原始方法</span></span><br><span class="line">  <span class="keyword">if</span> (!param.returnEarly) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      param.setResult(invokeOriginalMethodNative(method, originalMethodId,</span><br><span class="line">          additionalInfo.parameterTypes, additionalInfo.returnType, param.thisObject, param.args));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      param.setThrowable(e.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> afterIdx = beforeIdx - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    Object lastResult =  param.getResult();</span><br><span class="line">    Throwable lastThrowable = param.getThrowable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 afterHookedMethod 方法，表示 Hook 之后</span></span><br><span class="line">      ((XC_MethodHook) callbacksSnapshot[afterIdx]).afterHookedMethod(param);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      XposedBridge.log(t);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lastThrowable == <span class="keyword">null</span>)</span><br><span class="line">        param.setResult(lastResult);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        param.setThrowable(lastThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (--afterIdx &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有异常，则抛出异常，否则返回处理后的结果</span></span><br><span class="line">  <span class="keyword">if</span> (param.hasThrowable())</span><br><span class="line">    <span class="keyword">throw</span> param.getThrowable();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> param.getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就能清晰的看到 Hook 最终处理了，至此就完成了 Hook。其中 <code>invokeOriginalMethodNative</code> 的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libxposed_art.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">XposedBridge_invokeOriginalMethodNative</span><span class="params">(JNIEnv* env, jclass, jobject javaMethod,</span></span></span><br><span class="line"><span class="params"><span class="function">            jint isResolved, jobjectArray, jclass, jobject javaReceiver, jobjectArray javaArgs)</span> </span>&#123;</span><br><span class="line">    <span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(!isResolved)) &#123;</span><br><span class="line">        <span class="comment">// 从备份的方法中取得原始方法</span></span><br><span class="line">        ArtMethod* artMethod = ArtMethod::<span class="built_in">FromReflectedMethod</span>(soa, javaMethod);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LIKELY</span>(artMethod-&gt;<span class="built_in">IsXposedHookedMethod</span>())) &#123;</span><br><span class="line">            javaMethod = artMethod-&gt;<span class="built_in">GetXposedHookInfo</span>()-&gt;reflected_method;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM_SDK_VERSION &gt;= 23</span></span><br><span class="line">    <span class="comment">// 调用虚拟机的执行方法调用原始方法逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InvokeMethod</span>(soa, javaMethod, javaReceiver, javaArgs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InvokeMethod</span>(soa, javaMethod, javaReceiver, javaArgs, <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有最后一个问题，就是一个被 Hook 的方法的调用过程，上面只分析了处理过程，而没有正向的调用，下面开始分析。</p>
<h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p>分析一个 Java 方法的调用，可以从 <code>AndroidRuntime.start</code> 中开始，Java 虚拟机执行的第一个类是 <code>ZygoteInit</code> 从此就进入了 Java 层，它使用的是 <code>JNIEnv</code> 提供的 <code>CallStaticVoidMethod</code> 方法，看一下它的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jni_internal.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallStaticVoidMethod</span><span class="params">(JNIEnv* env, jclass, jmethodID mid, ...)</span> </span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="built_in">va_start</span>(ap, mid);</span><br><span class="line">  <span class="built_in">CHECK_NON_NULL_ARGUMENT_RETURN_VOID</span>(mid);</span><br><span class="line">  <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="built_in">InvokeWithVarArgs</span>(soa, <span class="literal">nullptr</span>, mid, ap);</span><br><span class="line">  <span class="built_in">va_end</span>(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了 <code>InvokeWithVarArgs</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">JValue <span class="title">InvokeWithVarArgs</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa, jobject obj, jmethodID mid,</span></span></span><br><span class="line"><span class="params"><span class="function">                         va_list args)</span></span></span><br><span class="line"><span class="function">    <span class="title">SHARED_REQUIRES</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  ArtMethod* method = soa.<span class="built_in">DecodeMethod</span>(mid);</span><br><span class="line">  <span class="keyword">bool</span> is_string_init = method-&gt;<span class="built_in">GetDeclaringClass</span>()-&gt;<span class="built_in">IsStringClass</span>() &amp;&amp; method-&gt;<span class="built_in">IsConstructor</span>();</span><br><span class="line">  <span class="keyword">if</span> (is_string_init) &#123;</span><br><span class="line">    method = soa.<span class="built_in">DecodeMethod</span>(WellKnownClasses::<span class="built_in">StringInitToStringFactoryMethodID</span>(mid));</span><br><span class="line">  &#125;</span><br><span class="line">  mirror::Object* receiver = method-&gt;<span class="built_in">IsStatic</span>() ? <span class="literal">nullptr</span> : soa.Decode&lt;mirror::Object*&gt;(obj);</span><br><span class="line">  <span class="keyword">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* shorty = method-&gt;<span class="built_in">GetInterfaceMethodIfProxy</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*))-&gt;<span class="built_in">GetShorty</span>(&amp;shorty_len);</span><br><span class="line">  JValue result;</span><br><span class="line">  <span class="function">ArgArray <span class="title">arg_array</span><span class="params">(shorty, shorty_len)</span></span>;</span><br><span class="line">  arg_array.<span class="built_in">BuildArgArrayFromVarArgs</span>(soa, receiver, args);</span><br><span class="line">  <span class="comment">// 调用 InvokeWithArgArray</span></span><br><span class="line">  <span class="built_in">InvokeWithArgArray</span>(soa, method, &amp;arg_array, &amp;result, shorty);</span><br><span class="line">  <span class="keyword">if</span> (is_string_init) &#123;</span><br><span class="line">    <span class="built_in">UpdateReference</span>(soa.<span class="built_in">Self</span>(), obj, result.<span class="built_in">GetL</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看 <code>InvokeWithArgArray</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokeWithArgArray</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="params"><span class="function">                               ArtMethod* method, ArgArray* arg_array, JValue* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span></span></span><br><span class="line"><span class="function">    <span class="title">SHARED_REQUIRES</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span>* args = arg_array-&gt;<span class="built_in">GetArray</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(soa.<span class="built_in">Env</span>()-&gt;check_jni)) &#123;</span><br><span class="line">    <span class="built_in">CheckMethodArguments</span>(soa.<span class="built_in">Vm</span>(), method-&gt;<span class="built_in">GetInterfaceMethodIfProxy</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*)), args);</span><br><span class="line">  &#125;</span><br><span class="line">  method-&gt;<span class="built_in">Invoke</span>(soa.<span class="built_in">Self</span>(), args, arg_array-&gt;<span class="built_in">GetNumBytes</span>(), result, shorty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终是调用到了 <code>ArtMethod</code> 的 <code>Invoke</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::Invoke</span><span class="params">(Thread* self, <span class="keyword">uint32_t</span>* args, <span class="keyword">uint32_t</span> args_size, JValue* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  ManagedStack fragment;</span><br><span class="line">  self-&gt;<span class="built_in">PushManagedStackFragment</span>(&amp;fragment);</span><br><span class="line"></span><br><span class="line">  Runtime* runtime = Runtime::<span class="built_in">Current</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(!runtime-&gt;<span class="built_in">IsStarted</span>() || Dbg::<span class="built_in">IsForcedInterpreterNeededForCalling</span>(self, <span class="keyword">this</span>))) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(runtime-&gt;<span class="built_in">GetClassLinker</span>()-&gt;<span class="built_in">GetImagePointerSize</span>(), <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> kLogInvocationStartAndReturn = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> have_quick_code = <span class="built_in">GetEntryPointFromQuickCompiledCode</span>() != <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">LIKELY</span>(have_quick_code)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">IsStatic</span>()) &#123;</span><br><span class="line">        (*art_quick_invoke_stub)(<span class="keyword">this</span>, args, args_size, self, result, shorty);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (*art_quick_invoke_static_stub)(<span class="keyword">this</span>, args, args_size, self, result, shorty);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self-&gt;<span class="built_in">PopManagedStackFragment</span>(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 Java 方法类型是非静态还是静态，跳入 <code>art_quick_invoke_stub</code> 或 <code>art_quick_invoke_static_stub</code>，看一下 <code>art_quick_invoke_stub</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">art_quick_invoke_stub</span><span class="params">(ArtMethod* method, <span class="keyword">uint32_t</span>* args, <span class="keyword">uint32_t</span> args_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Thread* self, JValue* result, <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span> </span>&#123;</span><br><span class="line">  quick_invoke_reg_setup&lt;<span class="literal">false</span>&gt;(method, args, args_size, self, result, shorty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> kIsStatic&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_invoke_reg_setup</span><span class="params">(ArtMethod* method, <span class="keyword">uint32_t</span>* args, <span class="keyword">uint32_t</span> args_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Thread* self, JValue* result, <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> core_reg_args[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> fp_reg_args[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> gpr_index = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> fpr_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> fpr_double_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> arg_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> result_in_float = kArm32QuickCodeUseSoftFloat ? <span class="number">0</span> :</span><br><span class="line">      (shorty[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> || shorty[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!kIsStatic) &#123;</span><br><span class="line">    core_reg_args[gpr_index++] = args[arg_index++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shorty_index = <span class="number">1</span>; shorty[shorty_index] != <span class="string">&#x27;\0&#x27;</span>; ++shorty_index, ++arg_index) &#123;</span><br><span class="line">    <span class="keyword">char</span> arg_type = shorty[shorty_index];</span><br><span class="line">    <span class="keyword">if</span> (kArm32QuickCodeUseSoftFloat) &#123;</span><br><span class="line">      arg_type = (arg_type == <span class="string">&#x27;D&#x27;</span>) ? <span class="string">&#x27;J&#x27;</span> : arg_type;</span><br><span class="line">      arg_type = (arg_type == <span class="string">&#x27;F&#x27;</span>) ? <span class="string">&#x27;I&#x27;</span> : arg_type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (arg_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: &#123;</span><br><span class="line">        fpr_double_index = std::<span class="built_in">max</span>(fpr_double_index, <span class="built_in">RoundUp</span>(fpr_index, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (fpr_double_index &lt; <span class="built_in">arraysize</span>(fp_reg_args)) &#123;</span><br><span class="line">          fp_reg_args[fpr_double_index++] = args[arg_index];</span><br><span class="line">          fp_reg_args[fpr_double_index++] = args[arg_index + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ++arg_index;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (fpr_index % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">          fpr_index = std::<span class="built_in">max</span>(fpr_double_index, fpr_index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fpr_index &lt; <span class="built_in">arraysize</span>(fp_reg_args)) &#123;</span><br><span class="line">          fp_reg_args[fpr_index++] = args[arg_index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入下一步</span></span><br><span class="line">  <span class="built_in">art_quick_invoke_stub_internal</span>(method, args, args_size, self, result, result_in_float,</span><br><span class="line">      core_reg_args, fp_reg_args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是调用了 <code>art_quick_invoke_stub_internal</code>，它是汇编代码实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// quick_entrypoints_arm.S</span><br><span class="line"></span><br><span class="line">ENTRY art_quick_invoke_stub_internal</span><br><span class="line">    SPILL_ALL_CALLEE_SAVE_GPRS             @ spill regs (9)</span><br><span class="line">    mov    r11, sp                         @ save the stack pointer</span><br><span class="line">    .cfi_def_cfa_register r11</span><br><span class="line"></span><br><span class="line">    mov    r9, r3                          @ move managed thread pointer into r9</span><br><span class="line"></span><br><span class="line">    add    r4, r2, #4                      @ create space for method pointer in frame</span><br><span class="line">    sub    r4, sp, r4                      @ reserve &amp; align *stack* to 16 bytes: native calling</span><br><span class="line">    and    r4, #0xFFFFFFF0                 @ convention only aligns to 8B, so we have to ensure ART</span><br><span class="line">    mov    sp, r4                          @ 16B alignment ourselves.</span><br><span class="line"></span><br><span class="line">    mov    r4, r0                          @ save method*</span><br><span class="line">    add    r0, sp, #4                      @ pass stack pointer + method ptr as dest for memcpy</span><br><span class="line">    bl     memcpy                          @ memcpy (dest, src, bytes)</span><br><span class="line">    mov    ip, #0                          @ set ip to 0</span><br><span class="line">    str    ip, [sp]                        @ store null for method* at bottom of frame</span><br><span class="line"></span><br><span class="line">    ldr    ip, [r11, #48]                  @ load fp register argument array pointer</span><br><span class="line">    vldm   ip, &#123;s0-s15&#125;                    @ copy s0 - s15</span><br><span class="line"></span><br><span class="line">    ldr    ip, [r11, #44]                  @ load core register argument array pointer</span><br><span class="line">    mov    r0, r4                          @ restore method*</span><br><span class="line">    add    ip, ip, #4                      @ skip r0</span><br><span class="line">    ldm    ip, &#123;r1-r3&#125;                     @ copy r1 - r3</span><br><span class="line"></span><br><span class="line">#ifdef ARM_R4_SUSPEND_FLAG</span><br><span class="line">    mov    r4, #SUSPEND_CHECK_INTERVAL     @ reset r4 to suspend check interval</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ldr    ip, [r0, #ART_METHOD_QUICK_CODE_OFFSET_32]  @ get pointer to the code</span><br><span class="line">    blx    ip                              @ call the method</span><br><span class="line"></span><br><span class="line">    mov    sp, r11                         @ restore the stack pointer</span><br><span class="line">    .cfi_def_cfa_register sp</span><br><span class="line"></span><br><span class="line">    ldr    r4, [sp, #40]                   @ load result_is_float</span><br><span class="line">    ldr    r9, [sp, #36]                   @ load the result pointer</span><br><span class="line">    cmp    r4, #0</span><br><span class="line">    ite    eq</span><br><span class="line">    strdeq r0, [r9]                        @ store r0/r1 into result pointer</span><br><span class="line">    vstrne d0, [r9]                        @ store s0-s1/d0 into result pointer</span><br><span class="line"></span><br><span class="line">    pop    &#123;r4, r5, r6, r7, r8, r9, r10, r11, pc&#125;               @ restore spill regs</span><br><span class="line">END art_quick_invoke_stub_internal</span><br></pre></td></tr></table></figure>

<p>其中中间部分一行代码使用 <code>ldr</code> 指令设置 ip 寄存器的位置来指示指令地址，使用到了 <code>ART_METHOD_QUICK_CODE_OFFSET_32</code> 这个宏，它是 32，表示 <code>EntryPointFromQuickCompiledCodeOffset</code> 这个函数返回的成员的偏移，也就是 <code>entry_point_from_quick_compiled_code_</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asm_support.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ART_METHOD_QUICK_CODE_OFFSET_32 32</span></span><br><span class="line"><span class="built_in">ADD_TEST_EQ</span>(ART_METHOD_QUICK_CODE_OFFSET_32,</span><br><span class="line">            art::ArtMethod::<span class="built_in">EntryPointFromQuickCompiledCodeOffset</span>(<span class="number">4</span>).<span class="built_in">Int32Value</span>())</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// art_method.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> MemberOffset <span class="title">EntryPointFromQuickCompiledCodeOffset</span><span class="params">(<span class="keyword">size_t</span> pointer_size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MemberOffset</span>(<span class="built_in">PtrSizedFieldsOffset</span>(pointer_size) + <span class="built_in">OFFSETOF_MEMBER</span>(</span><br><span class="line">      PtrSizedFields, entry_point_from_quick_compiled_code_) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*) * pointer_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到前面 Hook 时，使用了 <code>SetEntryPointFromQuickCompiledCode</code>，其实就是设置这个变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// art_method.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetEntryPointFromQuickCompiledCode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* entry_point_from_quick_compiled_code)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SetEntryPointFromQuickCompiledCodePtrSize</span>(entry_point_from_quick_compiled_code,</span><br><span class="line">                                              <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ALWAYS_INLINE <span class="keyword">void</span> <span class="title">SetEntryPointFromQuickCompiledCodePtrSize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> <span class="keyword">void</span>* entry_point_from_quick_compiled_code, <span class="keyword">size_t</span> pointer_size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">IsAotCompiler</span>() || !<span class="built_in">IsXposedHookedMethod</span>());</span><br><span class="line">    <span class="built_in">SetNativePointer</span>(<span class="built_in">EntryPointFromQuickCompiledCodeOffset</span>(pointer_size),</span><br><span class="line">                     entry_point_from_quick_compiled_code, pointer_size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那么下一步使用了 <code>blx</code> 跳转指令，代码就会跳转到这个地址上执行，进入 <code>GetQuickProxyInvokeHandler</code> 返回的地址 <code>art_quick_proxy_invoke_handler</code> 中， 最后执行 <code>artQuickProxyInvokeHandler</code> 函数，Xposed 在这个函数里面处理了 Hook，完成 Hook。</p>
<p>到这里就分析完了 Xposed 的实现，其实还有很多细节没有去分析，通过对比 ART 虚拟机的原始代码和 Xposed 修改后的代码，发现 Xposed 修改的地方还是很多的，大概有几百处，虽然每个文件修改的代码不多，但是足以说明 Xposed 作者对于 Android 系统原理和 ART 虚拟机的了解的深入程度。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过分析 Xposed 的实现原理，对于 Java 方法的 Hook 原理有了一些了解，同时回顾了 Android zygote 进程相关的内容，对于 ART 虚拟机执行方法的过程也有了一个大概的认识。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-257844.htm">https://bbs.pediy.com/thread-257844.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Innost/article/details/50461783">https://blog.csdn.net/Innost/article/details/50461783</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Luoshengyang/article/details/39256813">https://blog.csdn.net/Luoshengyang/article/details/39256813</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Luoshengyang/article/details/8914953">https://blog.csdn.net/Luoshengyang/article/details/8914953</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Xposed 实现原理分析</p><p><a href="https://l0neman.github.io/2020/10/11/xposed-实现原理分析/">https://l0neman.github.io/2020/10/11/xposed-实现原理分析/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>l0neman</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-10-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-10-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/android/">Android</a><a class="link-muted mr-2" rel="tag" href="/tags/xposed/">Xposed</a></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f0f12c19a2af379" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/qrcode/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/qrcode/wxpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/21/android-so-elf-%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android so(ELF) 文件解析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/19/android-%E6%A8%A1%E6%8B%9F%E5%99%A8-root-%E5%92%8C-supersu-%E5%AE%89%E8%A3%85/"><span class="level-item">Android 模拟器 Root 和 SuperSU 安装</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="l0neman/l0neman.github.io" issue-term="pathname" label="comment" theme="github-light" crossorigin="anonymous" async></script></div></div></div><!--!--><div class="column column-right  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#Xposed-使用方法"><span class="level-left"><span class="level-item">2</span><span class="level-item">Xposed 使用方法</span></span></a></li><li><a class="level is-mobile" href="#Xposed-原理概述"><span class="level-left"><span class="level-item">3</span><span class="level-item">Xposed 原理概述</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Android-zygote-进程"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Android zygote 进程</span></span></a></li><li><a class="level is-mobile" href="#基于-Dalvik-的方法-Hook"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">基于 Dalvik 的方法 Hook</span></span></a></li><li><a class="level is-mobile" href="#基于-ART-的方法-Hook"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">基于 ART 的方法 Hook</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Xposed-工作流程"><span class="level-left"><span class="level-item">4</span><span class="level-item">Xposed 工作流程</span></span></a></li><li><a class="level is-mobile" href="#Xposed-项目结构"><span class="level-left"><span class="level-item">5</span><span class="level-item">Xposed 项目结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Xposed"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Xposed</span></span></a></li><li><a class="level is-mobile" href="#XposedBridge"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">XposedBridge</span></span></a></li><li><a class="level is-mobile" href="#XposedInstaller"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">XposedInstaller</span></span></a></li><li><a class="level is-mobile" href="#android-art"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">android_art</span></span></a></li><li><a class="level is-mobile" href="#XposedTools"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">XposedTools</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Xposed-源码分析"><span class="level-left"><span class="level-item">6</span><span class="level-item">Xposed 源码分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Xposed-安装"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Xposed 安装</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#下载"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">下载</span></span></a></li><li><a class="level is-mobile" href="#直接刷入"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">直接刷入</span></span></a></li><li><a class="level is-mobile" href="#使用-recovery-刷入"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">使用 recovery 刷入</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Xposed-启动"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Xposed 启动</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Native-层"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">Native 层</span></span></a></li><li><a class="level is-mobile" href="#Java-层"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">Java 层</span></span></a></li><li><a class="level is-mobile" href="#Xposed-模块加载"><span class="level-left"><span class="level-item">6.2.3</span><span class="level-item">Xposed 模块加载</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Xposed-方法-Hook"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">Xposed 方法 Hook</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Dalvik-Hook-实现"><span class="level-left"><span class="level-item">6.3.1</span><span class="level-item">Dalvik Hook 实现</span></span></a></li><li><a class="level is-mobile" href="#ART-Hook-实现"><span class="level-left"><span class="level-item">6.3.2</span><span class="level-item">ART Hook 实现</span></span></a></li><li><a class="level is-mobile" href="#调用过程"><span class="level-left"><span class="level-item">6.3.3</span><span class="level-item">调用过程</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">7</span><span class="level-item">总结</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">8</span><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">Android 实用工具</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Android 应用开发</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/android-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">Android 系统原理</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/android-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"><span class="level-start"><span class="level-item">Android 逆向工程</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/"><span class="level-start"><span class="level-item">参考文档</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">实用工具</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">编程基础</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-14T16:18:50.000Z">2021-11-15</time></p><p class="title"><a href="/2021/11/15/staruml-%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95/">StarUML 破解方法</a></p><p class="categories"><a href="/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">实用工具</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-14T15:59:06.000Z">2021-11-14</time></p><p class="title"><a href="/2021/11/14/android-filter-%E5%88%86%E6%9E%90/">Android Filter 分析</a></p><p class="categories"><a href="/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">Android 应用开发</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-29T16:45:50.000Z">2021-06-30</time></p><p class="title"><a href="/2021/06/30/%E6%94%AF%E6%8C%81%E8%A7%A6%E6%91%B8%E6%8B%96%E5%8A%A8%E7%9A%84-touchdelegate/">支持触摸拖动的 TouchDelegate</a></p><p class="categories"><a href="/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">Android 应用开发</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-21T15:08:15.000Z">2021-04-21</time></p><p class="title"><a href="/2021/04/21/gdb-arm-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">GDB ARM 交叉编译环境搭建</a></p><p class="categories"><a href="/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">Android 实用工具</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-21T15:04:39.000Z">2021-04-21</time></p><p class="title"><a href="/2021/04/21/dropbear-android-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/">Dropbear Android 安装步骤</a></p><p class="categories"><a href="/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">Android 实用工具</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/arm/"><span class="tag">ARM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/avd/"><span class="tag">AVD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/activity/"><span class="tag">Activity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">Android</span><span class="tag">24</span></a></div><div class="control"><a class="tags has-addons" href="/tags/assembly/"><span class="tag">Assembly</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/binder/"><span class="tag">Binder</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/classloader/"><span class="tag">ClassLoader</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/computer/"><span class="tag">Computer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dex/"><span class="tag">Dex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elf/"><span class="tag">ELF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/emulator/"><span class="tag">Emulator</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jni/"><span class="tag">JNI</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/log/"><span class="tag">Log</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makefile/"><span class="tag">Makefile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">MarkDown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/metrial/"><span class="tag">Metrial</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ndk/"><span class="tag">NDK</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/regex/"><span class="tag">Regex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">SSH</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/theme/"><span class="tag">Theme</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/touch/"><span class="tag">Touch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/view/"><span class="tag">View</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xposed/"><span class="tag">Xposed</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zygote/"><span class="tag">Zygote</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aapt/"><span class="tag">aapt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uml/"><span class="tag">uml</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"><span class="tag">热修复</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"><span class="tag">热更新</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="l0neman 的博客" height="28"></a><p class="is-size-7"><span>&copy; 2021 l0neman</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/l0neman"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
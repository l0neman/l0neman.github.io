<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Android JNI 指南 - l0neman 的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="l0neman 的博客"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="l0neman 的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言编写此文档的用意： 作为 Android NDK 项目开发的参考手册。 对于 NDK 工程的搭建可参考 Android NDK 指南 JNI 简介JNI（Java Native Interface，Java 原生接口），是 Java 和 C++ 组件用以互相通信的接口。 Android 平台下的 JNI 支持由 Android NDK 提供，它是一套能将 C 或 C++（原生代码）嵌入到 An"><meta property="og:type" content="blog"><meta property="og:title" content="Android JNI 指南"><meta property="og:url" content="https://l0neman.github.io/2020/07/14/android-jni-%E6%8C%87%E5%8D%97/"><meta property="og:site_name" content="l0neman 的博客"><meta property="og:description" content="前言编写此文档的用意： 作为 Android NDK 项目开发的参考手册。 对于 NDK 工程的搭建可参考 Android NDK 指南 JNI 简介JNI（Java Native Interface，Java 原生接口），是 Java 和 C++ 组件用以互相通信的接口。 Android 平台下的 JNI 支持由 Android NDK 提供，它是一套能将 C 或 C++（原生代码）嵌入到 An"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://l0neman.github.io/img/og_image.png"><meta property="article:published_time" content="2020-07-14T15:27:23.000Z"><meta property="article:modified_time" content="2020-07-14T15:27:23.000Z"><meta property="article:author" content="l0neman"><meta property="article:tag" content="Android"><meta property="article:tag" content="NDK"><meta property="article:tag" content="JNI"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://l0neman.github.io/2020/07/14/android-jni-%E6%8C%87%E5%8D%97/"},"headline":"Android JNI 指南","image":["https://l0neman.github.io/img/og_image.png"],"datePublished":"2020-07-14T15:27:23.000Z","dateModified":"2020-07-14T15:27:23.000Z","author":{"@type":"Person","name":"l0neman"},"publisher":{"@type":"Organization","name":"l0neman 的博客","logo":{"@type":"ImageObject","url":"https://l0neman.github.io/img/logo.png"}},"description":"前言编写此文档的用意： 作为 Android NDK 项目开发的参考手册。 对于 NDK 工程的搭建可参考 Android NDK 指南 JNI 简介JNI（Java Native Interface，Java 原生接口），是 Java 和 C++ 组件用以互相通信的接口。 Android 平台下的 JNI 支持由 Android NDK 提供，它是一套能将 C 或 C++（原生代码）嵌入到 An"}</script><link rel="canonical" href="https://l0neman.github.io/2020/07/14/android-jni-%E6%8C%87%E5%8D%97/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?1727d76e0a823184efc8776f32a916a9";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="l0neman 的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/l0neman"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-three-quarters"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-14T15:27:23.000Z" title="2020/7/14 下午11:27:23">2020-07-14</time>发表</span><span class="level-item"><time dateTime="2020-07-14T15:27:23.000Z" title="2020/7/14 下午11:27:23">2020-07-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">Android 应用开发</a></span><span class="level-item">1 小时读完 (大约10651个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Android JNI 指南</h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>编写此文档的用意：</p>
<p>作为 Android NDK 项目开发的参考手册。</p>
<p>对于 NDK 工程的搭建可参考 <a href="/2020/07/14/android-ndk-%E6%8C%87%E5%8D%97/">Android NDK 指南</a></p>
<h1 id="JNI-简介"><a href="#JNI-简介" class="headerlink" title="JNI 简介"></a>JNI 简介</h1><p>JNI（Java Native Interface，Java 原生接口），是 Java 和 C++ 组件用以互相通信的接口。</p>
<p>Android 平台下的 JNI 支持由 Android NDK 提供，它是一套能将 C 或 C++（原生代码）嵌入到 Android 应用中的工具。</p>
<p>为什么要使用 JNI 在 Android 平台下进行编程：</p>
<ol>
<li>在平台之间移植应用；</li>
<li>重复使用现有库，或者提供自己的库供重复使用；</li>
<li>在某些情况下提供高性能，特别是像游戏这种计算密集型应用；</li>
<li>提供安全性保障，在二进制层面比字节码层面的逆向工作更加困难。<span id="more"></span></li>
</ol>
<h1 id="JNI-优化原则"><a href="#JNI-优化原则" class="headerlink" title="JNI 优化原则"></a>JNI 优化原则</h1><ol>
<li>尽可能减少跨 JNI 层的编组（Marshalling）数据资源的次数，因为跨 JNI 层进行编组的开销很大。尽可能设计一种接口，减少需要编组的数据量以及必须进行数据编组的频率；</li>
<li>尽量避免在使用受管理的编程语言（在虚拟机中运行）中与 C/C++ 编写的代码之间进行异步通信（例如 C/C++ 中开启线程后直接回调 Java 语言），这样可以使 JNI 接口更容易维护。通常使用与编写界面的相同语言进行异步更新，以简化异步界面的更新，例如，使用 Java 语言创建线程，然后发出对 C++ 层的阻塞调用，然后在阻塞完成后通知界面线程；</li>
<li>尽可能减少需要访问 JNI 或被 JNI 访问的线程数。如果确实需要以 Java 和 C++ 两种语言来利用线程池，请尝试在池所有者之间（而不是各个工作线程之间）保持 JNI 通信；</li>
<li>将接口保存在少量的容易识别的 C++ 和 Java 源位置，以便于将来进行重构。</li>
</ol>
<h1 id="名词说明"><a href="#名词说明" class="headerlink" title="名词说明"></a>名词说明</h1><p>下文叙述中使用到的名词说明：</p>
<ul>
<li><p>JNI 方法，在 Java 层使用 native 声明，使用 C/C++ 中实现的方法。</p>
</li>
<li><p>JNI 函数，JNI 提供的与 Java 层交互的工具一系列函数，例如 <code>RegisterNatives</code>。</p>
</li>
<li><p>不透明，具体结构未知，由具体的虚拟机实现决定。</p>
</li>
</ul>
<h1 id="JavaVM-和-JNIEnv"><a href="#JavaVM-和-JNIEnv" class="headerlink" title="JavaVM 和 JNIEnv"></a>JavaVM 和 JNIEnv</h1><p>JNI 定义了两个关键的数据结构，<code>JavaVM</code> 和 <code>JNIEnv</code>，它们的本质都是指向函数表的二级指针（在 C++ 版本中，两者都是类，类中都有一个指向函数表的指针，它们的成员函数封装了通过函数表进行访问的 JNI 函数），可以使用 <code>JavaVM</code> 类进行创建和销毁 JavaVM 的操作。理论上，每个进程可以有多个 JavaVM，但 Android 只允许有一个。</p>
<p><code>JNIEnv</code> 的指针将在每个 JNI 函数的第一个参数中。</p>
<p>这个 <code>JNIEnv</code> 只能用于线程本地存储（Thread Local），所以无法在线程之间共享 <code>JNIEnv</code>，如果需要在其他线程中访问 <code>JNIEnv</code>，可以通过 <code>JavaVM</code> 调用 <code>GetEnv</code> 函数获得相应的 <code>JNIEnv</code> 指针（需要在之前使用过 <code>AttachCurrentThread</code> 对此线程进行附加后调用）。</p>
<p><code>JavaVM</code> 指针是全局的，可以在线程之间共享，通过保存 <code>JavaVM</code> 用于在其他线程中获取 <code>JNIEnv</code>。</p>
<p><code>JNIEnv</code> 和 <code>JavaVM</code> 在 C 源文件和 C++ 源文件中的声明不同，使用 C 文件和 C++ 文件包含 <code>jni.h</code> 时，会有不同的类型定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jni.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> _JNIEnv JNIEnv;</span><br><span class="line"><span class="keyword">typedef</span> _JavaVM JavaVM;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNINativeInterface</span>* <span class="title">JNIEnv</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNIInvokeInterface</span>* <span class="title">JavaVM</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>因此，不建议同时在这两种语言包含的头文件中添加 <code>JNIEnv</code> 参数（容易导致混乱）。或者当源文件中出现 <code>#ifdef __cplusplus</code> ，且该文件中所有的内容都引用了 <code>JNIEnv</code> 时，那么可能需要做额外的处理。</p>
<h1 id="JNI-方法注册"><a href="#JNI-方法注册" class="headerlink" title="JNI 方法注册"></a>JNI 方法注册</h1><p>JNI 方法是 Java 代码与 C/C++ 代码沟通的桥梁，使用它时必须首先注册。JNI 方法的声明在 Java 类中，实现在 C/C++ 代码中，在 Java 层的方法声明前面必须添加 <code>native</code> 关键字，然后才能进行注册。</p>
<p>注册方式分为静态注册（根据 JNI 命令规范直接定义对应名字的 C/C++ 函数）和动态注册（使用 <code>RegisterNatives</code> 函数注册到 C/C++ 函数上）两种方式。</p>
<p>例如，Java 声明了如下 JNI 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.l0neman.jniexample.NativeHandler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 期望 JNI 返回一个字符串。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NDK 工程描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/main/</span><br><span class="line"> |</span><br><span class="line"> +-- java</span><br><span class="line"> +-- jni</span><br><span class="line">      |</span><br><span class="line">      +-- Android.mk</span><br><span class="line">      +-- Application.mk</span><br><span class="line">      +-- hello.cpp</span><br><span class="line">      +-- hello.h</span><br></pre></td></tr></table></figure>



<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Android.mk</span></span><br><span class="line"></span><br><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE    := hello</span><br><span class="line">LOCAL_SRC_FILES := hello.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<p>下面将针对上面搭建的 NDK 工程，采用两种方式在 C/C++ 代码中实现 Java 类 <code>NativeHandler</code> 中的 <code>getString</code> 方法并注册。</p>
<h2 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h2><p>静态注册只需要按照 JNI 接口规范，在 C/C++ 代码中声明一个 <code>Java_[全类名中 的 . 替换为 _]_[方法名]</code> 函数，然后添加 <code>JNIEXPORT</code> 前缀即可。</p>
<p>当系统加载 so 文件后，将根据名字对应规则，自动注册 JNI 方法。</p>
<p>下面采用了 C++ 代码描述，其中的函数需要使用 <code>extern &quot;C&quot;</code> 来包括（为了兼容 C 语言的符号签名规则，让 C 语言能够正常链接调用它）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDKTPROJECT_MAIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDKTPROJECT_MAIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_io_l0neman_jniexample_NativeHandler_getString</span><span class="params">(JNIEnv *env, jclass clazz)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//NDKTPROJECT_MAIN_H</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="function">jstring <span class="title">Java_io_l0neman_jniexample_NativeHandler_getString</span><span class="params">(JNIEnv *env, jclass clazz)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是 C 语言代码的实现，那么可以去除 <code>extern &quot;C&quot;</code> 的声明，且返回字符串的代码要改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时 C 语言中的 env 不是类，只是一个指向函数表的指针</span></span><br><span class="line"><span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此时就注册完成了，Java 层可以直接调用 <code>textView.setText(NativeHandler.getString())</code> 进行测试了。</p>
<p>这种注册方式简单直接，但是所有 C/C++ 中实现的 JNI 函数符号都需要被导出，对于逆向人员来说，使用 IDA Pro 可以直接看到注册 JNI 方法的名字，快速定位到对应的 Java 代码。</p>
<h2 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h2><p>动态注册与静态注册不同，它是用 <code>JNIEnv</code> 类型提供的 <code>registerNatives</code> 方法来将 JNI 方法动态绑定到指定的 C/C++ 函数上。</p>
<p>首先需要实现 JNI 提供的标准入口函数，<code>JNI_OnLoad</code>，它将会在调用 <code>System.loadLibrary(&quot;hello&quot;)</code> 后，由 Java 虚拟机进行回调，同时可以实现可选的 <code>JNI_OnUnload</code> 函数，用于虚拟机将动态库卸载时回收资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值表示要使用的 JNI 版本，返回低版本，将不能使用高版本提供的一些 JNI 函数，这里返回当前最高版本 <code>JNI_VERSION_1_6</code>，如果返回其它非版本数值，将导致加载 so 库失败。</p>
<p>完整注册代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *CLASS_NAME = <span class="string">&quot;io/l0neman/jniexample/NativeHandler&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jstring <span class="title">getString</span><span class="params">(JNIEnv *env, jclass nativeHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;getString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, (<span class="keyword">void</span> *) getString&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">  JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (vm-&gt;<span class="built_in">GetEnv</span>((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jclass nativeHandlerClass = env-&gt;<span class="built_in">FindClass</span>(CLASS_NAME);</span><br><span class="line">  <span class="keyword">if</span> (nativeHandlerClass == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jint methods = <span class="built_in"><span class="keyword">sizeof</span></span>(gMethods) / <span class="built_in"><span class="keyword">sizeof</span></span>(JNINativeMethod);</span><br><span class="line">  jint ret = env-&gt;<span class="built_in">RegisterNatives</span>(nativeHandlerClass, gMethods, methods);</span><br><span class="line">  <span class="keyword">if</span> (ret != JNI_OK) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> <span class="title">JNI_OnUnload</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 回收工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>JNI_OnLoad</code> 开始看。</p>
<ol>
<li>首先 <code>RegisterNatives</code> 这个函数由 <code>JNIEnv</code> 类型提供，而 <code>JNI_OnLoad</code> 第一个参数是 <code>JavaVM *</code>，所以，这里首先获取 <code>JNIEnv</code> 类型指针，使用 <code>JavaVM</code> 的 <code>GetEnv</code> 函数获取（由于系统默认已经附加到线程，所以这里才能直接 <code>GetEnv</code>）;</li>
<li>下面需要使用 <code>RegisterNatives</code> 注册 JNI 函数，看一下它的声明：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jni.h</span></span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">RegisterNatives</span><span class="params">(jclass clazz, <span class="keyword">const</span> JNINativeMethod* methods, jint nMethods)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第 1 个参数是 JNI 方法所在的 Java 类，第 2 个是包含需要注册的 JNI 方法对应关系的数组，第 3 个是要注册的 JNI 方法数量或者说前面的数组大小。</p>
<p>那么，就根据要求填充相关参数。</p>
<ol start="3">
<li>使用 <code>JNIEnv</code> 的 <code>FindClass</code> 来获得表示 <code>NativeHandler</code> 类型的 <code>jclass</code>，可以看到描述全类名的方法，将 <code>.</code> 替换为路径符号 <code>/</code> 即可，这样得到了第一个参数；</li>
<li>定义一个 <code>JNINativeMethod</code> 的数组，每个 <code>JNINativeMethod</code> 都用于描述一个 JNI 方法的 Java 方法声明和 C/C++ 函数的一对一关系。</li>
</ol>
<p><code>JNINativeMethod</code> 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jni.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature;</span><br><span class="line">    <span class="keyword">void</span>*       fnPtr;</span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>

<p>分别是 Java 层 JNI 方法的名字，方法签名，和要注册的 C/C++ 函数地址。</p>
<p>在方法签名中，每种 Java 基本类型都有对应的签名字符串，引用类型则为 <code>L[全类型名中的 . 替换为 /];</code>。</p>
<p>JNI 类型签名如下表：</p>
<table>
<thead>
<tr>
<th>签名</th>
<th>Java 类型</th>
</tr>
</thead>
<tbody><tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
</tr>
<tr>
<td>L</td>
<td>引用类型</td>
</tr>
<tr>
<td>[</td>
<td>数组前缀</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> n, String s, <span class="keyword">int</span>[] arr)</span></span>; </span><br></pre></td></tr></table></figure>

<p>签名为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ILjava/lang/String;[I)J </span><br></pre></td></tr></table></figure>

<p>那么前面的代码中的 <code>gMethods</code> 数组，即表明了要把 <code>NativeHandler</code> 中的 <code>getString</code> 注册绑定到 C++ 中的 <code>getString</code> 函数上。</p>
<ol start="5">
<li>最后调用 <code>env-&gt;RegisterNatives</code> 函数就可以了，一般情况下，注册成功，那么返回 <code>JNI_OK</code>。</li>
</ol>
<p>可以允许在 <code>JNI_OnLoad</code> 中绑定多个 Java 类中的 native 方法，建议不要这样做，会导致难以维护。</p>
<p>动态注册的好处是，可以只导出 <code>JNI_OnLoad</code>（注册的 C/C++ 函数可以进行符号优化，不导出），生成速度更快且更小的代码，且可避免与加载到应用中的其他库发生潜在冲突。</p>
<h2 id="类静态方法和类成员方法"><a href="#类静态方法和类成员方法" class="headerlink" title="类静态方法和类成员方法"></a>类静态方法和类成员方法</h2><p>注册 Java 中的静态 JNI 方法和类成员 JNI 方法的区别是，对应的 C/C++ 函数的回调参数不同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.l0neman.jniexample.NativeHander</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeHandler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.<span class="built_in">loadLibrary</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> native String <span class="title">getString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> native String <span class="title">getHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 C++ 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jstring <span class="title">getString</span><span class="params">(JNIEnv *env, jclass nativeHandler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jstring <span class="title">getHello</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line">  jclass nativeHandlerClass = env-&gt;<span class="built_in">GetObjectClass</span>(thiz);</span><br><span class="line">  <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法传递的是代码 Java 类的 <code>jclass</code>，而类方法传递的是表示 Java <code>this</code> 对象的 <code>jobject</code>，可以使用它来访问对应的 <code>this</code> 对象内的成员变量和相关方法。如果需要访问 <code>jclass</code>，使用 JNI 提供的 <code>GetObjectClass</code> 函数获取。</p>
<p>在注册工作完成后，就可以从 Java 层调用 JNI 方法，使用 C/C++ 语言处理逻辑了。</p>
<h1 id="Java-层访问"><a href="#Java-层访问" class="headerlink" title="Java 层访问"></a>Java 层访问</h1><p>在 C/C++ 代码中，需要对 Java 层进行访问，最基本的两种访问操作就是读写 Java 类成员和调用 Java 类方法。</p>
<h2 id="Java-成员变量访问"><a href="#Java-成员变量访问" class="headerlink" title="Java 成员变量访问"></a>Java 成员变量访问</h2><p>JNI 提供了一系列访问 Java 类的静态成员和对象成员的函数，例如。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetStaticIntField</span>();     <span class="comment">// 读取 Java 类型为 int 的类静态成员</span></span><br><span class="line"><span class="built_in">SetStaticIntField</span>();     <span class="comment">// 写入 Java 类型为 int 的类静态成员</span></span><br><span class="line"><span class="built_in">GetStaticObjectField</span>();  <span class="comment">// 读取类型为 Java 引用的类静态成员</span></span><br><span class="line"><span class="built_in">SetStaticObjectField</span>();  <span class="comment">// 写入类型为 Java 引用的类静态成员</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">GetIntField</span>();           <span class="comment">// 读取 Java 类型为 int 的类对象成员</span></span><br><span class="line"><span class="built_in">SetIntField</span>();           <span class="comment">// 写入 Java 类型为 int 的类对象成员</span></span><br><span class="line"><span class="built_in">GetObjectField</span>();        <span class="comment">// 读取类型为 Java 引用的类对象成员</span></span><br><span class="line"><span class="built_in">SetObjectField</span>();        <span class="comment">// 写入类型为 Java 引用的类对象成员</span></span><br></pre></td></tr></table></figure>

<p>总结为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GetStatic&lt;type&gt;<span class="built_in">Field</span>();    <span class="comment">// 读取 Java 类型为 type 的类静态成员</span></span><br><span class="line">SetStatic&lt;type&gt;<span class="built_in">Field</span>();    <span class="comment">// 写入 Java 类型为 type 的类静态成员</span></span><br><span class="line">Get&lt;type&gt;<span class="built_in">Field</span>();          <span class="comment">// 读取 Java 类型为 type 的类对象成员</span></span><br><span class="line">Set&lt;type&gt;<span class="built_in">Field</span>();          <span class="comment">// 写入 Java 类型为 type 的类对象成员</span></span><br></pre></td></tr></table></figure>

<p>当需要访问静态成员时需要提供一个代表 Java 类型的 <code>jclass</code> 作为参数，访问类对象成员时则需要一个表示 Java 对象的 <code>jobject</code> 作为参数。</p>
<p>同时两者都需要首先提供目标 Java 类成员的 JNI 类型签名（符合上面的 JNI 签名表规则），用来获取一个不透明的 <code>jfieldID</code> 类型，传递给 JNI 函数，用于找到目标成员，之后才能使用上述 JNI 函数访问 Java 类成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jfieldID <span class="title">GetStaticFieldID</span><span class="params">(jclass clazz, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* sig)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="Java-类方法访问"><a href="#Java-类方法访问" class="headerlink" title="Java 类方法访问"></a>Java 类方法访问</h2><p>JNI 同时也提供了一系列调用 Java 类的静态方法和对象方法的函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CallStaticVoidMethod</span>(); <span class="comment">// 调用返回值类型为 void 的静态方法</span></span><br><span class="line"><span class="built_in">CallStaticIntMethod</span>();  <span class="comment">// 调用返回值类型为 int 的静态方法</span></span><br><span class="line"><span class="built_in">CallObjectMethod</span>();     <span class="comment">// 调用返回值类型为 Java 引用的静态方法</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CallVoidMethod</span>();       <span class="comment">// 调用返回值类型为 void 的对象方法</span></span><br><span class="line"><span class="built_in">CallIntMethod</span>();        <span class="comment">// 调用返回值类型为 int 的对象方法</span></span><br><span class="line"><span class="built_in">CallObjectMethod</span>();     <span class="comment">// 调用返回值类型为 Java 引用的成员方法</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>总结为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;CallStatic&lt;type&gt;<span class="built_in">Method</span>(); <span class="comment">// 调用返回值类型为 type 的静态方法</span></span><br><span class="line">env-&gt;Call&lt;type&gt;<span class="built_in">Method</span>();       <span class="comment">// 调用返回值类型为 type 的成员方法</span></span><br></pre></td></tr></table></figure>

<p>当需要调用静态方法时需要提供一个代表 Java 类型的 <code>jclass</code> 作为参数，调用类成员方法时则需要一个表示 Java 对象的 <code>jobject</code> 作为参数。</p>
<p>同时两者都需要首先提供目标 Java 方法的 JNI 签名（符合上面的 JNI 签名表规则），用来获取一个不透明的 <code>jMethodID</code> 类型，传递给 JNI 函数，用于找到目标方法，之后才能使用上述 JNI 函数调用 Java 类方法。</p>
<h2 id="Java-层访问实例"><a href="#Java-层访问实例" class="headerlink" title="Java 层访问实例"></a>Java 层访问实例</h2><p>下面对实际的 Java 类成员和方法进行访问和调用。</p>
<p>首先定义一个 Java 类，<code>JniCallExample</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.hexman.jniexample.JniCallExample</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JniCallExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sFlag = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String mData = <span class="string">&quot;info&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setHello</span><span class="params">(String hello)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>.equals(hello);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JniCallExample</code> 类具有一个静态成员 <code>sFlag</code>，和成员变量 <code>mData</code>，还包含一个 <code>getData</code> 成员方法和一个静态方法。</p>
<p>那么下面将进行如下操作：</p>
<ol>
<li>读取 <code>sFlag</code> 的值并打印；</li>
<li>改变 <code>mData</code> 的值，然后调用 Java 层的 <code>getData</code> 方法，获得修改后的值；</li>
<li>调用 Java 层的 <code>sayHello</code> 方法，传递 <code>hello</code> 字符串，获得方法返回值。</li>
</ol>
<p>这里需要在 C/C++ 代码中打印变量，所以需要使用 NDK 提供的 <code>liblog</code> 库，Android.mk 如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE    := hello</span><br><span class="line">LOCAL_SRC_FILES := hello.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此行表示依赖 liblog 库</span></span><br><span class="line">LOCAL_LDLIBS := -llog</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<p>下面开始编写源代码。</p>
<p>首先在 <code>NativeHandler</code> 类里面，声明 JNI 方法 <code>void testAccessJava(JniCallExample jniCallExample)</code>，用于调用 C/C++ 代码来启动测试。</p>
<p>其中提供一个 <code>JniCallExample</code> 对象，是因为需要访问它的成员值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.hexman.jniexample.NativeHandler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">testAccessJava</span><span class="params">(JniCallExample jniCallExample)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 C++ 代码中定义对应的 JNI 方法的实现函数，并在 <code>JNI_OnLoad</code> 中注册函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *CLASS_NAME = <span class="string">&quot;io/l0neman/jniexample/NativeHandler&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;testAccessJava&quot;</span>, <span class="string">&quot;(Lio/l0neman/jniexample/JniCallExample;)V&quot;</span>, (<span class="keyword">void</span> *) testAccessJava&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAccessJava</span><span class="params">(JNIEnv *env, jobject nativeHandler)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">  JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (vm-&gt;<span class="built_in">GetEnv</span>((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jclass nativeHandlerClass = env-&gt;<span class="built_in">FindClass</span>(CLASS_NAME);</span><br><span class="line">  <span class="keyword">if</span> (nativeHandlerClass == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jint methods = <span class="built_in"><span class="keyword">sizeof</span></span>(gMethods) / <span class="built_in"><span class="keyword">sizeof</span></span>(JNINativeMethod);</span><br><span class="line">  jint ret = env-&gt;<span class="built_in">RegisterNatives</span>(nativeHandlerClass, gMethods, methods);</span><br><span class="line">  <span class="keyword">if</span> (ret != JNI_OK) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面填充 <code>testAccessJava</code> 的逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *TAG = <span class="string">&quot;TAJ&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于输出 Java 字符串（mData）的工具函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">utilPrintJavaStr</span><span class="params">(JNIEnv *env, jstring jStr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *mDataCChar = env-&gt;<span class="built_in">GetStringUTFChars</span>(jStr, <span class="literal">nullptr</span>);  <span class="comment">// str+</span></span><br><span class="line">  <span class="comment">// 这里需要把 Java 字符串转为 C 字符串才能输出</span></span><br><span class="line">  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;jniCallExample.mData: %s&quot;</span>, mDataCChar);</span><br><span class="line">  env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(jStr, mDataCChar);                    <span class="comment">// str-</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAccessJava</span><span class="params">(JNIEnv *env, jclass nativeHandler, jobject jniCallExample)</span> </span>&#123;</span><br><span class="line">  jclass jniCallExampleClass = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;io/l0neman/jniexample/JniCallExample&quot;</span>);</span><br><span class="line"></span><br><span class="line">  jfieldID sFlagStaticFieldId = env-&gt;<span class="built_in">GetStaticFieldID</span>(jniCallExampleClass, <span class="string">&quot;sFlag&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">  <span class="comment">// Java: int sFlag = JniCallExample.sFlag;</span></span><br><span class="line">  jint sFlag = env-&gt;<span class="built_in">GetStaticIntField</span>(jniCallExampleClass, sFlagStaticFieldId);</span><br><span class="line">  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;JniCallExample.sFlag: %d&quot;</span>, sFlag);</span><br><span class="line"></span><br><span class="line">  jfieldID mDataFieldId = env-&gt;<span class="built_in">GetFieldID</span>(jniCallExampleClass, <span class="string">&quot;mData&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">  <span class="comment">// Java: newData = &quot;data;</span></span><br><span class="line">  jstring newData = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">  <span class="comment">// Java: jniCallExample.mData = newData;</span></span><br><span class="line">  env-&gt;<span class="built_in">SetObjectField</span>(jniCallExample, mDataFieldId, newData);</span><br><span class="line"></span><br><span class="line">  jmethodID getDataMethodId = env-&gt;<span class="built_in">GetMethodID</span>(jniCallExampleClass, <span class="string">&quot;getData&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">  <span class="comment">// Java: String newMData = jniCallExample.getData();</span></span><br><span class="line">  jstring newMData = (jstring) env-&gt;<span class="built_in">CallObjectMethod</span>(jniCallExample, getDataMethodId);</span><br><span class="line">  <span class="built_in">utilPrintJavaStr</span>(env, newMData);</span><br><span class="line"></span><br><span class="line">  jmethodID setHelloStaticMethodId = env-&gt;<span class="built_in">GetStaticMethodID</span>(jniCallExampleClass, <span class="string">&quot;setHello&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Z&quot;</span>);</span><br><span class="line">  <span class="comment">// JavaL helloParam = &quot;hello&quot;;</span></span><br><span class="line">  jstring helloParam = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="comment">// Java: JniCallExample.setHello(helloParam);</span></span><br><span class="line">  jboolean isSetHello = (jboolean) env-&gt;<span class="built_in">CallStaticBooleanMethod</span>(jniCallExampleClass, setHelloStaticMethodId, helloParam);</span><br><span class="line">  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;isSetHello %d&quot;</span>, isSetHello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JniCallExample.sFlag: 256</span><br><span class="line">jniCallExample.mData: data</span><br><span class="line">isSetHello 1</span><br></pre></td></tr></table></figure>



<p>其中注释 <code>Java: xxx</code> 表示与 Java 代码有相同作用。</p>
<p>其中包含一部分对于字符串的操作：</p>
<p><code>env-&gt;NewStringUTF(&quot;data&quot;)</code> 用于创建一个 Java 字符串（new String()），它的内存由 Java 虚拟机管理，它使用 <code>jstring</code> 类型来描述，是一个 JNI 提供的不透明类型，用于映射一个 Java 字符串。每种 Java 类型都有对应的映射类型（下面会提供映射表），这里用作 Java 变量来给 Java 变量赋值或者作为参数传递。</p>
<p><code>env-&gt;GetStringUTFChars(jStr, nullptr);</code> 用于从 Java 字符串中取得 C 形式的 Modified_UTF-8（下文介绍）字符串，它将会在 native 层分配内存，而不是由 Java 虚拟机管理，所以使用后需要手动使用 <code>ReleaseStringUTFChars</code> 释放。</p>
<h2 id="访问优化"><a href="#访问优化" class="headerlink" title="访问优化"></a>访问优化</h2><p>在对 Java 层进行访问时，不管是访问 Java 类成员还是调用 Java 方法，都需要首先使用 <code>FindClass</code> 找到目标 Java 类，然后获取对应的成员 ID 和方法 ID， 对于 <code>FindClass</code> 和查找相关 ID 的函数，每次调用它们可能都需要进行多次的字符串比较，而使用这些 ID 去访问对于的 Java 类成员和方法速度却是很快的。</p>
<p>那么如果需要多次访问相同的 Java 目标，那么考虑将这些 <code>jclass</code>（FindClass 的结果）和相关 ID 缓存起来。 这些变量在被访问的 Java 类被卸载之前保证是有效的。只有在与 ClassLoader 关联的所有类都满足垃圾回收条件时，系统才会卸载这些类，这种情况比较少见，但在 Android 中是有可能出现的。</p>
<p>Android 推荐的方法是，在 Java 类中声明一个名叫 <code>nativeInit</code> 的 JNI 方法，在类的静态块内调用，这个 JNI 方法就负责提前缓存要使用的 Java 类型，那么一个类被加载时，<code>nativeInit</code> 就会被调用。</p>
<p>可以在 Android 系统源码中看到许多名叫 <code>nativeInit</code> 的 JNI 方法，它们就是负责此用途的。</p>
<p>一般使用 <code>static</code> 结构来缓存这些 ID 和 <code>jclass</code>，<code>jclass</code> 作为 Java 引用，需要使用 <code>NewGlobalRef</code> 函数创建一个全局引用来保护它不被回收。</p>
<p>那么现在改进之前的 Java 访问实例，如下：</p>
<p>首先在 <code>NativeHandler</code> 中增加 <code>nativeInit</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.hexman.jniexample.NativeHandler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    nativeInit();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">testAccessJava</span><span class="params">(JniCallExample jniCallExample)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是源代码，注册部分只修改 <code>JNINativeMethod</code> 数组即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;testAccessJava&quot;</span>, <span class="string">&quot;(Lio/l0neman/jniexample/JniCallExample;)V&quot;</span>, (<span class="keyword">void</span> *) testAccessJava&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeInit&quot;</span>,     <span class="string">&quot;()V&quot;</span>,                                       (<span class="keyword">void</span> *) nativeInit&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后是 <code>nativeInit</code> 的逻辑和修改过的 <code>testAccessJava</code> 函数的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JniCallExampleHolder</span> &#123;</span></span><br><span class="line">    jclass jniCallExampleClass;</span><br><span class="line">    jfieldID sFlagStaticFieldId;</span><br><span class="line">    jfieldID mDataFieldId;</span><br><span class="line">    jmethodID getDataMethodId;</span><br><span class="line">    jmethodID setHelloStaticMethodId;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JniCallExampleHolder gJniCallExampleHolder;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前缓存 jclass 和访问 ID</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nativeInit</span><span class="params">(JNIEnv *env, jclass clazz)</span> </span>&#123;</span><br><span class="line">  jclass jniCallExampleClass = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;io/l0neman/jniexample/JniCallExample&quot;</span>);</span><br><span class="line">  gJniCallExampleHolder.jniCallExampleClass = (jclass) env-&gt;<span class="built_in">NewGlobalRef</span>(jniCallExampleClass);   <span class="comment">// gr+</span></span><br><span class="line">  gJniCallExampleHolder.sFlagStaticFieldId = env-&gt;<span class="built_in">GetStaticFieldID</span>(jniCallExampleClass, <span class="string">&quot;sFlag&quot;</span>, <span class="string">&quot;I&quot;</span>);;</span><br><span class="line">  gJniCallExampleHolder.mDataFieldId = env-&gt;<span class="built_in">GetFieldID</span>(jniCallExampleClass, <span class="string">&quot;mData&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">  gJniCallExampleHolder.getDataMethodId = env-&gt;<span class="built_in">GetMethodID</span>(jniCallExampleClass, <span class="string">&quot;getData&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);;</span><br><span class="line">  gJniCallExampleHolder.setHelloStaticMethodId = env-&gt;<span class="built_in">GetStaticMethodID</span>(jniCallExampleClass, <span class="string">&quot;setHello&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Z&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAccessJava</span><span class="params">(JNIEnv *env, jclass nativeHandler, jobject jniCallExample)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java: int sFlag = JniCallExample.sFlag;</span></span><br><span class="line">  jint sFlag = env-&gt;<span class="built_in">GetStaticIntField</span>(gJniCallExampleHolder.jniCallExampleClass,</span><br><span class="line">                                      gJniCallExampleHolder.sFlagStaticFieldId);</span><br><span class="line">  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;JniCallExample.sFlag: %d&quot;</span>, sFlag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java: newData = &quot;data;</span></span><br><span class="line">  jstring newData = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">  <span class="comment">// Java: jniCallExample.mData = newData;</span></span><br><span class="line">  env-&gt;<span class="built_in">SetObjectField</span>(jniCallExample, gJniCallExampleHolder.mDataFieldId, newData);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java: String newMData = jniCallExample.getData();</span></span><br><span class="line">  jstring newMData = (jstring) env-&gt;<span class="built_in">CallObjectMethod</span>(jniCallExample, gJniCallExampleHolder.getDataMethodId);</span><br><span class="line">  <span class="built_in">utilPrintJavaStr</span>(env, newMData);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JavaL helloParam = &quot;hello&quot;;</span></span><br><span class="line">  jstring helloParam = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="comment">// Java: JniCallExample.setHello(helloParam);</span></span><br><span class="line">  jboolean isSetHello = (jboolean) env-&gt;<span class="built_in">CallStaticBooleanMethod</span>(gJniCallExampleHolder.jniCallExampleClass,</span><br><span class="line">                                                                gJniCallExampleHolder.setHelloStaticMethodId,</span><br><span class="line">                                                                helloParam);</span><br><span class="line">  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;isSetHello %d&quot;</span>, isSetHello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一个地方使用了 <code>env-&gt;NewGlobalRef</code> 建立了一个全局引用，它会保护这个 <code>jclass</code> 不会在 JNI 函数执行完之后被回收，注意需要在不使用的时候使用 <code>env-&gt;DeleteGlobalRef</code> 释放引用，例如 <code>JNI_OnUnload</code> 中。</p>
<h2 id="JNI-类型"><a href="#JNI-类型" class="headerlink" title="JNI 类型"></a>JNI 类型</h2><p>每种 Java 类型在 JNI 中都有对应的本地数据类型，C/C++ 通过 JNI 方法与 Java 层进行交互时，均是使用这些类型进行参数传递，此时虚拟机再根据每种类型翻译为相应的 Java 类型传递给 Java 层方法.</p>
<p>还有一些特殊的数据类型用来存储 Java 方法 ID 和类成员 ID。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><table>
<thead>
<tr>
<th>Java 类型</th>
<th>本地类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>jboolean</td>
<td>unsigned 8 bits</td>
</tr>
<tr>
<td>byte</td>
<td>jbyte</td>
<td>signed 8 bits</td>
</tr>
<tr>
<td>char</td>
<td>jchar</td>
<td>signed 16 bits</td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>signed 16 bits</td>
</tr>
<tr>
<td>int</td>
<td>jint</td>
<td>signed 32 bits</td>
</tr>
<tr>
<td>long</td>
<td>jlong</td>
<td>signed 64 bits</td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>32 bits</td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>64 bits</td>
</tr>
<tr>
<td>void</td>
<td>void</td>
<td>无</td>
</tr>
</tbody></table>
<p><code>jboolean</code> 的两种取值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_FALSE  0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_TRUE   1 </span></span><br></pre></td></tr></table></figure>

<p><code>jsize</code> 类型用于描述数组大小或者索引。</p>
<p>从 <code>jni.h</code> 中看它们和真实 C/C++ 数据类型的对应关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jni.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Primitive types that match up with Java equivalents. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span>  jboolean; <span class="comment">/* unsigned 8 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int8_t</span>   jbyte;    <span class="comment">/* signed 8 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> jchar;    <span class="comment">/* unsigned 16 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int16_t</span>  jshort;   <span class="comment">/* signed 16 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span>  jint;     <span class="comment">/* signed 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span>  jlong;    <span class="comment">/* signed 64 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span>    jfloat;   <span class="comment">/* 32-bit IEEE 754 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span>   jdouble;  <span class="comment">/* 64-bit IEEE 754 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &quot;cardinal indices and sizes&quot; */</span></span><br><span class="line"><span class="keyword">typedef</span> jint     jsize;</span><br></pre></td></tr></table></figure>



<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>在 C++ 中，Java 引用类型使用一些类表示，它们的继承关系如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobject</span>                     (所有 Java 对象)</span><br><span class="line"> |</span><br><span class="line"> +-- <span class="built_in">jclass</span>                (java.lang.Class 对象)</span><br><span class="line"> +-- <span class="built_in">jstring</span>               (java.lang.String 对象)</span><br><span class="line"> +-- <span class="built_in">jarray</span>                (数组)</span><br><span class="line"> |    |</span><br><span class="line"> |    +-- <span class="built_in">jobjectArray</span>     (object 数组)</span><br><span class="line"> |    +-- <span class="built_in">jbooleanArray</span>    (boolean 数组)</span><br><span class="line"> |    +-- <span class="built_in">jbyteArray</span>       (byte 数组)</span><br><span class="line"> |    +-- <span class="built_in">jcharArray</span>       (<span class="keyword">char</span> 数组)</span><br><span class="line"> |    +-- <span class="built_in">jshortArray</span>      (<span class="keyword">short</span> 数组)</span><br><span class="line"> |    +-- <span class="built_in">jintArray</span>        (<span class="keyword">int</span> 数组)</span><br><span class="line"> |    +-- <span class="built_in">jlongArray</span>       (<span class="keyword">long</span> 数组)</span><br><span class="line"> |    +-- <span class="built_in">jfloatArray</span>      (<span class="keyword">float</span> 数组)</span><br><span class="line"> |    +-- <span class="built_in">jdoubleArray</span>     (<span class="keyword">double</span> 数组)</span><br><span class="line"> |</span><br><span class="line"> +- <span class="built_in">jthrowable</span>             (java.lang.Throwable 对象)</span><br></pre></td></tr></table></figure>



<p>源码中定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jni.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jobject</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jclass</span> :</span> <span class="keyword">public</span> _jobject &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jstring</span> :</span> <span class="keyword">public</span> _jobject &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jarray</span> :</span> <span class="keyword">public</span> _jobject &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jobjectArray</span> :</span> <span class="keyword">public</span> _jarray &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jbooleanArray</span> :</span> <span class="keyword">public</span> _jarray &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jbyteArray</span> :</span> <span class="keyword">public</span> _jarray &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jcharArray</span> :</span> <span class="keyword">public</span> _jarray &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jshortArray</span> :</span> <span class="keyword">public</span> _jarray &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jintArray</span> :</span> <span class="keyword">public</span> _jarray &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jlongArray</span> :</span> <span class="keyword">public</span> _jarray &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jfloatArray</span> :</span> <span class="keyword">public</span> _jarray &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jdoubleArray</span> :</span> <span class="keyword">public</span> _jarray &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jthrowable</span> :</span> <span class="keyword">public</span> _jobject &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> _jobject*       jobject;</span><br><span class="line"><span class="keyword">typedef</span> _jclass*        jclass;</span><br><span class="line"><span class="keyword">typedef</span> _jstring*       jstring;</span><br><span class="line"><span class="keyword">typedef</span> _jarray*        jarray;</span><br><span class="line"><span class="keyword">typedef</span> _jobjectArray*  jobjectArray;</span><br><span class="line"><span class="keyword">typedef</span> _jbooleanArray* jbooleanArray;</span><br><span class="line"><span class="keyword">typedef</span> _jbyteArray*    jbyteArray;</span><br><span class="line"><span class="keyword">typedef</span> _jcharArray*    jcharArray;</span><br><span class="line"><span class="keyword">typedef</span> _jshortArray*   jshortArray;</span><br><span class="line"><span class="keyword">typedef</span> _jintArray*     jintArray;</span><br><span class="line"><span class="keyword">typedef</span> _jlongArray*    jlongArray;</span><br><span class="line"><span class="keyword">typedef</span> _jfloatArray*   jfloatArray;</span><br><span class="line"><span class="keyword">typedef</span> _jdoubleArray*  jdoubleArray;</span><br><span class="line"><span class="keyword">typedef</span> _jthrowable*    jthrowable;</span><br><span class="line"><span class="keyword">typedef</span> _jobject*       jweak;</span><br></pre></td></tr></table></figure>



<p>在 C 语言中，所有 JNI 引用类型都与 jobject 的定义相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jni.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>*           jobject;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jclass;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jstring;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jarray;</span><br><span class="line"><span class="keyword">typedef</span> jarray          jobjectArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray          jbooleanArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray          jbyteArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray          jcharArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray          jshortArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray          jintArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray          jlongArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray          jfloatArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray          jdoubleArray;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jthrowable;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jweak;</span><br></pre></td></tr></table></figure>



<h3 id="方法和类成员-ID"><a href="#方法和类成员-ID" class="headerlink" title="方法和类成员 ID"></a>方法和类成员 ID</h3><p>它们是不透明结构体指针类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jni.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">jfieldID</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">jfieldID</span> *<span class="title">jfieldID</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">jmethodID</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">jmethodID</span> *<span class="title">jmethodID</span>;</span></span><br></pre></td></tr></table></figure>



<h3 id="数组元素"><a href="#数组元素" class="headerlink" title="数组元素"></a>数组元素</h3><p><code>jvalue</code> 用于作为参数数组中的元素类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jni.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">jvalue</span> &#123;</span></span><br><span class="line">    jboolean    z;</span><br><span class="line">    jbyte       b;</span><br><span class="line">    jchar       c;</span><br><span class="line">    jshort      s;</span><br><span class="line">    jint        i;</span><br><span class="line">    jlong       j;</span><br><span class="line">    jfloat      f;</span><br><span class="line">    jdouble     d;</span><br><span class="line">    jobject     l;</span><br><span class="line">&#125; jvalue;</span><br></pre></td></tr></table></figure>



<h2 id="引用管理"><a href="#引用管理" class="headerlink" title="引用管理"></a>引用管理</h2><p>Java 对象在 JNI 中有两种引用方式，一种是局部引用；一种是全局引用。</p>
<h3 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h3><p>Java 层通过 JNI 方法传递给 C/C++ 函数的每个对象参数，以及 C/C++ 通过 JNI 函数（<code>Call&lt;type&gt;Method</code>）调用接收的 Java 方法的对象返回值都属于局部引用。</p>
<p>局部引用仅在当前线程中的当前 C/C++ 函数运行期间有效。在 C/C++ 函数返回后，即使对象本身继续存在，该引用也无效。</p>
<p>局部引用适用于 <code>jobject</code> 的所有子类，包括 <code>jclass</code>、<code>jstring</code> 和 <code>jarray</code>。</p>
<h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><p>创建全局引用只能使用 <code>NewGlobalRef</code> 和 <code>NewWeakGlobalRef</code> 函数。</p>
<p>如果希望长时间的持有某个引用，那么必须使用全局引用，使用 <code>NewGlobalRef</code> 函数时将局部引用作为参数传入，换取全局引用。在调用 <code>DeleteGlobalRef</code> 删除全局引用之前，此引用保证有效。</p>
<p>通常用于缓存 <code>FindClass</code> 返回的 <code>jclass</code>，就像前面的 Java 访问优化中所做的措施一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jclass localClass = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;MyClass&quot;</span>);</span><br><span class="line">jclass globalClass = <span class="keyword">reinterpret_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(localClass)); </span><br></pre></td></tr></table></figure>



<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于同一个对象的引用可能存在多个不同的值，例如，对于同一个对象多次调用 <code>NewGlobalRef</code> 所返回的值可能不同。</p>
<p>如果需要比较两个引用是否指向同一个对象，必须使用 <code>IsSameObject</code> 函数，切勿在 C/C++ 代码中使用 <code>==</code> 比较各个引用。</p>
<p>在两次调用 <code>NewGlobalRef</code> 对同一个对象创建全局引用时，表示这个对象的 32 位值可能不同；而在多次调用 <code>NewGlobalRef</code> 创建不同对象的全局引用时，它们可能具有相同的 32 位值，所以不能将 <code>jobject</code> 用作 key 使用。</p>
<p>不要过度分配局部引用，如果需要创建大量引用，应该主动调用 <code>DeleteLocalRef</code> 删除它们，而不是期望 JNI 自动删除。JNI 默认实现只能保留 16 个局部引用，如果需要保存更多数量，可以按照需要删除，或使用 <code>EnsureLocalCapacity/PushLocalFrame</code> 申请保留更多引用数量。</p>
<p><code>jfieldID</code> 和 <code>jmethodID</code> 为不透明类型，不属于对象引用，所以不能使用 <code>NewGlobalRef</code> 保护。<code>GetStringUTFChars</code> 和 <code>GetByteArrayElements</code> 返回的原始数据指针也不属于对象。</p>
<p>一种特殊情况是，如果使用 <code>AttachCurrentThread</code> 附加到 C/C++ 线程，那么在线程分离之前，运行中的代码一定不会自动释放局部引用。代码创建的任何局部引用都必须手动删除。通常，在循环中创建局部引用的任何 C/C++ 代码需要执行某些手动删除操作。</p>
<p>谨慎使用全局引用。全局引用不可避免，但它们很难调试，并且可能会导致难以诊断的内存（不良）行为。在所有其他条件相同的情况下，全局引用越少，解决方案的效果可能越好。</p>
<h1 id="Java-常用数据访问"><a href="#Java-常用数据访问" class="headerlink" title="Java 常用数据访问"></a>Java 常用数据访问</h1><p>对 Java 字符串和数组的访问方法。访问这些数据是 JNI 开发的基础。</p>
<h2 id="访问字符串"><a href="#访问字符串" class="headerlink" title="访问字符串"></a>访问字符串</h2><p>访问字符串有如下两种情况：</p>
<ol>
<li>Java 层调用 JNI 方法，String 对象以 <code>jstring</code> 的形式传入 JNI 方法，此时 C/C++ 语言接收使用；</li>
<li>C/C++ 产生字符串数据，返回给 Java 层使用。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java Code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hello = &quot;result&quot;</span></span><br><span class="line"><span class="keyword">final</span> String hello = NativeHandler.testAccessString(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Code</span></span><br><span class="line"></span><br><span class="line"><span class="function">jstring <span class="title">testAccessString</span><span class="params">(JNIEnv *env, jclass clazz, jstring hello)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *stringChars = env-&gt;<span class="built_in">GetStringUTFChars</span>(hello, <span class="literal">nullptr</span>);  <span class="comment">// str+</span></span><br><span class="line">  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;java string: %s&quot;</span>, stringChars);</span><br><span class="line">  env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(hello, stringChars);                    <span class="comment">// str-</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取字符串"><a href="#获取字符串" class="headerlink" title="获取字符串"></a>获取字符串</h3><p><code>GetStringUTFChars</code> 将返回 C/C++ 语言可以直接使用的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html#wp16542">Modified_UTF-8</a> 格式字符串（Modified_UTF-8 格式是 JNI 提供的优化后的 UTF-8 格式字符串，优化后的编码对 C 代码友好，因为它将 <code>\u0000</code> 编码为 <code>0xc0 0x80</code>，而不是 <code>0x00</code>。这样做的好处是，可以依靠以 <code>\0</code> 终止的 C 样式字符串，非常适合与标准 libc 字符串函数配合使用。但缺点是，无法将任意 UTF-8 的数据传递给 JNI 函数）。</p>
<p>在使用 <code>GetStringUTFChars</code> 获取字符串后，JavaVM 为字符串在 native 层分配了内存，在字符串使用完毕后，必须使用 <code>ReleaseStringUTFChars</code> 释放内存，否则将会造成内存泄漏。</p>
<p>从 C/C++ 获取 Java 字符串的长度有两种方式，可直接使用 <code>GetStringUTFLength</code> 对 <code>jstring</code> 计算长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java Code</span></span><br><span class="line"></span><br><span class="line">jstring hello;</span><br><span class="line">jsize utfLength = env-&gt;<span class="built_in">GetStringUTFLength</span>(hello);</span><br></pre></td></tr></table></figure>

<p>或者使用 C/C++ 的 <code>strlen</code> 计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *stringChars = env-&gt;<span class="built_in">GetStringUTFChars</span>(hello, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">size_t</span> utfLength = <span class="built_in">strlen</span>(stringChars);</span><br></pre></td></tr></table></figure>

<p><code>GetStringUTFChars</code> 函数的第 2 个参数是一个 <code>jboolean</code> 类型的指针，表示关心是否创建了字符串的副本，如果创建了字符串的副本它会返回 <code>JNI_TRUE</code>，否则为 <code>JNI_FALSE</code>，不管是否创建，都需要 Release 操作，所以一般不会关心它的结果，传递 <code>nullptr</code> 即可（C 语言传递 <code>NULL</code>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Code</span></span><br><span class="line"></span><br><span class="line">jboolean isCopy;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *stringChars = env-&gt;<span class="built_in">GetStringUTFChars</span>(hello,);  <span class="comment">// str+</span></span><br><span class="line"><span class="keyword">if</span> (isCopy == JNI_TRUE) &#123;</span><br><span class="line">  <span class="comment">// 创建了字符串副本</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCopy == JNI_FALSE) &#123;</span><br><span class="line">  <span class="comment">// 未创建字符串副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h3><p>JNI 还提供了 <code>GetStringChars</code> 函数，它返回的是 UTF-16 字符串，使用 UTF-16 字符串执行操作通常会更快，但是 UTF-16 字符串不是以零终止的，并且允许使用 <code>\u0000</code>，因此需要保留字符串长度和返回的 <code>jchar</code> 指针。</p>
<p>一般的开发中几乎都使用 <code>GetStringUTFChars</code> 获取字符串。</p>
<h3 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h3><p>如果需要返回给 Java 层字符串，使用 <code>env-&gt;NewStringUTF(&quot;result&quot;)</code> 即可，JavaVM 将会基于 C 字符串创建一个新的 <code>String</code> 的对象，它的内存由虚拟机管理。</p>
<p>注意传递给 <code>NewStringUTF</code> 的数据必须采用 Modified_UTF-8 格式。一种常见的错误是从文件或网络数据流中读取字符数据，在未过滤的情况下将其传递给 <code>NewStringUTF</code>。除非确定数据是有效的 Modified_UTF-8 格式（或 7 位 ASCII，这是一个兼容子集），否则需要剔除无效字符或将它们转换为适当的 Modified_UTF-8 格式。如果不这样做，UTF-16 转换可能会产生意外的结果（Java 语言使用的是 UTF-16）。默认状态下 CheckJNI 会为模拟器启用，它会扫描并在收到无效字符串输入时中止虚拟机。</p>
<h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p>和访问 Java 成员类似，JNI 提供了一系列访问数组的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetIntArrayElements</span>();</span><br><span class="line"><span class="built_in">GetBooleanArrayElements</span>();</span><br><span class="line"><span class="built_in">GetDoubleArrayElements</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>总结为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get&lt;type&gt;<span class="built_in">ArrayElements</span>();</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;type&gt;</code> 中只能是 Java 的基本类型，不包含 <code>String</code> 以及其他引用类型。</p>
<p>下面分别使用 C/C++ 获取 Java 传递的 <code>int</code> 类型和 <code>String</code> 的数组，作为获取 Java 基本类型和引用类型数组的典型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java Code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] array0 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">String[] array1 = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>&#125;;</span><br><span class="line">NativeHandler.testAccessArray(array0, array1);</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Code</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAccessArray</span><span class="params">(JNIEnv *env, jclass clazz, jintArray array0, jobjectArray array1)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 访问原始数组</span></span><br><span class="line">  jint *elements0 = env-&gt;<span class="built_in">GetIntArrayElements</span>(array0, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span>(elements0 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    jsize array0Length = env-&gt;<span class="built_in">GetArrayLength</span>(array0);</span><br><span class="line">    <span class="keyword">for</span> (jint i = <span class="number">0</span>; i &lt; array0Length; i++) &#123;</span><br><span class="line">      __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;array0[%d] = %d&quot;</span>, i, elements0[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;<span class="built_in">ReleaseIntArrayElements</span>(array0, elements0, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问对象数组</span></span><br><span class="line">  jsize array1Length = env-&gt;<span class="built_in">GetArrayLength</span>(array1);</span><br><span class="line">  <span class="keyword">for</span> (jint i = <span class="number">0</span>; i &lt; array1Length; i++) &#123;</span><br><span class="line">    jstring element = (jstring) env-&gt;<span class="built_in">GetObjectArrayElement</span>(array1, i);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *chars = env-&gt;<span class="built_in">GetStringUTFChars</span>(element, <span class="literal">nullptr</span>);  <span class="comment">// str+</span></span><br><span class="line">    __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;array1[%d] = %s&quot;</span>, i, chars);</span><br><span class="line">    env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(element, chars);                    <span class="comment">// str-</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array0[0] = 1</span><br><span class="line">array0[1] = 2</span><br><span class="line">array0[2] = 3</span><br><span class="line">array0[3] = 4</span><br><span class="line">array0[4] = 5</span><br><span class="line">array1[0] = a</span><br><span class="line">array1[1] = b</span><br><span class="line">array1[2] = c</span><br><span class="line">array1[3] = d</span><br><span class="line">array1[4] = e</span><br></pre></td></tr></table></figure>

<p>代码比较清晰，可以看到基本类型的数组，直接可以使用 <code>Get&lt;type&gt;ArrayElements(...)</code> 获得一个数组的首地址，使用 <code>GetArrayLength</code> 获取数组长度后，即可像 C/C++ 原生数组一样使用指针遍历每一个元素。</p>
<p>在对原生类型的数组访问之后，需要调用 <code>Release&lt;type&gt;ArrayElements</code> 请求释放内存。</p>
<p>对象数组则没有提供 <code>Get&lt;type&gt;ArrayElements(...)</code> 的方法，但是它提供了获取单个元素的 <code>GetObjectArrayElement</code> 方法，那么也可以使用循环获取每个 <code>jobject</code> 元素，然后转换为原本的类型。</p>
<p>如果需要更改原生类型的数组元素值，直接修改获取 C/C++ 数组元素的值，JNI 将会把值复制回原始数据区中。</p>
<p>如果需要更改引用类型的数组元素值，JNI 提供了 <code>SetObjectArrayElement</code> 函数，可直接修改原始元素对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;<span class="built_in">SetObjectArrayElement</span>(array1, <span class="number">1</span>, env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;hello&quot;</span>));</span><br></pre></td></tr></table></figure>



<h3 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h3><p>JNI 为了在不限制虚拟机实现的情况下使接口尽可能高效，允许 <code>Get&lt;type&gt;ArrayElements(...)</code> 函数的调用在运行时直接返回指向实际数据元素的指针，或者分配一些内存创建数据的副本。</p>
<p>在调用 Release 之前，返回的原生数组指针保证可用，如果没有创建数据的副本，那么原生数组将被固定，在虚拟机整理内存碎片时不会调整原生数组的位置，Release 的时候需要进行判空操作，防止在 Get 数组失败时 Release 空指针。</p>
<p><code>ReleaseIntArrayElements</code> 函数的最后一个函数的 <code>mode</code> 参数有三个，运行时执行的操作取决于返回的指针指向实际数据还是指向数据副本。</p>
<p><code>mode</code> 以及对应的 Release 行为：</p>
<ol>
<li><code>0</code></li>
</ol>
<p>实际数据：取消数组元素固定。<br>数据副本：将数据复制回原始数据，释放包含副本的缓冲区。</p>
<ol start="2">
<li><code>JNI_COMMIT</code></li>
</ol>
<p>实际数据：不执行任何操作。<br>数据副本：将数据复制回原始数据，不释放包含副本的缓冲区。</p>
<ol start="3">
<li><code>JNI_ABORT</code></li>
</ol>
<p>实际数据：取消数组元素固定，不中止早期的写入数据。<br>数据副本：释放包含相应副本的缓冲区；对该副本所做的任何更改都会丢失。</p>
<p>通常传递 <code>0</code> 来保持固定和复制数组的行为一致，其他选项可以用来更好地控制内存，需要谨慎传递。</p>
<p>其中 <code>GetIntArrayElements</code> 的第 2 个参数，它类似于 <code>GetStringUTFChars</code> 的第 2 个参数，也是 <code>isCopy</code>，表示获取数组时是否创建了数据副本。</p>
<p>通常检查 <code>isCopy</code> 标志的原因有两个：</p>
<ol>
<li>了解是否需要在对数组进行更改后使用 <code>JNI_COMMIT</code> 调用 Release 函数，如果需要在对数组进行更改和仅使用数组内容的代码之间切换，则可以跳过释放缓冲区提交（更改数组数据后需要继续访问数组）；</li>
<li>有效处理 <code>JNI_ABORT</code>，考虑可能需要获取一个数组，然后进行适当修改后，将数组的一部分传递给其他函数使用，最后舍弃对数组的修改。如果知道 JNI 为数组创建了副本，那么就不需要自己创建一个可被修改的副本，如果 JNI 传递的是实际数据的指针，那么就需要自己创建数组的副本。</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>不能认为 <code>*isCopy</code> 为 <code>JNI_FALSE</code> 时就不需要调用 Release，这是一种常见误区。</p>
<p>如果 JNI 没有分配任何副本缓冲区，返回指向实际数据的指针，那么虚拟机必须固定实际数组的内存，此时垃圾回收器将不能移动内存，造成内存不能释放。</p>
<p><code>JNI_COMMIT</code> 标记不会释放数组，最终还需要使用其他标记再次调用 Release。</p>
<h3 id="数组区域调用"><a href="#数组区域调用" class="headerlink" title="数组区域调用"></a>数组区域调用</h3><p>如果只想复制 Java 数组，使用 <code>Get&lt;type&gt;ArrayRegion</code> 更好。</p>
<p>通常使用 <code>Get&lt;type&gt;ArrayElements</code> 时，如果需要复制数组数据到外部的缓冲区中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jbyte* data = env-&gt;<span class="built_in">GetByteArrayElements</span>(array, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(buffer, data, len);</span><br><span class="line">  env-&gt;<span class="built_in">ReleaseByteArrayElements</span>(array, data, JNI_ABORT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样会复制数组 <code>len</code> 长度的字节到 <code>buffer</code> 中，然后释放数组内存。其中 Get 调用可能会返回实际数组或者实际数组的副本，取决于运行时的情况，代码复制数据（那么上面的代码可能是第 2 次复制），那么这种情况下，使用 <code>JNI_ABORT</code> 确保不会再出现第 3 次复制。</p>
<p>使用 <code>Get&lt;type&gt;ArrayRegion</code> 函数不仅可以完成相同操作，而且不必考虑 Release 调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制数组 len 长度的字节到缓冲区 buffer 中</span></span><br><span class="line">env-&gt;<span class="built_in">GetByteArrayRegion</span>(array, <span class="number">0</span>, len, buffer);</span><br></pre></td></tr></table></figure>

<p>区域调用优点：</p>
<ol>
<li>只需要一个 JNI 调用，而不是两个，减少开销；</li>
<li>不需要固定实际数组或额外复制数据；</li>
<li>降低风险，不存在操作失败后忘记调用 Release 的风险。</li>
</ol>
<p>除此之外，JNI 还提供了针对于字符串的区域调用函数，<code>GetStringUTFRegion</code> 或 <code>GetStringRegion</code> 将字符数据复制到 <code>String</code> 对象之外。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>所有线程都是 Linux 线程，由内核调度。线程通常从受虚拟机管理的代码启动（使用 <code>Thread#start()</code> 方法），但也可以在 native 层创建，然后通过 JNI 函数附加到 JavaVM。在 C/C++ 代码中例如使用 <code>pthread_create</code> 启动本地线程，然后调用 JNI 提供的 <code>AttachCurrentThread</code> 或 <code>AttachCurrentThreadAsDeamon</code> 函数，在附加之前，这个线程不会包含任何 <code>JNIEnv</code>，所以无法调用 <code>JNI</code>（<code>JNIEnv</code> 指针不能在多个线程中共享，只能分别附加，主线程默认已被附加）。</p>
<p>被附加成功的本地线程会构建 <code>java.lang.Thread</code> 对象并被添加到 Main ThreadGroup，从而使调试程序能够看到它。在已附加的线程上调用 <code>AttachCurrentThread</code> 属于空操作。</p>
<p>通过 JNI 附加的线程在退出之前必须调用 <code>DetachCurrentThread</code> 分离附加。如果直接对此进行编写代码会很麻烦，可以使用 <code>pthread_key_create</code> 定义在线程退出之前调用的析构函数，之后再调用 <code>DetachCurrentThread</code>。（将该 key 与 <code>pthread_setspecific</code> 配合使用，以将 <code>JNIEnv</code> 存储在线程本地存储中；这样一来，该 key 将作为参数传递到线程的析构函数中。）</p>
<h3 id="附加到本地线程"><a href="#附加到本地线程" class="headerlink" title="附加到本地线程"></a>附加到本地线程</h3><p>下面是一个附加到线程的示例，使用 <code>pthread_create</code> 创建一个线程，并在线程执行代码中附加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java Code:</span></span><br><span class="line"></span><br><span class="line">NativeHandler.testThread();</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Code:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">threadTest</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 尝试获得已附加的 JNIEnv</span></span><br><span class="line">  jint ret = gJavaVM-&gt;<span class="built_in">GetEnv</span>((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6);</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ret) &#123;</span><br><span class="line">    <span class="keyword">case</span> JNI_OK:</span><br><span class="line">      __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;获得了 JNIEnv.&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> JNI_EDETACHED:</span><br><span class="line">      ret = gJavaVM-&gt;<span class="built_in">AttachCurrentThread</span>(&amp;env, <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">if</span> (ret == JNI_OK) &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;线程已附加. %ld&quot;</span>, (<span class="keyword">long</span>) <span class="built_in">pthread_getspecific</span>(gKey));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_ERROR, TAG, <span class="string">&quot;线程附加失败，code: %d.&quot;</span>, ret);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> JNI_EVERSION:</span><br><span class="line">      __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;错误 JNI_EVERSION.&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __android_log_print(ANDROID_LOG_ERROR, TAG, <span class="string">&quot;未知错误：%d&quot;</span>, ret);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程销毁函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadDestroy</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">  jint ret = gJavaVM-&gt;<span class="built_in">GetEnv</span>((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == JNI_OK) &#123;</span><br><span class="line">    __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;线程分离.&quot;</span>);</span><br><span class="line">    gJavaVM-&gt;<span class="built_in">DetachCurrentThread</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testThread</span><span class="params">(JNIEnv *env, jclass clazz)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 JavaVM 指针</span></span><br><span class="line">  env-&gt;<span class="built_in">GetJavaVM</span>(&amp;gJavaVM);</span><br><span class="line">  <span class="comment">// 创建线程本地存储，指定线程析构函数</span></span><br><span class="line">  <span class="built_in">pthread_key_create</span>(&amp;gKey, &amp;threadDestroy);</span><br><span class="line">  <span class="comment">// 创建线程</span></span><br><span class="line">  <span class="keyword">pthread_t</span> tid;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, &amp;threadTest, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="string">&quot;thread [%ld] create err&quot;</span>, tid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待线程结束</span></span><br><span class="line">  <span class="built_in">pthread_join</span>(tid, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 移除线程本地存储</span></span><br><span class="line">  <span class="built_in">pthread_key_delete</span>(gKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，首先保存 <code>JavaVM</code>，然后启动线程，在线程中使用 <code>GetEnv</code> 函数尝试从线程获得 <code>JNIEnv</code>，返回值将有 3 种结果：</p>
<ol>
<li><code>JNI_OK</code>，说明此线程已附加，可直接使用获得的 <code>JNIEnv</code>；</li>
<li><code>JNI_EDETACHED</code>，说明此线程未附加，那么需要使用 <code>AttachCurrentThread</code> 进行附加；</li>
<li><code>JNI_EVERSION</code>，说明不支持指定的版本。</li>
</ol>
<p>在获得 <code>JNIEnv</code> 之后线程就执行完毕了，那么 <code>pthread_create</code> 中指定的线程析构函数 <code>threadDestroy</code> 将被回调，在这里确认线程已被附加后，使用 <code>DetachCurrentThread</code> 分离线程。</p>
<p><code>AttachCurrentThread</code> 的第 2 个参数一般可以指定为空，它是一个 <code>JavaVMAttachArgs</code> 结构指针，用于指定格外信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jni.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JavaVMAttachArgs</span> &#123;</span></span><br><span class="line">    jint        version;    <span class="comment">/* must be &gt;= JNI_VERSION_1_2 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;       <span class="comment">/* NULL or name of thread as modified UTF-8 str */</span></span><br><span class="line">    jobject     group;      <span class="comment">/* global ref of a ThreadGroup object, or NULL */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="JNI-异常"><a href="#JNI-异常" class="headerlink" title="JNI 异常"></a>JNI 异常</h1><p>当原生代码出现异常挂起时，大多数 JNI 函数无法被调用。通过 C/C++ 代码可以检查到是否出现了异常（通过 <code>ExceptionCheck</code> 或者 <code>ExceptionOccurred</code> 的返回值）；或者直接清除异常。</p>
<p>在异常挂起时，只能调用如下 JNI 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DeleteGlobalRef</span><br><span class="line">DeleteLocalRef</span><br><span class="line">DeleteWeakGlobalRef</span><br><span class="line">ExceptionCheck</span><br><span class="line">ExceptionClear</span><br><span class="line">ExceptionDescribe</span><br><span class="line">ExceptionOccurred</span><br><span class="line">MonitorExit</span><br><span class="line">PopLocalFrame</span><br><span class="line">PushLocalFrame</span><br><span class="line">Release&lt;PrimitiveType&gt;ArrayElements</span><br><span class="line">ReleasePrimitiveArrayCritical</span><br><span class="line">ReleaseStringChars</span><br><span class="line">ReleaseStringCritical</span><br><span class="line">ReleaseStringUTFChars</span><br></pre></td></tr></table></figure>

<p>许多 JNI 调用都会抛出异常，但通常可以使用一种更简单的方法来检查失败调用，例如 <code>NewString</code> 函数返回非空，则表示不需要检查异常。如果使用 <code>CallObjectMethod</code> 函数，则始终必须检查异常，如果系统抛出异常，那么函数返回值无效。</p>
<h3 id="检查异常"><a href="#检查异常" class="headerlink" title="检查异常"></a>检查异常</h3><p>使用 <code>ExceptionCheck</code> 函数可检查上一次代码调用是否出现了异常，如果出现异常，<code>ExceptionCheck</code> 将返回 <code>JNI_TRUE</code>，否则为 <code>JNI_FALSE</code>；或使用 <code>ExceptionOccurred</code> 函数，如果出现异常，它会返回一个 <code>jthrowable</code> 对象，否则为空。</p>
<p>通常使用 <code>ExceptionCheck</code> 函数，因为它不需要创建局部引用（<code>jthrowable</code>）。</p>
<p>在捕获到异常之后，使用 <code>ExceptionDescribe</code> 打印异常信息，如果调用 <code>ExceptionClear</code> 清除异常，那么异常将被忽略（不过在未处理的情况下盲目地忽略异常可能会出现问题）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查异常</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkException</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (env-&gt;<span class="built_in">ExceptionCheck</span>() == JNI_TRUE) &#123;</span><br><span class="line">    env-&gt;<span class="built_in">ExceptionDescribe</span>();</span><br><span class="line">    env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>目前 Android 并不支持 C++ 异常。</p>
<p>JNI 提供了 <code>Throw</code> 和 <code>ThrowNew</code> 用来抛出 Java 异常，但不会在调用后就抛出异常，只是在当前线程中设置了异常指针。从本地代码返回到受虚拟机管理的代码后，会观察到这些异常指针并进行相应处理（抛出异常）。</p>
<p>JNI 没有提供直接操作 Java <code>Throwable</code> 对象本身的内置函数（直接创建对象或者获取异常信息）。</p>
<p>如果想要抛出指定异常，则需要自己找到 <code>Throwable</code> 类后，调用 <code>ThrowNew</code> 函数产生异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出 NullPointerException</span></span><br><span class="line">env-&gt;<span class="built_in">ThrowNew</span>(env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;java/lang/NullPointerException&quot;</span>), msg);</span><br><span class="line"><span class="comment">// 抛出 RuntimeException</span></span><br><span class="line">env-&gt;<span class="built_in">ThrowNew</span>(env-&gt;<span class="built_in">FindClass</span>(env, <span class="string">&quot;java/lang/RuntimeException&quot;</span>), msg);</span><br></pre></td></tr></table></figure>

<p>如果需要获取异常信息，那么需要查找 <code>Throwable#getMessage()</code> 的方法 ID 并调用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/training/articles/perf-jni">https://developer.android.google.cn/training/articles/perf-jni</a></p>
</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Android JNI 指南</p><p><a href="https://l0neman.github.io/2020/07/14/android-jni-指南/">https://l0neman.github.io/2020/07/14/android-jni-指南/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>l0neman</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-07-14</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-07-14</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/android/">Android</a><a class="link-muted mr-2" rel="tag" href="/tags/ndk/">NDK</a><a class="link-muted mr-2" rel="tag" href="/tags/jni/">JNI</a></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f0f12c19a2af379" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/qrcode/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/qrcode/wxpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/07/19/100-%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-github-toc-%E7%94%9F%E6%88%90%E5%99%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">100 行代码实现 GitHub TOC 生成器</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/14/android-ndk-%E6%8C%87%E5%8D%97/"><span class="level-item">Android NDK 指南</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="l0neman/l0neman.github.io" issue-term="pathname" label="comment" theme="github-light" crossorigin="anonymous" async></script></div></div></div><!--!--><div class="column column-right  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#JNI-简介"><span class="level-left"><span class="level-item">2</span><span class="level-item">JNI 简介</span></span></a></li><li><a class="level is-mobile" href="#JNI-优化原则"><span class="level-left"><span class="level-item">3</span><span class="level-item">JNI 优化原则</span></span></a></li><li><a class="level is-mobile" href="#名词说明"><span class="level-left"><span class="level-item">4</span><span class="level-item">名词说明</span></span></a></li><li><a class="level is-mobile" href="#JavaVM-和-JNIEnv"><span class="level-left"><span class="level-item">5</span><span class="level-item">JavaVM 和 JNIEnv</span></span></a></li><li><a class="level is-mobile" href="#JNI-方法注册"><span class="level-left"><span class="level-item">6</span><span class="level-item">JNI 方法注册</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#静态注册"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">静态注册</span></span></a></li><li><a class="level is-mobile" href="#动态注册"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">动态注册</span></span></a></li><li><a class="level is-mobile" href="#类静态方法和类成员方法"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">类静态方法和类成员方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Java-层访问"><span class="level-left"><span class="level-item">7</span><span class="level-item">Java 层访问</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Java-成员变量访问"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">Java 成员变量访问</span></span></a></li><li><a class="level is-mobile" href="#Java-类方法访问"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">Java 类方法访问</span></span></a></li><li><a class="level is-mobile" href="#Java-层访问实例"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">Java 层访问实例</span></span></a></li><li><a class="level is-mobile" href="#访问优化"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">访问优化</span></span></a></li><li><a class="level is-mobile" href="#JNI-类型"><span class="level-left"><span class="level-item">7.5</span><span class="level-item">JNI 类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本数据类型"><span class="level-left"><span class="level-item">7.5.1</span><span class="level-item">基本数据类型</span></span></a></li><li><a class="level is-mobile" href="#引用类型"><span class="level-left"><span class="level-item">7.5.2</span><span class="level-item">引用类型</span></span></a></li><li><a class="level is-mobile" href="#方法和类成员-ID"><span class="level-left"><span class="level-item">7.5.3</span><span class="level-item">方法和类成员 ID</span></span></a></li><li><a class="level is-mobile" href="#数组元素"><span class="level-left"><span class="level-item">7.5.4</span><span class="level-item">数组元素</span></span></a></li></ul></li><li><a class="level is-mobile" href="#引用管理"><span class="level-left"><span class="level-item">7.6</span><span class="level-item">引用管理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#局部引用"><span class="level-left"><span class="level-item">7.6.1</span><span class="level-item">局部引用</span></span></a></li><li><a class="level is-mobile" href="#全局引用"><span class="level-left"><span class="level-item">7.6.2</span><span class="level-item">全局引用</span></span></a></li><li><a class="level is-mobile" href="#提示"><span class="level-left"><span class="level-item">7.6.3</span><span class="level-item">提示</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Java-常用数据访问"><span class="level-left"><span class="level-item">8</span><span class="level-item">Java 常用数据访问</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#访问字符串"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">访问字符串</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#获取字符串"><span class="level-left"><span class="level-item">8.1.1</span><span class="level-item">获取字符串</span></span></a></li><li><a class="level is-mobile" href="#提示-1"><span class="level-left"><span class="level-item">8.1.2</span><span class="level-item">提示</span></span></a></li><li><a class="level is-mobile" href="#返回字符串"><span class="level-left"><span class="level-item">8.1.3</span><span class="level-item">返回字符串</span></span></a></li></ul></li><li><a class="level is-mobile" href="#访问数组"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">访问数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#提示-2"><span class="level-left"><span class="level-item">8.2.1</span><span class="level-item">提示</span></span></a></li><li><a class="level is-mobile" href="#注意"><span class="level-left"><span class="level-item">8.2.2</span><span class="level-item">注意</span></span></a></li><li><a class="level is-mobile" href="#数组区域调用"><span class="level-left"><span class="level-item">8.2.3</span><span class="level-item">数组区域调用</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#线程"><span class="level-left"><span class="level-item">9</span><span class="level-item">线程</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#附加到本地线程"><span class="level-left"><span class="level-item">9.1.1</span><span class="level-item">附加到本地线程</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#JNI-异常"><span class="level-left"><span class="level-item">10</span><span class="level-item">JNI 异常</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#检查异常"><span class="level-left"><span class="level-item">10.1.1</span><span class="level-item">检查异常</span></span></a></li><li><a class="level is-mobile" href="#抛出异常"><span class="level-left"><span class="level-item">10.1.2</span><span class="level-item">抛出异常</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">11</span><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">Android 实用工具</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Android 应用开发</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/android-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">Android 系统原理</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/android-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"><span class="level-start"><span class="level-item">Android 逆向工程</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/"><span class="level-start"><span class="level-item">参考文档</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">实用工具</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">编程基础</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-14T16:18:50.000Z">2021-11-15</time></p><p class="title"><a href="/2021/11/15/staruml-%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95/">StarUML 破解方法</a></p><p class="categories"><a href="/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">实用工具</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-14T15:59:06.000Z">2021-11-14</time></p><p class="title"><a href="/2021/11/14/android-filter-%E5%88%86%E6%9E%90/">Android Filter 分析</a></p><p class="categories"><a href="/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">Android 应用开发</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-29T16:45:50.000Z">2021-06-30</time></p><p class="title"><a href="/2021/06/30/%E6%94%AF%E6%8C%81%E8%A7%A6%E6%91%B8%E6%8B%96%E5%8A%A8%E7%9A%84-touchdelegate/">支持触摸拖动的 TouchDelegate</a></p><p class="categories"><a href="/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">Android 应用开发</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-21T15:08:15.000Z">2021-04-21</time></p><p class="title"><a href="/2021/04/21/gdb-arm-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">GDB ARM 交叉编译环境搭建</a></p><p class="categories"><a href="/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">Android 实用工具</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-21T15:04:39.000Z">2021-04-21</time></p><p class="title"><a href="/2021/04/21/dropbear-android-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/">Dropbear Android 安装步骤</a></p><p class="categories"><a href="/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">Android 实用工具</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/arm/"><span class="tag">ARM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/avd/"><span class="tag">AVD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/activity/"><span class="tag">Activity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">Android</span><span class="tag">24</span></a></div><div class="control"><a class="tags has-addons" href="/tags/assembly/"><span class="tag">Assembly</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/binder/"><span class="tag">Binder</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/classloader/"><span class="tag">ClassLoader</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/computer/"><span class="tag">Computer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dex/"><span class="tag">Dex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elf/"><span class="tag">ELF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/emulator/"><span class="tag">Emulator</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jni/"><span class="tag">JNI</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/log/"><span class="tag">Log</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makefile/"><span class="tag">Makefile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">MarkDown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/metrial/"><span class="tag">Metrial</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ndk/"><span class="tag">NDK</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/regex/"><span class="tag">Regex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">SSH</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/theme/"><span class="tag">Theme</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/touch/"><span class="tag">Touch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/view/"><span class="tag">View</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xposed/"><span class="tag">Xposed</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zygote/"><span class="tag">Zygote</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aapt/"><span class="tag">aapt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uml/"><span class="tag">uml</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"><span class="tag">热修复</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"><span class="tag">热更新</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="l0neman 的博客" height="28"></a><p class="is-size-7"><span>&copy; 2021 l0neman</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/l0neman"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
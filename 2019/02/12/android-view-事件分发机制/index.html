<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Android View 事件分发机制 - l0neman 的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="l0neman 的博客"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="l0neman 的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="触摸事件处理框架Android 的 View 和 ViewGroup 采用了 Composite(组合) 设计模式，View 的组合具有高度动态性，在这种情况下，由于触摸事件是从底层驱动传递至上层 View 对象，如果按照普通对象间传递信息的方式，将会很复杂，很难处理，这里 Android 采用了 Chain of Responsibility（责任链） 设计模式，触摸事件流将通过视图树，使每个"><meta property="og:type" content="blog"><meta property="og:title" content="Android View 事件分发机制"><meta property="og:url" content="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="l0neman 的博客"><meta property="og:description" content="触摸事件处理框架Android 的 View 和 ViewGroup 采用了 Composite(组合) 设计模式，View 的组合具有高度动态性，在这种情况下，由于触摸事件是从底层驱动传递至上层 View 对象，如果按照普通对象间传递信息的方式，将会很复杂，很难处理，这里 Android 采用了 Chain of Responsibility（责任链） 设计模式，触摸事件流将通过视图树，使每个"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180255373.jpg"><meta property="og:image" content="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180324754.jpg"><meta property="og:image" content="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180348020.jpg"><meta property="og:image" content="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180405567.jpg"><meta property="og:image" content="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180420036.jpg"><meta property="og:image" content="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180831881.jpg"><meta property="og:image" content="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180903319.jpg"><meta property="og:image" content="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211181000852.gif"><meta property="og:image" content="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211181046103.gif"><meta property="article:published_time" content="2019-02-12T10:51:31.000Z"><meta property="article:modified_time" content="2019-02-12T10:51:31.000Z"><meta property="article:author" content="l0neman"><meta property="article:tag" content="Android"><meta property="article:tag" content="View"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="./20170211180255373.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},"headline":"Android View 事件分发机制","image":["https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180255373.jpg","https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180324754.jpg","https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180348020.jpg","https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180405567.jpg","https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180420036.jpg","https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180831881.jpg","https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211180903319.jpg","https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211181000852.gif","https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/20170211181046103.gif"],"datePublished":"2019-02-12T10:51:31.000Z","dateModified":"2019-02-12T10:51:31.000Z","author":{"@type":"Person","name":"l0neman"},"publisher":{"@type":"Organization","name":"l0neman 的博客","logo":{"@type":"ImageObject","url":"https://l0neman.github.io/img/logo.png"}},"description":"触摸事件处理框架Android 的 View 和 ViewGroup 采用了 Composite(组合) 设计模式，View 的组合具有高度动态性，在这种情况下，由于触摸事件是从底层驱动传递至上层 View 对象，如果按照普通对象间传递信息的方式，将会很复杂，很难处理，这里 Android 采用了 Chain of Responsibility（责任链） 设计模式，触摸事件流将通过视图树，使每个"}</script><link rel="canonical" href="https://l0neman.github.io/2019/02/12/android-view-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?1727d76e0a823184efc8776f32a916a9";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="l0neman 的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/l0neman"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-three-quarters"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-02-12T10:51:31.000Z" title="2019/2/12 下午6:51:31">2019-02-12</time>发表</span><span class="level-item"><time dateTime="2019-02-12T10:51:31.000Z" title="2019/2/12 下午6:51:31">2019-02-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">Android 应用开发</a></span><span class="level-item">38 分钟读完 (大约5743个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Android View 事件分发机制</h1><div class="content"><h1 id="触摸事件处理框架"><a href="#触摸事件处理框架" class="headerlink" title="触摸事件处理框架"></a>触摸事件处理框架</h1><p>Android 的 View 和 ViewGroup 采用了 Composite(组合) 设计模式，View 的组合具有高度动态性，在这种情况下，由于触摸事件是从底层驱动传递至上层 View 对象，如果按照普通对象间传递信息的方式，将会很复杂，很难处理，这里 Android 采用了 Chain of Responsibility（责任链） 设计模式，触摸事件流将通过视图树，使每个 View 对象都有机会处理事件，一旦某个 View 选择接收事件流，那么整个事件将交给它处理，如果 View 选择不处理，那么事件流会继续传递，直到找到最后的处理者，在处理触摸事件时有几个重要的方法，在弄懂 Android 事件分发机制之前，需要先了解这几个方法的作用及关系。</p>
<span id="more"></span>


<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><ul>
<li>ViewGroup 的三个重载方法</li>
</ul>
<blockquote>
<p><code>boolean dispatchEvent(MotionEvent e)</code> 当触摸事件传递给当前 View 或 ViewGroup 时，此方法将会被调用，它会负责事件的分发工作，可能会将事件交给自己的 <code>onTouchEvent</code> 方法或子View来处理，返回值为是否消耗事件</p>
<p><code>boolean onIntercepteEvent(MotionEvent e)</code> 此方法将被 <code>dispatchEvent</code> 方法调用，返回的是是否拦截此次事件，如果返回 true，事件将被拦截，事件交给自己的 <code>onTouchEvent</code> 处理，子 view 将不能接收到事件，否则交给子view处理，但子 view 可以通过一个方法设置一个标记来阻止事件的拦截。</p>
<p><code>boolean onTouchEvent(MotionEvent e)</code> 负责消耗触摸事件，一般在此处处理触摸事件，返回值为是否消耗事件，若不消耗事件，事件将不会再次被传递，而是交给上层 View 进行处理</p>
</blockquote>
<ul>
<li>View 中存在两个方法，作用和 ViewGroup 相似</li>
</ul>
<blockquote>
<p><code>boolean dispatchEvent(MotionEvent e)</code> 作用和 ViewGroup 类似，由于 View 一定会处理事件，所以 View 不存在 <code>onIntercepteEvent</code> 这个方法，因此 <code>dispatchEvent</code> 最终会将事件交给 <code>onTouchEvent</code> 方法处理</p>
<p><code>boolean onTouchEvent(MotionEvent e)</code> 与 ViewGroup 作用相同</p>
</blockquote>
<h2 id="调用关系"><a href="#调用关系" class="headerlink" title="调用关系"></a>调用关系</h2><p>上面介绍了每个方法的作用，下面用伪代码来描述他们的大致关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 事件交给 viewGroup 的 dispatchTouchEvent 进行处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (onIntercepteEvent(event)) &#123;</span><br><span class="line">    <span class="comment">/* 决定拦截，事件将交给自己处理 */</span></span><br><span class="line">    consume = onTouchEvent(event);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 否则交给子view或viewGroup继续分发事件 */</span></span><br><span class="line">    consume = touchTarget.dispatchTouchEvent();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的伪代码将事件处理模型描述了出来，事件总体是按照这个方式处理的，但涉及到 DOWN，MOVE 等具体事件时还需要详细探讨</p>
<h2 id="触摸事件流向"><a href="#触摸事件流向" class="headerlink" title="触摸事件流向"></a>触摸事件流向</h2><p>上面介绍了触摸事件处理结构，下面介绍当一个触摸事件产生时，触摸事件的传递方向，当触摸屏幕产生触摸事件时，事件将会首先到达顶层 Activity 并交给它的 <code>dispatchTouchEvent</code> 方法来处理，虽然 Activity 不是 View，但它同样具有 <code>dispatchTouchEvent</code>和 <code>onTouchEvent</code> 方法，<code>dispatchTouchEvent</code> 会辗转调用顶层 View 的 <code>dispatchTouchEvent</code> 方法，并传递触摸事件，即开始按照上面伪代码描述的流程来传递事件，如果顶层 View 的 <code>dispatchTouchEvent</code> 返回 <code>false</code> 即事件没有被消耗，则会最终交给 Activity 自身的 <code>onTouchEvent</code> 方法处理</p>
<h1 id="部分方法内部实现"><a href="#部分方法内部实现" class="headerlink" title="部分方法内部实现"></a>部分方法内部实现</h1><p>在遇到事件冲突问题时，通常需要在自定义的 ViewGroup 或 View 中重写部分事件处理方法改变部分原有规则。</p>
<h2 id="Activity-dispatchTouchEvent"><a href="#Activity-dispatchTouchEvent" class="headerlink" title="Activity-dispatchTouchEvent"></a>Activity-dispatchTouchEvent</h2><p>可以看到 Activity 的 <code>dispatchTouchEvent</code> 的处理，就是之前所描述的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    onUserInteraction();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Window 对象将会把事件传递给顶层 view(DecorView)</span></span><br><span class="line">  <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则交给自己</span></span><br><span class="line">  <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="View-dispatchTouchEvent"><a href="#View-dispatchTouchEvent" class="headerlink" title="View-dispatchTouchEvent"></a>View-dispatchTouchEvent</h2><p>View 的 dispatchEventEvent 方法，当 OnTouchListener 未处理事件，事件将交给 onTouchEvent 处理。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123; <span class="comment">// 安全条件过滤后的事件</span></span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>; <span class="comment">// 处理滚动条</span></span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 如果 view 设置了 onTouchListener 并且它消耗了事件，</span></span><br><span class="line">      	<span class="comment">// 那么view 的 onTouchEvent 方法将不会再回调</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP || </span><br><span class="line">        actionMasked == MotionEvent.ACTION_CANCEL || </span><br><span class="line">        (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Viewgroup-onInterceptTouchEvent"><a href="#Viewgroup-onInterceptTouchEvent" class="headerlink" title="Viewgroup-onInterceptTouchEvent"></a>Viewgroup-onInterceptTouchEvent</h2><p>ViewGroup 的 <code>onInterceptTouchEvent</code> 的方法实现，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">        &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">        &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">        &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用的几个布局，包括 <code>LiearnLayout</code>、<code>RelativeLayout</code>、<code>FrameLayout</code>，都没有重写 <code>onInterceptTouchEvent</code> 方法，使用的都是 ViewGroup 的实现，只有在手指或者鼠标触摸时返回 <code>true</code> 选择拦截事件，其他情况都返回  <code>false</code>，不拦截事件，事件将交给子 View 处理，当需要拦截事件交给 ViewGroup 处理的时候，可以重写这个方法，改变它默认的规则。</p>
<h2 id="View-onTouchEvent"><a href="#View-onTouchEvent" class="headerlink" title="View-onTouchEvent"></a>View-onTouchEvent</h2><p>ViewGroup 和 View 使用相同的 <code>onTouchEvent</code> 方法实现，可以看出 View 默认实现了点击事件的处理，对于设置了 DISABLE 属性的 view，如果设置了可点击，例如 <code>CLICKABLE</code> 或 <code>LONGCLICKABLE</code> 属性，则会消耗事件，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">  	<span class="comment">// 当控件为 DISABLED 状态时，如果设置了点击属性，依然会消耗事件</span></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 类似 onTouchListener</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 处理点击事件</span></span><br><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                        focusTaken = requestFocus();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                   &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        postDelayed(mUnsetPressedState,</span><br><span class="line">                                ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                        mUnsetPressedState.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                &#125;</span><br><span class="line">                mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class="line">                <span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">                    mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                    <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingCheckForTap.x = event.getX();</span><br><span class="line">                    mPendingCheckForTap.y = event.getY();</span><br><span class="line">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                    checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                setPressed(<span class="keyword">false</span>);</span><br><span class="line">                removeTapCallback();</span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                drawableHotspotChanged(x, y);</span><br><span class="line">                <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        setPressed(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="ViewGroup-dispatchTouchEvent-分析"><a href="#ViewGroup-dispatchTouchEvent-分析" class="headerlink" title="ViewGroup-dispatchTouchEvent 分析"></a>ViewGroup-dispatchTouchEvent 分析</h1><p>上面是事件分发的流程和参与事件分发的部分方法实现，最后对 ViewGroup 的 dispatchTouchEvent 方法进行分析，它是事件分发机制的核心实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------ part 1 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在 DOWN事件(事件序列开始) 发生时初始化 */</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">      <span class="comment">/* 清空 mFirstTouchTarget */</span></span><br><span class="line">      cancelAndClearTouchTargets(ev);</span><br><span class="line">      <span class="comment">/* 清空状态包括 FLAG_DISALLOW_INTERCEPT */</span></span><br><span class="line">      resetTouchState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">/* FLAG_DISALLOW_INTERCEPT 为子 View 设置的拦截标记 */</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      intercepted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------ part 1 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------ part 2 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) ||</span><br><span class="line">        actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">    TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/*  不是 CANCEL 事件且未拦截 */</span></span><br><span class="line">    <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">      View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">          ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN ||</span><br><span class="line">          (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) ||</span><br><span class="line">          actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">            : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">        removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">          <span class="comment">/* 寻找可以处理事件子View */</span></span><br><span class="line">          <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span> &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">            <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">              i = childrenCount - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 子 View 不能接收事件（VISIBLE或动画执行中 或 事件坐标点未落在子 View 内 */</span></span><br><span class="line">            <span class="keyword">if</span> (!canViewReceivePointerEvents(child) ||</span><br><span class="line">                !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">              ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            newTouchTarget = getTouchTarget(child);</span><br><span class="line">            <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">              newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resetCancelNextUpFlag(child);</span><br><span class="line">            <span class="comment">/* 有子View处理了 DOWN 事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">              mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">              <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                    mLastTouchDownIndex = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mLastTouchDownIndex = childIndex;</span><br><span class="line">              &#125;</span><br><span class="line">              mLastTouchDownX = ev.getX();</span><br><span class="line">              mLastTouchDownY = ev.getY();</span><br><span class="line">              <span class="comment">/* 添加到 TouchTarget 链表头部 */</span></span><br><span class="line">              newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">              alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">/* 没有找到处理事件的子View，赋值最近的子View(链表尾部) */</span></span><br><span class="line">          newTouchTarget = mFirstTouchTarget;</span><br><span class="line">          <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newTouchTarget = newTouchTarget.next;</span><br><span class="line">          &#125;</span><br><span class="line">          newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------ part 2 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------ part 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// TouchTarget 为空，事件交给自己 onTouchEvent</span></span><br><span class="line">      handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>, TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将事件分发给 TouchTarget 链表</span></span><br><span class="line">      TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">      TouchTarget target = mFirstTouchTarget;</span><br><span class="line">      <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">          handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child) || intercepted;</span><br><span class="line">          <span class="comment">/* 如果上次 TouchTarget 处理了事件，而这次被拦截 ，则会分发 CANCEL 事件给子View */</span></span><br><span class="line">          <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">            <span class="comment">// 删除 TouchTarget</span></span><br><span class="line">            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">              mFirstTouchTarget = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              predecessor.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            target.recycle();</span><br><span class="line">            target = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        target = next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------ part 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">      resetTouchState();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">      removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一部分代码</p>
<ol>
<li><p>当 DOWN 事件到来时，清空保存的状态，包括 <code>mFirstTouchTarget</code> 和 重置 <code>FLAG_DISALLOW_INTERCEPT</code> 标志位。</p>
</li>
<li><p>当 DOWN 事件到来时 或 <code>mFisrtTouchTarget</code> 不为空时，会调用 <code>onInterceptTouchEvent</code> 询问是否拦截事件，如果<br><code>FLAG_DISALLOW_INTERCEPT</code> 标志位被设置，则不会拦截事件。</p>
</li>
</ol>
<p>从下一段代码可以获取到，<code>mFisrtTouchTarget</code> 代表是否有子View处理了事件，<code>FLAG_DISALLOW_INTERCEPT</code> 标志位可通过在子<br>View 中调用父 ViewGroup 的 <code>requestDisallowInterceptTouchEvent()</code> 方法来设置</p>
<p>第二部分代码</p>
<p>如果 ViewGroup 未拦截事件，那么开始寻找可以处理事件的子View，即利用 <code>dispatchTransformedTouchEvent</code> 方法把事件分<br>发给子 View，如果子 View 处理了，即子View的 <code>dispatchTouchEvent</code> 返回 <code>true</code>，那么将会调用 <code>addTouchTarget</code> 方法，将子<br>View 加入 <code>TouchTarget</code> 链表中，其中 <code>mFirstTouchTarget</code> 作为链表的头结点，这时 <code>mFirstTouchTarget</code> 被赋值，下次事件，如果<br>子 View 设置，<code>FLAG_DISALLOW_INTERCEPT</code> 标志，则可以阻止 ViewGroup 拦截事件。</p>
<p>在 <code>dispatchTransformedTouchEvent</code> 方法中，如果 <code>child</code> 参数不为空，就会调用子 View 的 <code>dispatchTouchEvent</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 分发 CANCEL 事件 */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">  <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">    event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">      handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    event.setAction(oldAction);</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 分发事件 child 为 null，则交给自己处理 */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">  <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        event.offsetLocation(offsetX, offsetY);</span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">        event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三部分代码则是将事件分发给子 View，如果没有子 View 处理事件，那么交给自己处理，其中如果子 View 处理过事件，但是下次<br>被父 ViewGroup 拦截了，那么 TouchTarget 当前处理事件的这个子 View 节点将被删除，本次会给子 View 分发 CANCEL 事件。</p>
<p>从以上代码分析可得出一些结论；</p>
<ol>
<li><p>如果 ViewGroup 在 DOWN事件 时拦截了事件，那么子 View 再也无法拦截事件，因为<br> <code>actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null</code> 这个条件不会再次被满足。</p>
</li>
<li><p>如果在 DOWN事件 时被设置 <code>FLAG_DISALLOW_INTERCEPT</code>，则可以阻止 ViewGroup 拦截事件。</p>
</li>
</ol>
<h1 id="编码验证"><a href="#编码验证" class="headerlink" title="编码验证"></a>编码验证</h1><p>现在在代码中通过一些用例对上面的分析即结论进行验证。</p>
<p>首先新建一个Activity，再实现它的 <code>onTouchEvent</code> 方法，并打印日志，日志使用了 Logger 开源库，日志更直观一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getActionMasked()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            Logger.d(<span class="string">&quot;activity consume down&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            Logger.d(<span class="string">&quot;activity consume move&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            Logger.d(<span class="string">&quot;activity consume up&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 Activity 布局中加入自定义的 ViewGroup TouchParent， 内部只重写了 <code>onIntercepTouchEvent</code> 和 <code>onTouchEvent</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> eventMasked = ev.getActionMasked();</span><br><span class="line">        <span class="keyword">switch</span> (eventMasked) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> eventMasked = event.getActionMasked();</span><br><span class="line">        <span class="keyword">switch</span> (eventMasked) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                Logger.d(<span class="string">&quot;parent consume down&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                Logger.d(<span class="string">&quot;parent consume move&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                Logger.d(<span class="string">&quot;parent consume up&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的 TouchParent 里面包含了一个自定义的 View TouchChild，它只重写了 <code>onTouchEvent</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> eventMasked = event.getActionMasked();</span><br><span class="line">    <span class="keyword">switch</span> (eventMasked) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            Logger.d(<span class="string">&quot;child consume down&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            Logger.d(<span class="string">&quot;child consume move&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            Logger.d(<span class="string">&quot;child consume up&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好，现在上面都是默认情况，TouchParent 和 TouchChild 都默认处理所有事件，开始测试，现在用手指在 TouchChild 的绿色区域的位置向 TouchParent 的白色区域滑动并抬起手指，如下图</p>
<p><img src="./20170211180255373.jpg"></p>
<ol>
<li>正常情况，TouchParent不拦截事件，那么TouchChild会处理所有事件，结果如下：</li>
</ol>
<p><img src="./20170211180324754.jpg"></p>
<ol start="2">
<li><p>现在把 TouchParent 的 <code>onIntercepTouchEvent</code> 方法改一下，让它“只拦截” DOWN 事件，试试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (eventMasked) &#123;</span><br><span class="line">  	<span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  	<span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  	<span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>结果是：</p>
<p><img src="./20170211180348020.jpg"></p>
<p>   所以为什么是引号呢，这就验证了前面的，当 ViewGroup 决定拦截 DOWN 时，那么所有的事件都会交给它来处理，不会是表面上的只拦截DOWN事件，<code>onInterceptTouchEvent</code> 也将不会再被调用。</p>
<ol start="3">
<li> 在 2 的基础上，把 TouchParent 的 onTouchEvent 的 MOVE 事件改成返回 false，不处理 MOVE 事件看看会怎样</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">     <span class="comment">// Logger.d(&quot;parent consume move&quot;);</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./20170211180405567.jpg"></p>
<p>其中 MOVE 事件由于 TouchParent 没有处理，最终交给了 Activity 处理</p>
<ol start="4">
<li><p>现在把 TouchParent 里的 <code>onInterceptTouchEvent</code> 方法改为 DOWN 事件不拦截，MOVE 和 UP 事件拦截</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> eventMasked = ev.getActionMasked();</span><br><span class="line">        <span class="keyword">switch</span> (eventMasked) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后把 TouchChild 里的 <code>onTouchEvent</code> 方法，在 DOWN 中调用 <code>getParent().requestDisallowInterceptTouchEvent(true);</code> 即，阻止 TouchParent 的事件拦截，测试一下：</p>
</li>
</ol>
<p><img src="./20170211180420036.jpg"></p>
<p>   可以看到，事件完全被TouchChild处理了，因为 TouchChild 使用 <code>requestDisallowInterceptTouchEvent</code> 阻止了 TouchParent 的拦截，不过如果 TouchParent在down 事件里选择拦截的话，那么 TouchChild 将无法进行拦截，这里要注意的是 <code>requestDisallowInterceptTouchEvent</code> 是在 <code>onTouchEvent</code> 里调用的，推荐在 <code>dispatchTouchEvent</code> 方法里进行过拦截，<code>dispatchTouchEvent</code> 是必然会接受到事件的，而 <code>onTouchEvent</code> 可能受到 OnTouchListener 的影响而不被调用。</p>
<ol start="5">
<li>现在再在4的基础上在 TouchChild 里面的 <code>onTouchEvent</code> 里 MOVE 事件里调用 <code>getParent().requestDisallowInterceptTouchEvent(false);</code> 把事件还给TouchParent会怎样</li>
</ol>
<p><img src="./20170211180831881.jpg"></p>
<p>   这里多做了一次 MOVE 事件，为了看的更清楚，当 TouchChild 在 DOWN 事件里阻拦了 TouchParent 的时候，TouchChild 将会处理下一个 MOVE，在这里TouchChild有把事件交还给 TouchParent，这时 TouchParent 拦截了MOVE 事件，事件将会交给 TouchParent 来处理，但是很奇怪为什么会下一个 MOVE 会被 Activity 处理呢，然后才是 TouchParent 处理 MOVE，因为从前面的结论可以知道，上次是 TouchChild 处理的事件，这次被拦截的话，此次的事件将会变成一个 CANCEL 事件并分发给子 view，这里 TouchChild 没有处理 CANCEL 事件，所以最终交给了 Activity 处理，现在让 TouchChild 处理 CANCEL</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">    Logger.d(<span class="string">&quot;child consume cancel&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./20170211180903319.jpg"></p>
<p>好了，事件确实是 CANCEL 事件，这次被 TouchChild 消耗了，Activity 就不会处理了</p>
<p>以上测试了几个典型例子，对结论进行了论证，下面是Android事件分发机制在处理事件冲突时的应用。</p>
<h1 id="触摸事件冲突处理"><a href="#触摸事件冲突处理" class="headerlink" title="触摸事件冲突处理"></a>触摸事件冲突处理</h1><p>一般在项目中可能会遇到界面比较复杂的情况，而且可能是可滑动的布局相互嵌套的情况，比如，ScrollView 里面有一个 ListView，两个 view 都是纵向划动的，一定会有冲突，还有 ViewPager 里面有 ScrollView，或 ScrollView 里面有 ViewPager，这两个是横向和纵向划动的冲突，这种情况可能与用户体验相关，应该根据滑动的动作来决定事件交给哪个 View 来处理，为了解决这个问题，就需要对事件分发机制有所熟悉。</p>
<p>​    例如或 ScrollView 里面有 ViewPager 这种情况，当用户偏向横划的时候，相应的 ViewPager 就要做出内容的偏移，当用户偏向竖划的时后，ScrollView 就要滚动里面的内容，针对这种情况，就产生了一个判断条件，就是用户横向或纵向划动，转化为逻辑就是，MOVE 事件时 x 和 y 轴 滑动距离相比较，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; y <span class="comment">/*横向滑动*/</span>) &#123;</span><br><span class="line">    <span class="comment">// ViewPager滚动</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="comment">/*纵向滑动*/</span>&#123;</span><br><span class="line">    <span class="comment">// ScrollView滚动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那就是说，x &gt; y 时，ViewPager会拦截 ScrollView 的事件，自己来处理，否则 ScrollView 拦截 ViewPager 的事件，自己来处理</p>
<p>针对此情况，一般有两种拦截的方法，也就是触摸事件冲突处理的方法。</p>
<h2 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h2><p>外部拦截法以嵌套布局外层 ViewGroup 为主，重写 <code>onInterceptTouchEvent</code> 方法，事件是否拦截，完全由 ViewGroup 决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterceptTouch</span><span class="params">(MotionEvent ev)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*是否拦截*/</span></span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">switch</span>(event.getAction())&#123;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">        <span class="comment">/*不拦截Down事件*/</span></span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">        <span class="keyword">if</span>(父容器自身需要此事件)&#123;</span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">        <span class="comment">/*不拦截Up事件,没有意义*/</span></span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法的事件决定权完全在外部 ViewGroup 上，其中为什么不拦截 DOWN 事件呢，因为一旦拦截，那么事件就一定会给自己处理了，子 View 就没有选择的余地了。</p>
<h2 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h2><p>内部拦截法以嵌套布局内层 View 为主，主要重写子 View 的 <code>dispatchTouchEvent</code> 方法，这种方法需要 ViewGroup 不拦截 DOWN 事件，然后通过调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent</code> 来控制事件传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*子View*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event.getAction())&#123;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">        <span class="comment">/*使父View不再调用事件拦截*/</span></span><br><span class="line">        parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">        <span class="keyword">if</span>(<span class="comment">/*还给父view事件*/</span>)&#123;</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实在 ScrollView 里面有 ViewPager 这种情况，源码里已经了处理，所以用的时候没有任何问题，下面截取了 ViewPager 的 <code>onInterceptTouchEvent</code> 的部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	* Remember location of down touch.</span></span><br><span class="line"><span class="comment">    * ACTION_DOWN always refers to pointer index 0.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    mLastMotionX = mInitialMotionX = ev.getX();</span><br><span class="line">    mLastMotionY = mInitialMotionY = ev.getY();</span><br><span class="line">    mActivePointerId = ev.getPointerId(<span class="number">0</span>);</span><br><span class="line">    mIsUnableToDrag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    mIsScrollStarted = <span class="keyword">true</span>;</span><br><span class="line">    mScroller.computeScrollOffset();</span><br><span class="line">    <span class="keyword">if</span> (mScrollState == SCROLL_STATE_SETTLING</span><br><span class="line">      	&amp;&amp; Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) &gt; mCloseEnough) &#123;</span><br><span class="line">        <span class="comment">// Let the user &#x27;catch&#x27; the pager as it animates.</span></span><br><span class="line">        mScroller.abortAnimation();</span><br><span class="line">        mPopulatePending = <span class="keyword">false</span>;</span><br><span class="line">        populate();</span><br><span class="line">        mIsBeingDragged = <span class="keyword">true</span>;</span><br><span class="line">        requestParentDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">        setScrollState(SCROLL_STATE_DRAGGING);</span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	completeScroll(<span class="keyword">false</span>);</span><br><span class="line">    	mIsBeingDragged = <span class="keyword">false</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line"> 	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现在 DOWN 事件中有一个 <code>requestParentDisallowInterceptTouchEvent(true)</code>，这里就是拦截外层 View 使用的内部拦截法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestParentDisallowInterceptTouchEvent</span><span class="params">(<span class="keyword">boolean</span> disallowIntercept)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ViewParent parent = getParent();</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际运用中，需要对于情况来选择合适的方法。</p>
<h1 id="事件冲突处理实例"><a href="#事件冲突处理实例" class="headerlink" title="事件冲突处理实例"></a>事件冲突处理实例</h1><p>这里假设一种情况，ScrollView 里面有一个 ListView，这两个 View 嵌套一定会出现问题，首先正常的在 Activity 里面放上一个 ScrollView 然后在里面放上一个 ListView，其中 ScrollView 是可以滚动的，ListView 高度限制为 200dp，内部子元素有 20 个，代码很简单，核心部分如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ListView listView = (ListView)findViewById(R.id.lv_content);</span><br><span class="line">listView.setAdapter(</span><br><span class="line">    <span class="keyword">new</span> BaseAdapter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123; <span class="keyword">return</span> position; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">          TextView textView = <span class="keyword">new</span> TextView(parent.getContext());</span><br><span class="line">          textView.setLayoutParams(<span class="keyword">new</span> AbsListView.LayoutParams(</span><br><span class="line">              ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">              ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">          ));</span><br><span class="line">          textView.setTextSize(<span class="number">45</span>);</span><br><span class="line">          textView.setTextColor(Color.WHITE);</span><br><span class="line">          textView.setGravity(Gravity.CENTER);</span><br><span class="line">          textView.setText(<span class="string">&quot;item&quot;</span> + position);</span><br><span class="line">          convertView = textView;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ((TextView)convertView).setText(<span class="string">&quot;item&quot;</span> + position);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> convertView;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>运行一下</p>
<p><img src="./20170211181000852.gif"></p>
<p>会发现 ListView 根本无法滑动，肯定是 MOVE 事件完全被 ScrollView 拦截了，导致 ListView 接收不到事件，也就无法响应滑动，DOWN事件一般是不会被 ScrollView 拦截的，现在就想办法让 ListView 滑动，解决它们的冲突</p>
<p>首先需要一个条件，就是什么时候让 ListView 滑动，什么时候再把事件交还给 ScrollView，让它继续滑动，那么现在条件是这样，当手指落在 ListView 上并移动时，ListView 完全处理 MOVE 事件，当 ListView 达到底部的极限时且手指继续向上滑动 或 当 ListView 达到顶部的极限时且手指继续向下滑动把事件交给 ScrollView 处理，针对这个条件，发现决定事件的主要是 ListView，那么这里采用内部拦截法，重写 ListView 的事件处理方法，下面是完整代码和实现效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TouchListView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TouchListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TouchListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLastY;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> eventMasked = ev.getActionMasked();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">        <span class="keyword">switch</span> (eventMasked) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mLastY = y;</span><br><span class="line">                <span class="comment">// 拦截事件</span></span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">if</span> (y &lt; mLastY &amp;&amp; checkScrollBottomLimit(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 当ListView达到底部的极限时且手指继续向上滑动，释放事件</span></span><br><span class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; mLastY &amp;&amp; checkScrollTopLimit(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 当ListView达到顶部的极限时且手指继续向下滑动，释放事件</span></span><br><span class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mLastY = y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断ListView是否滚动到了底部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listView target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 滚动到了底部返回true，否则false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkScrollBottomLimit</span><span class="params">(ListView listView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listView.getLastVisiblePosition() == listView.getCount() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> View lastChild = listView.getChildAt(</span><br><span class="line">                    listView.getChildCount() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> lastChildBottom = listView.getTop() + lastChild.getBottom();</span><br><span class="line">            <span class="keyword">if</span> (lastChildBottom == listView.getBottom()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断ListView是否滚动到了顶部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listView target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 滚动到了顶部返回true，否则false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkScrollTopLimit</span><span class="params">(ListView listView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listView.getFirstVisiblePosition() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> View lastChild = listView.getChildAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (lastChild.getTop() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./20170211181046103.gif"></p>
<p>感觉有点别扭，例如当 ListView 达到底部的极限时且手指继续向上滑动，释放事件，ScrollView 继续滚动，但是要再向下滑动时，手指还在ListView上，按自然滑动的规则 ListView 内容应该向下滚动，但这时事件还是 ScrollView 在处理，所以它会跟着手一起滚动，这里可以用另一种比较麻烦的方法，将事件直接通过 ListView 的对象，调用它的 <code>onTouchEvent</code> 传递过去，这个问题先留下来。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Android View 事件分发机制</p><p><a href="https://l0neman.github.io/2019/02/12/android-view-事件分发机制/">https://l0neman.github.io/2019/02/12/android-view-事件分发机制/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>l0neman</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-02-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2019-02-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/android/">Android</a><a class="link-muted mr-2" rel="tag" href="/tags/view/">View</a></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f0f12c19a2af379" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/qrcode/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/qrcode/wxpay.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/02/14/android-arsc-%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android arsc 文件解析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/02/12/android-%E5%9D%90%E6%A0%87%E7%B3%BB%E5%92%8C-view-%E6%BB%91%E5%8A%A8%E6%96%B9%E6%B3%95/"><span class="level-item">Android 坐标系和 View 滑动方法</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="l0neman/l0neman.github.io" issue-term="pathname" label="comment" theme="github-light" crossorigin="anonymous" async></script></div></div></div><!--!--><div class="column column-right  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#触摸事件处理框架"><span class="level-left"><span class="level-item">1</span><span class="level-item">触摸事件处理框架</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#核心方法"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">核心方法</span></span></a></li><li><a class="level is-mobile" href="#调用关系"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">调用关系</span></span></a></li><li><a class="level is-mobile" href="#触摸事件流向"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">触摸事件流向</span></span></a></li></ul></li><li><a class="level is-mobile" href="#部分方法内部实现"><span class="level-left"><span class="level-item">2</span><span class="level-item">部分方法内部实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Activity-dispatchTouchEvent"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Activity-dispatchTouchEvent</span></span></a></li><li><a class="level is-mobile" href="#View-dispatchTouchEvent"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">View-dispatchTouchEvent</span></span></a></li><li><a class="level is-mobile" href="#Viewgroup-onInterceptTouchEvent"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Viewgroup-onInterceptTouchEvent</span></span></a></li><li><a class="level is-mobile" href="#View-onTouchEvent"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">View-onTouchEvent</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ViewGroup-dispatchTouchEvent-分析"><span class="level-left"><span class="level-item">3</span><span class="level-item">ViewGroup-dispatchTouchEvent 分析</span></span></a></li><li><a class="level is-mobile" href="#编码验证"><span class="level-left"><span class="level-item">4</span><span class="level-item">编码验证</span></span></a></li><li><a class="level is-mobile" href="#触摸事件冲突处理"><span class="level-left"><span class="level-item">5</span><span class="level-item">触摸事件冲突处理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#外部拦截法"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">外部拦截法</span></span></a></li><li><a class="level is-mobile" href="#内部拦截法"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">内部拦截法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#事件冲突处理实例"><span class="level-left"><span class="level-item">6</span><span class="level-item">事件冲突处理实例</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">Android 实用工具</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Android 应用开发</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/android-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">Android 系统原理</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/android-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"><span class="level-start"><span class="level-item">Android 逆向工程</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/"><span class="level-start"><span class="level-item">参考文档</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">实用工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">编程基础</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-29T16:45:50.000Z">2021-06-30</time></p><p class="title"><a href="/2021/06/30/%E6%94%AF%E6%8C%81%E8%A7%A6%E6%91%B8%E6%8B%96%E5%8A%A8%E7%9A%84-touchdelegate/">支持触摸拖动的 TouchDelegate</a></p><p class="categories"><a href="/categories/android-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">Android 应用开发</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-21T15:08:15.000Z">2021-04-21</time></p><p class="title"><a href="/2021/04/21/gdb-arm-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">GDB ARM 交叉编译环境搭建</a></p><p class="categories"><a href="/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">Android 实用工具</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-21T15:04:39.000Z">2021-04-21</time></p><p class="title"><a href="/2021/04/21/dropbear-android-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/">Dropbear Android 安装步骤</a></p><p class="categories"><a href="/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">Android 实用工具</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-21T14:49:48.000Z">2021-04-21</time></p><p class="title"><a href="/2021/04/21/material-design-%E5%8F%82%E8%80%83/">Material Design 参考</a></p><p class="categories"><a href="/categories/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/">参考文档</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-21T10:20:58.000Z">2021-04-21</time></p><p class="title"><a href="/2021/04/21/android-avd-%E4%BD%8D%E7%BD%AE%E4%BF%AE%E6%94%B9/">Android AVD 位置修改</a></p><p class="categories"><a href="/categories/android-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">Android 实用工具</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/arm/"><span class="tag">ARM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/avd/"><span class="tag">AVD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/activity/"><span class="tag">Activity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">Android</span><span class="tag">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/assembly/"><span class="tag">Assembly</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/binder/"><span class="tag">Binder</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/classloader/"><span class="tag">ClassLoader</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/computer/"><span class="tag">Computer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dex/"><span class="tag">Dex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elf/"><span class="tag">ELF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/emulator/"><span class="tag">Emulator</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jni/"><span class="tag">JNI</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/log/"><span class="tag">Log</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/make/"><span class="tag">Make</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makefile/"><span class="tag">Makefile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">MarkDown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/metrial/"><span class="tag">Metrial</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ndk/"><span class="tag">NDK</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/regex/"><span class="tag">Regex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">SSH</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/theme/"><span class="tag">Theme</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/touch/"><span class="tag">Touch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/view/"><span class="tag">View</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xposed/"><span class="tag">Xposed</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zygote/"><span class="tag">Zygote</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aapt/"><span class="tag">aapt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"><span class="tag">热修复</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"><span class="tag">热更新</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="l0neman 的博客" height="28"></a><p class="is-size-7"><span>&copy; 2021 l0neman</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/l0neman"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>